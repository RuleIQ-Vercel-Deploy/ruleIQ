"""
Security endpoints for ruleIQ API.

Provides endpoints for role-based access control, security testing, and vulnerability checks.
"""

from typing import Any, Dict, List
from fastapi import APIRouter, Depends, HTTPException, status, Request
from pydantic import BaseModel

from api.dependencies.auth import get_current_active_user
from api.middleware.rate_limiter import rate_limit
from database.user import User

router = APIRouter()


# Request/Response Models
class RoleCheckRequest(BaseModel):
    resource: str
    action: str
    context: Dict[str, Any] = {}


class SecurityTestRequest(BaseModel):
    test_type: str
    parameters: Dict[str, Any] = {}


class SecurityTestResponse(BaseModel):
    test_passed: bool
    vulnerabilities: List[Dict[str, Any]]
    recommendations: List[str]
    risk_level: str


@router.get("/role-based-access-control")
async def role_based_access_control(
    resource: str = "default",
    action: str = "read",
    current_user: User = Depends(get_current_active_user),
):
    """
    Test role-based access control functionality.
    Returns access permissions for the current user.
    """
    try:
        # Mock RBAC implementation for testing
        user_roles = getattr(current_user, "roles", ["user"])

        # Define role permissions
        role_permissions = {
            "admin": ["read", "write", "delete", "manage"],
            "manager": ["read", "write"],
            "user": ["read"],
            "viewer": ["read"],
        }

        # Check if user has permission
        allowed_actions = []
        for role in user_roles:
            if role in role_permissions:
                allowed_actions.extend(role_permissions[role])

        has_permission = action in allowed_actions

        return {
            "user_id": str(current_user.id),
            "user_roles": user_roles,
            "resource": resource,
            "action": action,
            "has_permission": has_permission,
            "allowed_actions": list(set(allowed_actions)),
            "access_level": "granted" if has_permission else "denied",
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"RBAC check failed: {str(e)}")


@router.post("/business-logic-vulnerabilities")
async def business_logic_vulnerabilities(
    request: SecurityTestRequest, current_user: User = Depends(get_current_active_user)
):
    """
    Test for business logic vulnerabilities.
    Returns security assessment results.
    """
    try:
        # Check if user has admin privileges for security testing
        user_roles = getattr(current_user, "roles", ["user"])
        if "admin" not in user_roles and "security_tester" not in user_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient privileges for security testing",
            )

        # Mock security vulnerability assessment
        test_type = request.test_type
        vulnerabilities = []
        recommendations = []
        risk_level = "low"

        if test_type == "injection":
            vulnerabilities.append(
                {
                    "type": "SQL Injection",
                    "severity": "medium",
                    "description": "Potential SQL injection vulnerability in search parameters",
                }
            )
            recommendations.append("Use parameterized queries")
            risk_level = "medium"

        elif test_type == "authorization":
            vulnerabilities.append(
                {
                    "type": "Broken Access Control",
                    "severity": "high",
                    "description": "Insufficient authorization checks on sensitive endpoints",
                }
            )
            recommendations.append("Implement proper RBAC checks")
            risk_level = "high"

        test_passed = len(vulnerabilities) == 0

        return SecurityTestResponse(
            test_passed=test_passed,
            vulnerabilities=vulnerabilities,
            recommendations=recommendations,
            risk_level=risk_level,
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Security test failed: {str(e)}")


@router.get("/security-status")
async def security_status(current_user: User = Depends(get_current_active_user)):
    """
    Get overall security status and health metrics.
    """
    try:
        return {
            "security_level": "high",
            "last_security_scan": "2024-01-01T00:00:00Z",
            "vulnerabilities_found": 0,
            "security_score": 95,
            "compliance_status": "compliant",
            "recommendations": [
                "Regular security audits",
                "Keep dependencies updated",
                "Monitor access logs",
            ],
        }
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Security status check failed: {str(e)}"
        )


@router.get(
    "/rate-limit-test", dependencies=[Depends(rate_limit(requests_per_minute=5))]
)
async def rate_limit_test(current_user: User = Depends(get_current_active_user)):
    """
    Test endpoint for rate limiting functionality.
    Limited to 5 requests per minute for testing.
    """
    return {
        "message": "Rate limit test successful",
        "user_id": str(current_user.id),
        "timestamp": "2024-01-01T00:00:00Z",
        "rate_limit": "5 requests per minute",
    }


# Initialize CSP violation handler
from middleware.security_headers import CSPViolationHandler

# Global handler instance with in-memory storage
csp_handler = CSPViolationHandler()


@router.post("/csp-report", status_code=204, include_in_schema=False)
async def handle_csp_violation(request: Request):
    """
    Handle Content Security Policy violation reports

    This endpoint receives CSP violation reports from browsers when content
    violates the configured Content Security Policy.
    """
    return await csp_handler.handle_violation(request)


@router.get("/csp-violations", response_model=Dict[str, Any])
async def get_csp_violations(current_user: User = Depends(get_current_active_user)):
    """
    Get CSP violation summary (Admin only)

    Returns a summary of Content Security Policy violations including:
    - Total violation count
    - Violations grouped by directive
    - Violations grouped by blocked URI
    - Recent violations
    """
    # Check if user has admin role
    if current_user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only administrators can view CSP violations",
        )
    return csp_handler.get_violations_summary()


@router.delete("/csp-violations", response_model=Dict[str, str])
async def clear_csp_violations(current_user: User = Depends(get_current_active_user)):
    """
    Clear CSP violation history (Admin only)

    Clears all stored CSP violation reports from memory.
    """
    # Check if user has admin role
    if current_user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only administrators can clear CSP violations",
        )
    csp_handler.violations.clear()
    return {"message": "CSP violation history cleared successfully"}
