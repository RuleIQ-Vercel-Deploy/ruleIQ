# Story S0-2.3: Add Concurrent Operation Tests for YOLO System

## Story
**As a** QA engineer  
**I want** comprehensive tests for concurrent agent operations  
**So that** we can ensure the system handles parallel workflows without deadlocks or race conditions

## Status
- **State**: READY
- **Priority**: P2 (Medium - Test Coverage)
- **Points**: 5
- **Sprint**: Next

## Acceptance Criteria
- [ ] Test multiple agents running simultaneously
- [ ] Test context conflicts between parallel agents
- [ ] Test state management under concurrent access
- [ ] Test handoff collisions and queuing
- [ ] Test resource contention scenarios
- [ ] All tests must be deterministic and reproducible

## Technical Details

### Test Scenarios to Implement

1. **Parallel Agent Execution**
```python
async def test_parallel_agents():
    """Test multiple agents working simultaneously."""
    orchestrator = YOLOOrchestrator()
    await orchestrator.activate()
    
    # Start multiple agent workflows
    tasks = [
        orchestrator.run_agent(AgentType.DEV),
        orchestrator.run_agent(AgentType.QA),
        orchestrator.run_agent(AgentType.SECURITY)
    ]
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    assert all(not isinstance(r, Exception) for r in results)
```

2. **Context Race Conditions**
```python
async def test_context_race_conditions():
    """Test context updates from multiple agents."""
    context_manager = ContextRefreshSystem()
    
    async def add_context_items(agent: str, count: int):
        for i in range(count):
            context_manager.add_context(
                f"item_{i}",
                f"Content from {agent}",
                ContextPriority.HIGH,
                agent
            )
            await asyncio.sleep(0.001)  # Simulate work
    
    # Multiple agents adding context simultaneously
    await asyncio.gather(
        add_context_items("dev", 100),
        add_context_items("qa", 100),
        add_context_items("pm", 100)
    )
    
    # Verify all items were added correctly
    stats = context_manager.get_statistics()
    assert stats["total_items"] == 300
```

3. **Handoff Collision Test**
```python
async def test_handoff_collision():
    """Test simultaneous handoff attempts."""
    orchestrator = YOLOOrchestrator()
    await orchestrator.activate()
    
    # Two agents trying to hand off to the same target
    orchestrator.state.current_agent = AgentType.PM
    
    async def attempt_handoff(from_agent: AgentType):
        orchestrator.state.current_agent = from_agent
        return await orchestrator.handoff(AgentType.DEV)
    
    # Should handle gracefully without corruption
    results = await asyncio.gather(
        attempt_handoff(AgentType.PM),
        attempt_handoff(AgentType.ARCHITECT),
        return_exceptions=True
    )
```

4. **State File Lock Test**
```python
async def test_state_file_locking():
    """Test concurrent state file access."""
    orchestrator1 = YOLOOrchestrator()
    orchestrator2 = YOLOOrchestrator()
    
    # Both trying to save state simultaneously
    await asyncio.gather(
        orchestrator1._save_state(),
        orchestrator2._save_state()
    )
    
    # State should be consistent
    loaded_state = orchestrator1._load_state()
    assert loaded_state is not None
```

### Files to Create/Update
1. Create `/home/omar/Documents/ruleIQ/.bmad-core/yolo/tests/test_concurrent_operations.py`
2. Update `/home/omar/Documents/ruleIQ/.bmad-core/yolo/yolo-system.py`
   - Add thread-safe state management
   - Add async locks where needed

### Required Utilities
```python
import asyncio
import threading
from asyncio import Lock

class ThreadSafeOrchestrator(YOLOOrchestrator):
    def __init__(self):
        super().__init__()
        self._state_lock = Lock()
        self._handoff_lock = Lock()
    
    async def handoff(self, to_agent: AgentType, **kwargs):
        async with self._handoff_lock:
            return await super().handoff(to_agent, **kwargs)
```

## Dependencies
- Stories S0-2.1 and S0-2.2 should be completed first
- May require asyncio testing utilities

## Testing
- Run tests with pytest-asyncio
- Use pytest-timeout for deadlock detection
- Measure test execution time for performance regression
- Run tests multiple times to ensure stability

## Definition of Done
- [ ] All concurrent test scenarios implemented
- [ ] Tests are deterministic (no flaky tests)
- [ ] Thread-safety measures added where needed
- [ ] Documentation includes concurrency considerations
- [ ] Performance benchmarks established
- [ ] CI pipeline updated to run concurrent tests