# TODO Tracking Document

Generated: 2025-09-02T14:17:45.371488

## Summary

- Python TODOs remaining: 17
- JavaScript TODOs remaining: 396
- TypeScript TODOs remaining: 549

## Python TODOs

- `./fix-todos.py:33` - if '# TODO' in line or '#TODO' in line:
- `./fix-todos.py:152` - f.write("# TODO Tracking Document\n\n")
- `./api/routers/webhooks.py:39` - # TODO: Update user subscription status in database
- `./api/routers/webhooks.py:48` - # TODO: Create subscription record in database
- `./api/routers/webhooks.py:56` - # TODO: Update subscription status in database
- `./api/routers/webhooks.py:64` - # TODO: Send notification to customer
- `./api/routers/webhooks.py:80` - # TODO: Trigger CI/CD or notifications
- `./api/routers/webhooks.py:88` - # TODO: Trigger code review or checks
- `./api/routers/webhooks.py:96` - # TODO: Update issue tracking
- `./api/routers/webhooks.py:113` - # TODO: Update email status in database
- `./api/routers/webhooks.py:119` - # TODO: Mark email as invalid
- `./api/routers/webhooks.py:124` - # TODO: Update user preferences
- `./api/routers/webhooks.py:129` - # TODO: Update subscription preferences
- `./api/routers/webhooks.py:347` - # TODO: Load webhook configuration from database based on webhook_id
- `./api/routers/webhooks.py:371` - # TODO: Process custom webhook based on webhook_id configuration
- `./tests/test_services.py:176` - # TODO: Investigate where 'assess_compliance_requirements' logic resides or if this test is obsolete.
- `./tests/integration/api/test_freemium_endpoints.py:28` - # TODO: These functions are not implemented yet - using mock versions

## JavaScript TODOs

- `./frontend/.next/static/chunks/main-app.js:18` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sentry_nextjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/nextjs */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+nextjs@9.46.0_@opentelemetry+context-async-hooks@1.30.1_@opentelemetry+api@1.9._42796a51c56a345b0bf099c431630b51/node_modules/@sentry/nextjs/build/esm/index.client.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_@babel+core@7.28.3_@opentelemetry+api@1.9.0_@playwright+test@1.55.0_react-d_5cb839d67a79b5bc53dfde1d42b0ad7b/node_modules/next/dist/build/polyfills/process.js\");\nglobalThis[\"_sentryRewritesTunnelPath\"] = \"/monitoring\";\nglobalThis[\"SENTRY_RELEASE\"] = undefined;\nglobalThis[\"_sentryBasePath\"] = undefined;\nglobalThis[\"_sentryRewriteFramesAssetPrefixPath\"] = \"\";\nglobalThis[\"_sentryAssetPrefix\"] = undefined;\nglobalThis[\"_sentryExperimentalThirdPartyOriginStackFrames\"] = undefined;\nglobalThis[\"_sentryRouteManifest\"] = \"{\\\"dynamicRoutes\\\":[{\\\"path\\\":\\\"/assessments/:id\\\",\\\"regex\\\":\\\"^/assessments/([^/]+)$\\\",\\\"paramNames\\\":[\\\"id\\\"]},{\\\"path\\\":\\\"/assessments/:id/results\\\",\\\"regex\\\":\\\"^/assessments/([^/]+)/results$\\\",\\\"paramNames\\\":[\\\"id\\\"]},{\\\"path\\\":\\\"/assessment/results/:token\\\",\\\"regex\\\":\\\"^/assessment/results/([^/]+)$\\\",\\\"paramNames\\\":[\\\"token\\\"]}],\\\"staticRoutes\\\":[{\\\"path\\\":\\\"/\\\"},{\\\"path\\\":\\\"/forgot-password\\\"},{\\\"path\\\":\\\"/login\\\"},{\\\"path\\\":\\\"/register\\\"},{\\\"path\\\":\\\"/signup\\\"},{\\\"path\\\":\\\"/signup-traditional\\\"},{\\\"path\\\":\\\"/analytics\\\"},{\\\"path\\\":\\\"/assessments\\\"},{\\\"path\\\":\\\"/assessments/new\\\"},{\\\"path\\\":\\\"/business-profile\\\"},{\\\"path\\\":\\\"/chat\\\"},{\\\"path\\\":\\\"/chat-test\\\"},{\\\"path\\\":\\\"/checkout\\\"},{\\\"path\\\":\\\"/compliance-wizard\\\"},{\\\"path\\\":\\\"/components\\\"},{\\\"path\\\":\\\"/dashboard\\\"},{\\\"path\\\":\\\"/dashboard-custom\\\"},{\\\"path\\\":\\\"/data-export-demo\\\"},{\\\"path\\\":\\\"/evidence\\\"},{\\\"path\\\":\\\"/forms\\\"},{\\\"path\\\":\\\"/loading-states\\\"},{\\\"path\\\":\\\"/modals\\\"},{\\\"path\\\":\\\"/policies\\\"},{\\\"path\\\":\\\"/policies/new\\\"},{\\\"path\\\":\\\"/pricing\\\"},{\\\"path\\\":\\\"/reports\\\"},{\\\"path\\\":\\\"/settings/billing\\\"},{\\\"path\\\":\\\"/settings/integrations\\\"},{\\\"path\\\":\\\"/settings/team\\\"},{\\\"path\\\":\\\"/test-quick-actions\\\"},{\\\"path\\\":\\\"/freemium\\\"},{\\\"path\\\":\\\"/freemium/assessment\\\"},{\\\"path\\\":\\\"/freemium/results\\\"},{\\\"path\\\":\\\"/assessment\\\"},{\\\"path\\\":\\\"/auth/callback\\\"},{\\\"path\\\":\\\"/demo/error-boundary\\\"},{\\\"path\\\":\\\"/demo/file-upload\\\"},{\\\"path\\\":\\\"/demo/loading-states\\\"},{\\\"path\\\":\\\"/design-system\\\"},{\\\"path\\\":\\\"/editor\\\"},{\\\"path\\\":\\\"/marketing\\\"},{\\\"path\\\":\\\"/monitoring/test-error\\\"},{\\\"path\\\":\\\"/showcase/components\\\"},{\\\"path\\\":\\\"/test-theme\\\"}]}\";\n\n// Only initialize Sentry if a valid DSN is provided\nconst sentryDsn = process.env['NEXT_PUBLIC_SENTRY_DSN'];\nconst isValidDsn = sentryDsn && sentryDsn !== 'https://your-dsn@sentry.io/project-id' && sentryDsn.startsWith('https://') && sentryDsn.includes('@sentry.io');\nif (isValidDsn) {\n    _sentry_nextjs__WEBPACK_IMPORTED_MODULE_0__.init({\n        dsn: sentryDsn,\n        // Adjust this value in production, or use tracesSampler for greater control\n        tracesSampleRate:  false ? 0 : 1.0,\n        // Configure browser tracing\n        integrations: [\n            _sentry_nextjs__WEBPACK_IMPORTED_MODULE_0__.browserTracingIntegration({\n                // Set up automatic route change tracking in Next.js App Router\n                instrumentNavigation: true,\n                instrumentPageLoad: true\n            }),\n            _sentry_nextjs__WEBPACK_IMPORTED_MODULE_0__.replayIntegration({\n                // Capture 10% of the sessions in production\n                replaysSessionSampleRate:  false ? 0 : 1.0,\n                // Of those, capture 100% of error sessions\n                replaysOnErrorSampleRate: 1.0\n            })\n        ],\n        // Environment configuration\n        environment: \"development\",\n        // Release tracking\n        release: process.env['NEXT_PUBLIC_SENTRY_DSN'] || 'ruleiq-frontend@unknown',\n        // Performance Monitoring\n        tracesSampler: (samplingContext)=>{\n            var _location_pathname;\n            // Adjust sample rates based on context\n            const { location } = samplingContext;\n            if ((location === null || location === void 0 ? void 0 : location.pathname) === '/api/health') {\n                return 0.1; // Lower sampling for health checks\n            }\n            if (location === null || location === void 0 ? void 0 : (_location_pathname = location.pathname) === null || _location_pathname === void 0 ? void 0 : _location_pathname.startsWith('/api/')) {\n                return 0.5; // Moderate sampling for API routes\n            }\n            if (false) {}\n            return 1.0; // Full sampling in development\n        },\n        // Error filtering\n        beforeSend (event) {\n            // Filter out development-only errors\n            if (true) {\n                var _event_exception_values__value, _event_exception_values_, _event_exception_values, _event_exception;\n                // Filter out some common development errors\n                if ((_event_exception = event.exception) === null || _event_exception === void 0 ? void 0 : (_event_exception_values = _event_exception.values) === null || _event_exception_values === void 0 ? void 0 : (_event_exception_values_ = _event_exception_values[0]) === null || _event_exception_values_ === void 0 ? void 0 : (_event_exception_values__value = _event_exception_values_.value) === null || _event_exception_values__value === void 0 ? void 0 : _event_exception_values__value.includes('ResizeObserver loop limit exceeded')) {\n                    return null;\n                }\n            }\n            return event;\n        },\n        // User context\n        beforeSendTransaction (event) {\n            // You can modify the transaction before it's sent\n            return event;\n        },\n        // Additional context\n        initialScope: {\n            tags: {\n                component: 'frontend'\n            }\n        }\n    });\n} else {\n// TODO: Replace with proper logging\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2luc3RydW1lbnRhdGlvbi1jbGllbnQudHMiLCJtYXBwaW5ncyI6Ijs7O0FBQUNBLFVBQVUsQ0FBQyw0QkFBNEIsR0FBRztBQUFjQSxVQUFVLENBQUMsaUJBQWlCLEdBQUdDO0FBQVVELFVBQVUsQ0FBQyxrQkFBa0IsR0FBR0M7QUFBVUQsVUFBVSxDQUFDLHNDQUFzQyxHQUFHO0FBQUdBLFVBQVUsQ0FBQyxxQkFBcUIsR0FBR0M7QUFBVUQsVUFBVSxDQUFDLGlEQUFpRCxHQUFHQztBQUFVRCxVQUFVLENBQUMsdUJBQXVCLEdBQUc7QUFBd29EO0FBRXQrRCxvREFBb0Q7QUFDcEQsTUFBTUcsWUFBWUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDLHlCQUF5QjtBQUN2RCxNQUFNQyxhQUNKSCxhQUNBQSxjQUFjLDJDQUNkQSxVQUFVSSxVQUFVLENBQUMsZUFDckJKLFVBQVVLLFFBQVEsQ0FBQztBQUVyQixJQUFJRixZQUFZO0lBQ2RKLGdEQUFXLENBQUM7UUFDVlEsS0FBS1A7UUFFTCw0RUFBNEU7UUFDNUVRLGtCQUFrQlAsTUFBcUMsR0FBRyxDQUFHLEdBQUc7UUFFaEUsNEJBQTRCO1FBQzVCUSxjQUFjO1lBQ1pWLHFFQUFnQyxDQUFDO2dCQUMvQiwrREFBK0Q7Z0JBQy9EWSxzQkFBc0I7Z0JBQ3RCQyxvQkFBb0I7WUFDdEI7WUFDQWIsNkRBQXdCLENBQUM7Z0JBQ3ZCLDRDQUE0QztnQkFDNUNlLDBCQUEwQmIsTUFBcUMsR0FBRyxDQUFHLEdBQUc7Z0JBQ3hFLDJDQUEyQztnQkFDM0NjLDBCQUEwQjtZQUM1QjtTQUNEO1FBRUQsNEJBQTRCO1FBQzVCQyxhQWpDNHdCO1FBbUM1d0IsbUJBQW1CO1FBQ25CQyxTQUFTaEIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDLHlCQUF5QixJQUFJO1FBRWxELHlCQUF5QjtRQUN6QmdCLGVBQWUsQ0FBQ0M7Z0JBUVZDO1lBUEosdUNBQXVDO1lBQ3ZDLE1BQU0sRUFBRUEsUUFBUSxFQUFFLEdBQUdEO1lBRXJCLElBQUlDLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVUMsUUFBUSxNQUFLLGVBQWU7Z0JBQ3hDLE9BQU8sS0FBSyxtQ0FBbUM7WUFDakQ7WUFFQSxJQUFJRCxxQkFBQUEsZ0NBQUFBLHFCQUFBQSxTQUFVQyxRQUFRLGNBQWxCRCx5Q0FBQUEsbUJBQW9CaEIsVUFBVSxDQUFDLFVBQVU7Z0JBQzNDLE9BQU8sS0FBSyxtQ0FBbUM7WUFDakQ7WUFFQSxJQUFJSCxLQUFxQyxFQUFFLEVBRTFDO1lBRUQsT0FBTyxLQUFLLCtCQUErQjtRQUM3QztRQUVBLGtCQUFrQjtRQUNsQnFCLFlBQVdDLEtBQUs7WUFDZCxxQ0FBcUM7WUFDckMsSUFBSXRCLElBQXNDLEVBQUU7b0JBRXRDc0IsZ0NBQUFBLDBCQUFBQSx5QkFBQUE7Z0JBREosNENBQTRDO2dCQUM1QyxLQUFJQSxtQkFBQUEsTUFBTUMsU0FBUyxjQUFmRCx3Q0FBQUEsMEJBQUFBLGlCQUFpQkUsTUFBTSxjQUF2QkYsK0NBQUFBLDJCQUFBQSx1QkFBeUIsQ0FBQyxFQUFFLGNBQTVCQSxnREFBQUEsaUNBQUFBLHlCQUE4QkcsS0FBSyxjQUFuQ0gscURBQUFBLCtCQUFxQ2xCLFFBQVEsQ0FBQyx1Q0FBdUM7b0JBQ3ZGLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLE9BQU9rQjtRQUNUO1FBRUEsZUFBZTtRQUNmSSx1QkFBc0JKLEtBQUs7WUFDekIsa0RBQWtEO1lBQ2xELE9BQU9BO1FBQ1Q7UUFFQSxxQkFBcUI7UUFDckJLLGNBQWM7WUFDWkMsTUFBTTtnQkFDSkMsV0FBVztZQUNiO1FBQ0Y7SUFDRjtBQUNGLE9BQU87QUFDSCxvQ0FBb0M7QUFDeEMiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9pbnN0cnVtZW50YXRpb24tY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIjtnbG9iYWxUaGlzW1wiX3NlbnRyeVJld3JpdGVzVHVubmVsUGF0aFwiXSA9IFwiL21vbml0b3JpbmdcIjtnbG9iYWxUaGlzW1wiU0VOVFJZX1JFTEVBU0VcIl0gPSB1bmRlZmluZWQ7Z2xvYmFsVGhpc1tcIl9zZW50cnlCYXNlUGF0aFwiXSA9IHVuZGVmaW5lZDtnbG9iYWxUaGlzW1wiX3NlbnRyeVJld3JpdGVGcmFtZXNBc3NldFByZWZpeFBhdGhcIl0gPSBcIlwiO2dsb2JhbFRoaXNbXCJfc2VudHJ5QXNzZXRQcmVmaXhcIl0gPSB1bmRlZmluZWQ7Z2xvYmFsVGhpc1tcIl9zZW50cnlFeHBlcmltZW50YWxUaGlyZFBhcnR5T3JpZ2luU3RhY2tGcmFtZXNcIl0gPSB1bmRlZmluZWQ7Z2xvYmFsVGhpc1tcIl9zZW50cnlSb3V0ZU1hbmlmZXN0XCJdID0gXCJ7XFxcImR5bmFtaWNSb3V0ZXNcXFwiOlt7XFxcInBhdGhcXFwiOlxcXCIvYXNzZXNzbWVudHMvOmlkXFxcIixcXFwicmVnZXhcXFwiOlxcXCJeL2Fzc2Vzc21lbnRzLyhbXi9dKykkXFxcIixcXFwicGFyYW1OYW1lc1xcXCI6W1xcXCJpZFxcXCJdfSx7XFxcInBhdGhcXFwiOlxcXCIvYXNzZXNzbWVudHMvOmlkL3Jlc3VsdHNcXFwiLFxcXCJyZWdleFxcXCI6XFxcIl4vYXNzZXNzbWVudHMvKFteL10rKS9yZXN1bHRzJFxcXCIsXFxcInBhcmFtTmFtZXNcXFwiOltcXFwiaWRcXFwiXX0se1xcXCJwYXRoXFxcIjpcXFwiL2Fzc2Vzc21lbnQvcmVzdWx0cy86dG9rZW5cXFwiLFxcXCJyZWdleFxcXCI6XFxcIl4vYXNzZXNzbWVudC9yZXN1bHRzLyhbXi9dKykkXFxcIixcXFwicGFyYW1OYW1lc1xcXCI6W1xcXCJ0b2tlblxcXCJdfV0sXFxcInN0YXRpY1JvdXRlc1xcXCI6W3tcXFwicGF0aFxcXCI6XFxcIi9cXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvZm9yZ290LXBhc3N3b3JkXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2xvZ2luXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL3JlZ2lzdGVyXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL3NpZ251cFxcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9zaWdudXAtdHJhZGl0aW9uYWxcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvYW5hbHl0aWNzXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2Fzc2Vzc21lbnRzXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2Fzc2Vzc21lbnRzL25ld1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9idXNpbmVzcy1wcm9maWxlXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2NoYXRcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvY2hhdC10ZXN0XFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2NoZWNrb3V0XFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2NvbXBsaWFuY2Utd2l6YXJkXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2NvbXBvbmVudHNcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvZGFzaGJvYXJkXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2Rhc2hib2FyZC1jdXN0b21cXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvZGF0YS1leHBvcnQtZGVtb1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9ldmlkZW5jZVxcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9mb3Jtc1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9sb2FkaW5nLXN0YXRlc1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9tb2RhbHNcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvcG9saWNpZXNcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvcG9saWNpZXMvbmV3XFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL3ByaWNpbmdcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvcmVwb3J0c1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9zZXR0aW5ncy9iaWxsaW5nXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL3NldHRpbmdzL2ludGVncmF0aW9uc1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9zZXR0aW5ncy90ZWFtXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL3Rlc3QtcXVpY2stYWN0aW9uc1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9mcmVlbWl1bVxcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9mcmVlbWl1bS9hc3Nlc3NtZW50XFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2ZyZWVtaXVtL3Jlc3VsdHNcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvYXNzZXNzbWVudFxcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9hdXRoL2NhbGxiYWNrXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2RlbW8vZXJyb3ItYm91bmRhcnlcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvZGVtby9maWxlLXVwbG9hZFxcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9kZW1vL2xvYWRpbmctc3RhdGVzXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL2Rlc2lnbi1zeXN0ZW1cXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvZWRpdG9yXFxcIn0se1xcXCJwYXRoXFxcIjpcXFwiL21hcmtldGluZ1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi9tb25pdG9yaW5nL3Rlc3QtZXJyb3JcXFwifSx7XFxcInBhdGhcXFwiOlxcXCIvc2hvd2Nhc2UvY29tcG9uZW50c1xcXCJ9LHtcXFwicGF0aFxcXCI6XFxcIi90ZXN0LXRoZW1lXFxcIn1dfVwiO2ltcG9ydCAqIGFzIFNlbnRyeSBmcm9tICdAc2VudHJ5L25leHRqcyc7XG5cbi8vIE9ubHkgaW5pdGlhbGl6ZSBTZW50cnkgaWYgYSB2YWxpZCBEU04gaXMgcHJvdmlkZWRcbmNvbnN0IHNlbnRyeURzbiA9IHByb2Nlc3MuZW52WydORVhUX1BVQkxJQ19TRU5UUllfRFNOJ107XG5jb25zdCBpc1ZhbGlkRHNuID1cbiAgc2VudHJ5RHNuICYmXG4gIHNlbnRyeURzbiAhPT0gJ2h0dHBzOi8veW91ci1kc25Ac2VudHJ5LmlvL3Byb2plY3QtaWQnICYmXG4gIHNlbnRyeURzbi5zdGFydHNXaXRoKCdodHRwczovLycpICYmXG4gIHNlbnRyeURzbi5pbmNsdWRlcygnQHNlbnRyeS5pbycpO1xuXG5pZiAoaXNWYWxpZERzbikge1xuICBTZW50cnkuaW5pdCh7XG4gICAgZHNuOiBzZW50cnlEc24sXG5cbiAgICAvLyBBZGp1c3QgdGhpcyB2YWx1ZSBpbiBwcm9kdWN0aW9uLCBvciB1c2UgdHJhY2VzU2FtcGxlciBmb3IgZ3JlYXRlciBjb250cm9sXG4gICAgdHJhY2VzU2FtcGxlUmF0ZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IDAuMSA6IDEuMCxcblxuICAgIC8vIENvbmZpZ3VyZSBicm93c2VyIHRyYWNpbmdcbiAgICBpbnRlZ3JhdGlvbnM6IFtcbiAgICAgIFNlbnRyeS5icm93c2VyVHJhY2luZ0ludGVncmF0aW9uKHtcbiAgICAgICAgLy8gU2V0IHVwIGF1dG9tYXRpYyByb3V0ZSBjaGFuZ2UgdHJhY2tpbmcgaW4gTmV4dC5qcyBBcHAgUm91dGVyXG4gICAgICAgIGluc3RydW1lbnROYXZpZ2F0aW9uOiB0cnVlLFxuICAgICAgICBpbnN0cnVtZW50UGFnZUxvYWQ6IHRydWUsXG4gICAgICB9KSxcbiAgICAgIFNlbnRyeS5yZXBsYXlJbnRlZ3JhdGlvbih7XG4gICAgICAgIC8vIENhcHR1cmUgMTAlIG9mIHRoZSBzZXNzaW9ucyBpbiBwcm9kdWN0aW9uXG4gICAgICAgIHJlcGxheXNTZXNzaW9uU2FtcGxlUmF0ZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IDAuMSA6IDEuMCxcbiAgICAgICAgLy8gT2YgdGhvc2UsIGNhcHR1cmUgMTAwJSBvZiBlcnJvciBzZXNzaW9uc1xuICAgICAgICByZXBsYXlzT25FcnJvclNhbXBsZVJhdGU6IDEuMCxcbiAgICAgIH0gYXMgYW55KSwgLy8gVHlwZSBjYXN0aW5nIGZvciBjb21wYXRpYmlsaXR5XG4gICAgXSxcblxuICAgIC8vIEVudmlyb25tZW50IGNvbmZpZ3VyYXRpb25cbiAgICBlbnZpcm9ubWVudDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYsXG5cbiAgICAvLyBSZWxlYXNlIHRyYWNraW5nXG4gICAgcmVsZWFzZTogcHJvY2Vzcy5lbnZbJ05FWFRfUFVCTElDX1NFTlRSWV9EU04nXSB8fCAncnVsZWlxLWZyb250ZW5kQHVua25vd24nLFxuXG4gICAgLy8gUGVyZm9ybWFuY2UgTW9uaXRvcmluZ1xuICAgIHRyYWNlc1NhbXBsZXI6IChzYW1wbGluZ0NvbnRleHQpID0+IHtcbiAgICAgIC8vIEFkanVzdCBzYW1wbGUgcmF0ZXMgYmFzZWQgb24gY29udGV4dFxuICAgICAgY29uc3QgeyBsb2NhdGlvbiB9ID0gc2FtcGxpbmdDb250ZXh0O1xuXG4gICAgICBpZiAobG9jYXRpb24/LnBhdGhuYW1lID09PSAnL2FwaS9oZWFsdGgnKSB7XG4gICAgICAgIHJldHVybiAwLjE7IC8vIExvd2VyIHNhbXBsaW5nIGZvciBoZWFsdGggY2hlY2tzXG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NhdGlvbj8ucGF0aG5hbWU/LnN0YXJ0c1dpdGgoJy9hcGkvJykpIHtcbiAgICAgICAgcmV0dXJuIDAuNTsgLy8gTW9kZXJhdGUgc2FtcGxpbmcgZm9yIEFQSSByb3V0ZXNcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIDAuMTsgLy8gTG93ZXIgc2FtcGxpbmcgaW4gcHJvZHVjdGlvblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMS4wOyAvLyBGdWxsIHNhbXBsaW5nIGluIGRldmVsb3BtZW50XG4gICAgfSxcblxuICAgIC8vIEVycm9yIGZpbHRlcmluZ1xuICAgIGJlZm9yZVNlbmQoZXZlbnQpIHtcbiAgICAgIC8vIEZpbHRlciBvdXQgZGV2ZWxvcG1lbnQtb25seSBlcnJvcnNcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IHNvbWUgY29tbW9uIGRldmVsb3BtZW50IGVycm9yc1xuICAgICAgICBpZiAoZXZlbnQuZXhjZXB0aW9uPy52YWx1ZXM/LlswXT8udmFsdWU/LmluY2x1ZGVzKCdSZXNpemVPYnNlcnZlciBsb29wIGxpbWl0IGV4Y2VlZGVkJykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfSxcblxuICAgIC8vIFVzZXIgY29udGV4dFxuICAgIGJlZm9yZVNlbmRUcmFuc2FjdGlvbihldmVudCkge1xuICAgICAgLy8gWW91IGNhbiBtb2RpZnkgdGhlIHRyYW5zYWN0aW9uIGJlZm9yZSBpdCdzIHNlbnRcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuXG4gICAgLy8gQWRkaXRpb25hbCBjb250ZXh0XG4gICAgaW5pdGlhbFNjb3BlOiB7XG4gICAgICB0YWdzOiB7XG4gICAgICAgIGNvbXBvbmVudDogJ2Zyb250ZW5kJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59IGVsc2Uge1xuICAgIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBwcm9wZXIgbG9nZ2luZ1xufVxuIl0sIm5hbWVzIjpbImdsb2JhbFRoaXMiLCJ1bmRlZmluZWQiLCJTZW50cnkiLCJzZW50cnlEc24iLCJwcm9jZXNzIiwiZW52IiwiaXNWYWxpZERzbiIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsImluaXQiLCJkc24iLCJ0cmFjZXNTYW1wbGVSYXRlIiwiaW50ZWdyYXRpb25zIiwiYnJvd3NlclRyYWNpbmdJbnRlZ3JhdGlvbiIsImluc3RydW1lbnROYXZpZ2F0aW9uIiwiaW5zdHJ1bWVudFBhZ2VMb2FkIiwicmVwbGF5SW50ZWdyYXRpb24iLCJyZXBsYXlzU2Vzc2lvblNhbXBsZVJhdGUiLCJyZXBsYXlzT25FcnJvclNhbXBsZVJhdGUiLCJlbnZpcm9ubWVudCIsInJlbGVhc2UiLCJ0cmFjZXNTYW1wbGVyIiwic2FtcGxpbmdDb250ZXh0IiwibG9jYXRpb24iLCJwYXRobmFtZSIsImJlZm9yZVNlbmQiLCJldmVudCIsImV4Y2VwdGlvbiIsInZhbHVlcyIsInZhbHVlIiwiYmVmb3JlU2VuZFRyYW5zYWN0aW9uIiwiaW5pdGlhbFNjb3BlIiwidGFncyIsImNvbXBvbmVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./instrumentation-client.ts\n"));
- `./frontend/.next/static/chunks/main-app.js:117` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   breadcrumbsIntegration: () => (/* binding */ breadcrumbsIntegration)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/index.js\");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry-internal/browser-utils */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry-internal+browser-utils@9.46.0/node_modules/@sentry-internal/browser-utils/build/esm/index.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../debug-build.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/debug-build.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/helpers.js\");\n\n\n\n\n\n/** maxStringLength gets capped to prevent 100 breadcrumbs exceeding 1MB event payload size */\nconst MAX_ALLOWED_STRING_LENGTH = 1024;\n\nconst INTEGRATION_NAME = 'Breadcrumbs';\n\nconst _breadcrumbsIntegration = ((options = {}) => {\n  const _options = {\n    console: true,\n    dom: true,\n    fetch: true,\n    history: true,\n    sentry: true,\n    xhr: true,\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      // TODO(v10): Remove this functionality and use `consoleIntegration` from @sentry/core instead.\n      if (_options.console) {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addConsoleInstrumentationHandler)(_getConsoleBreadcrumbHandler(client));\n      }\n      if (_options.dom) {\n        (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_1__.addClickKeypressInstrumentationHandler)(_getDomBreadcrumbHandler(client, _options.dom));\n      }\n      if (_options.xhr) {\n        (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_1__.addXhrInstrumentationHandler)(_getXhrBreadcrumbHandler(client));\n      }\n      if (_options.fetch) {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addFetchInstrumentationHandler)(_getFetchBreadcrumbHandler(client));\n      }\n      if (_options.history) {\n        (0,_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_1__.addHistoryInstrumentationHandler)(_getHistoryBreadcrumbHandler(client));\n      }\n      if (_options.sentry) {\n        client.on('beforeSendEvent', _getSentryBreadcrumbHandler(client));\n      }\n    },\n  };\n}) ;\n\nconst breadcrumbsIntegration = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.defineIntegration)(_breadcrumbsIntegration);\n\n/**\n * Adds a breadcrumb for Sentry events or transactions if this option is enabled.\n */\nfunction _getSentryBreadcrumbHandler(client) {\n  return function addSentryBreadcrumb(event) {\n    if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getClient)() !== client) {\n      return;\n    }\n\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addBreadcrumb)(\n      {\n        category: `sentry.${event.type === 'transaction' ? 'transaction' : 'event'}`,\n        event_id: event.event_id,\n        level: event.level,\n        message: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getEventDescription)(event),\n      },\n      {\n        event,\n      },\n    );\n  };\n}\n\n/**\n * A HOC that creates a function that creates breadcrumbs from DOM API calls.\n * This is a HOC so that we get access to dom options in the closure.\n */\nfunction _getDomBreadcrumbHandler(\n  client,\n  dom,\n) {\n  return function _innerDomBreadcrumb(handlerData) {\n    if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getClient)() !== client) {\n      return;\n    }\n\n    let target;\n    let componentName;\n    let keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;\n\n    let maxStringLength =\n      typeof dom === 'object' && typeof dom.maxStringLength === 'number' ? dom.maxStringLength : undefined;\n    if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD &&\n        _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.warn(\n          `\\`dom.maxStringLength\\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`,\n        );\n      maxStringLength = MAX_ALLOWED_STRING_LENGTH;\n    }\n\n    if (typeof keyAttrs === 'string') {\n      keyAttrs = [keyAttrs];\n    }\n\n    // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n    try {\n      const event = handlerData.event ;\n      const element = _isEvent(event) ? event.target : event;\n\n      target = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.htmlTreeAsString)(element, { keyAttrs, maxStringLength });\n      componentName = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getComponentName)(element);\n    } catch {\n      target = '<unknown>';\n    }\n\n    if (target.length === 0) {\n      return;\n    }\n\n    const breadcrumb = {\n      category: `ui.${handlerData.name}`,\n      message: target,\n    };\n\n    if (componentName) {\n      breadcrumb.data = { 'ui.component_name': componentName };\n    }\n\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addBreadcrumb)(breadcrumb, {\n      event: handlerData.event,\n      name: handlerData.name,\n      global: handlerData.global,\n    });\n  };\n}\n\n/**\n * Creates breadcrumbs from console API calls\n */\nfunction _getConsoleBreadcrumbHandler(client) {\n  return function _consoleBreadcrumb(handlerData) {\n    if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getClient)() !== client) {\n      return;\n    }\n\n    const breadcrumb = {\n      category: 'console',\n      data: {\n        arguments: handlerData.args,\n        logger: 'console',\n      },\n      level: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.severityLevelFromString)(handlerData.level),\n      message: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.safeJoin)(handlerData.args, ' '),\n    };\n\n    if (handlerData.level === 'assert') {\n      if (handlerData.args[0] === false) {\n        breadcrumb.message = `Assertion failed: ${(0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.safeJoin)(handlerData.args.slice(1), ' ') || 'console.assert'}`;\n        breadcrumb.data.arguments = handlerData.args.slice(1);\n      } else {\n        // Don't capture a breadcrumb for passed assertions\n        return;\n      }\n    }\n\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addBreadcrumb)(breadcrumb, {\n      input: handlerData.args,\n      level: handlerData.level,\n    });\n  };\n}\n\n/**\n * Creates breadcrumbs from XHR API calls\n */\nfunction _getXhrBreadcrumbHandler(client) {\n  return function _xhrBreadcrumb(handlerData) {\n    if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getClient)() !== client) {\n      return;\n    }\n\n    const { startTimestamp, endTimestamp } = handlerData;\n\n    const sentryXhrData = handlerData.xhr[_sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_1__.SENTRY_XHR_DATA_KEY];\n\n    // We only capture complete, non-sentry requests\n    if (!startTimestamp || !endTimestamp || !sentryXhrData) {\n      return;\n    }\n\n    const { method, url, status_code, body } = sentryXhrData;\n\n    const data = {\n      method,\n      url,\n      status_code,\n    };\n\n    const hint = {\n      xhr: handlerData.xhr,\n      input: body,\n      startTimestamp,\n      endTimestamp,\n    };\n\n    const breadcrumb = {\n      category: 'xhr',\n      data,\n      type: 'http',\n      level: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getBreadcrumbLogLevelFromHttpStatusCode)(status_code),\n    };\n\n    client.emit('beforeOutgoingRequestBreadcrumb', breadcrumb, hint );\n\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addBreadcrumb)(breadcrumb, hint);\n  };\n}\n\n/**\n * Creates breadcrumbs from fetch API calls\n */\nfunction _getFetchBreadcrumbHandler(client) {\n  return function _fetchBreadcrumb(handlerData) {\n    if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getClient)() !== client) {\n      return;\n    }\n\n    const { startTimestamp, endTimestamp } = handlerData;\n\n    // We only capture complete fetch requests\n    if (!endTimestamp) {\n      return;\n    }\n\n    if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {\n      // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)\n      return;\n    }\n\n    ({\n      method: handlerData.fetchData.method,\n      url: handlerData.fetchData.url,\n    });\n\n    if (handlerData.error) {\n      const data = handlerData.fetchData;\n      const hint = {\n        data: handlerData.error,\n        input: handlerData.args,\n        startTimestamp,\n        endTimestamp,\n      };\n\n      const breadcrumb = {\n        category: 'fetch',\n        data,\n        level: 'error',\n        type: 'http',\n      } ;\n\n      client.emit('beforeOutgoingRequestBreadcrumb', breadcrumb, hint );\n\n      (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addBreadcrumb)(breadcrumb, hint);\n    } else {\n      const response = handlerData.response ;\n      const data = {\n        ...handlerData.fetchData,\n        status_code: response?.status,\n      };\n\n      handlerData.fetchData.request_body_size;\n      handlerData.fetchData.response_body_size;\n      response?.status;\n\n      const hint = {\n        input: handlerData.args,\n        response,\n        startTimestamp,\n        endTimestamp,\n      };\n\n      const breadcrumb = {\n        category: 'fetch',\n        data,\n        type: 'http',\n        level: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getBreadcrumbLogLevelFromHttpStatusCode)(data.status_code),\n      };\n\n      client.emit('beforeOutgoingRequestBreadcrumb', breadcrumb, hint );\n\n      (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addBreadcrumb)(breadcrumb, hint);\n    }\n  };\n}\n\n/**\n * Creates breadcrumbs from history API calls\n */\nfunction _getHistoryBreadcrumbHandler(client) {\n  return function _historyBreadcrumb(handlerData) {\n    if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getClient)() !== client) {\n      return;\n    }\n\n    let from = handlerData.from;\n    let to = handlerData.to;\n    const parsedLoc = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.parseUrl)(_helpers_js__WEBPACK_IMPORTED_MODULE_3__.WINDOW.location.href);\n    let parsedFrom = from ? (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.parseUrl)(from) : undefined;\n    const parsedTo = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.parseUrl)(to);\n\n    // Initial pushState doesn't provide `from` information\n    if (!parsedFrom?.path) {\n      parsedFrom = parsedLoc;\n    }\n\n    // Use only the path component of the URL if the URL matches the current\n    // document (almost all the time when using pushState)\n    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {\n      to = parsedTo.relative;\n    }\n    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {\n      from = parsedFrom.relative;\n    }\n\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addBreadcrumb)({\n      category: 'navigation',\n      data: {\n        from,\n        to,\n      },\n    });\n  };\n}\n\nfunction _isEvent(event) {\n  return !!event && !!(event ).target;\n}\n\n\n//# sourceMappingURL=breadcrumbs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2Jyb3dzZXJAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9pbnRlZ3JhdGlvbnMvYnJlYWRjcnVtYnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbVM7QUFDdEg7QUFDN0g7QUFDVDs7QUFFdkM7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhFQUFnQztBQUN4QztBQUNBO0FBQ0EsUUFBUSxzR0FBc0M7QUFDOUM7QUFDQTtBQUNBLFFBQVEsNEZBQTRCO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLDRFQUE4QjtBQUN0QztBQUNBO0FBQ0EsUUFBUSxnR0FBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVELCtCQUErQiwrREFBaUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFTO0FBQ2pCO0FBQ0E7O0FBRUEsSUFBSSwyREFBYTtBQUNqQjtBQUNBLDRCQUE0Qix1REFBdUQ7QUFDbkY7QUFDQTtBQUNBLGlCQUFpQixpRUFBbUI7QUFDcEMsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3REFBVztBQUNqQixRQUFRLCtDQUFLO0FBQ2IsbURBQW1ELDBCQUEwQixtQkFBbUIsaUJBQWlCLGtDQUFrQywyQkFBMkI7QUFDOUs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLDhEQUFnQixZQUFZLDJCQUEyQjtBQUN0RSxzQkFBc0IsOERBQWdCO0FBQ3RDLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQSxJQUFJLDJEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxhQUFhLHFFQUF1QjtBQUNwQyxlQUFlLHNEQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Qsc0RBQVEscURBQXFEO0FBQy9HO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksMkRBQWE7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFTO0FBQ2pCO0FBQ0E7O0FBRUEsWUFBWSwrQkFBK0I7O0FBRTNDLDBDQUEwQywrRUFBbUI7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUNBQWlDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUZBQXVDO0FBQ3BEOztBQUVBOztBQUVBLElBQUksMkRBQWE7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBUztBQUNqQjtBQUNBOztBQUVBLFlBQVksK0JBQStCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sMkRBQWE7QUFDbkIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUZBQXVDO0FBQ3REOztBQUVBOztBQUVBLE1BQU0sMkRBQWE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixzREFBUSxDQUFDLCtDQUFNO0FBQ3JDLDRCQUE0QixzREFBUTtBQUNwQyxxQkFBcUIsc0RBQVE7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSwyREFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWtDO0FBQ2xDIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrYnJvd3NlckA5LjQ2LjAvbm9kZV9tb2R1bGVzL0BzZW50cnkvYnJvd3Nlci9idWlsZC9ucG0vZXNtL2ludGVncmF0aW9ucy9icmVhZGNydW1icy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVJbnRlZ3JhdGlvbiwgYWRkQ29uc29sZUluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGFkZEZldGNoSW5zdHJ1bWVudGF0aW9uSGFuZGxlciwgZ2V0Q2xpZW50LCBzYWZlSm9pbiwgc2V2ZXJpdHlMZXZlbEZyb21TdHJpbmcsIGFkZEJyZWFkY3J1bWIsIGRlYnVnLCBodG1sVHJlZUFzU3RyaW5nLCBnZXRDb21wb25lbnROYW1lLCBnZXRCcmVhZGNydW1iTG9nTGV2ZWxGcm9tSHR0cFN0YXR1c0NvZGUsIHBhcnNlVXJsLCBnZXRFdmVudERlc2NyaXB0aW9uIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IGFkZENsaWNrS2V5cHJlc3NJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBhZGRYaHJJbnN0cnVtZW50YXRpb25IYW5kbGVyLCBhZGRIaXN0b3J5SW5zdHJ1bWVudGF0aW9uSGFuZGxlciwgU0VOVFJZX1hIUl9EQVRBX0tFWSB9IGZyb20gJ0BzZW50cnktaW50ZXJuYWwvYnJvd3Nlci11dGlscyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4uL2RlYnVnLWJ1aWxkLmpzJztcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJy4uL2hlbHBlcnMuanMnO1xuXG4vKiogbWF4U3RyaW5nTGVuZ3RoIGdldHMgY2FwcGVkIHRvIHByZXZlbnQgMTAwIGJyZWFkY3J1bWJzIGV4Y2VlZGluZyAxTUIgZXZlbnQgcGF5bG9hZCBzaXplICovXG5jb25zdCBNQVhfQUxMT1dFRF9TVFJJTkdfTEVOR1RIID0gMTAyNDtcblxuY29uc3QgSU5URUdSQVRJT05fTkFNRSA9ICdCcmVhZGNydW1icyc7XG5cbmNvbnN0IF9icmVhZGNydW1ic0ludGVncmF0aW9uID0gKChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgX29wdGlvbnMgPSB7XG4gICAgY29uc29sZTogdHJ1ZSxcbiAgICBkb206IHRydWUsXG4gICAgZmV0Y2g6IHRydWUsXG4gICAgaGlzdG9yeTogdHJ1ZSxcbiAgICBzZW50cnk6IHRydWUsXG4gICAgeGhyOiB0cnVlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHNldHVwKGNsaWVudCkge1xuICAgICAgLy8gVE9ETyh2MTApOiBSZW1vdmUgdGhpcyBmdW5jdGlvbmFsaXR5IGFuZCB1c2UgYGNvbnNvbGVJbnRlZ3JhdGlvbmAgZnJvbSBAc2VudHJ5L2NvcmUgaW5zdGVhZC5cbiAgICAgIGlmIChfb3B0aW9ucy5jb25zb2xlKSB7XG4gICAgICAgIGFkZENvbnNvbGVJbnN0cnVtZW50YXRpb25IYW5kbGVyKF9nZXRDb25zb2xlQnJlYWRjcnVtYkhhbmRsZXIoY2xpZW50KSk7XG4gICAgICB9XG4gICAgICBpZiAoX29wdGlvbnMuZG9tKSB7XG4gICAgICAgIGFkZENsaWNrS2V5cHJlc3NJbnN0cnVtZW50YXRpb25IYW5kbGVyKF9nZXREb21CcmVhZGNydW1iSGFuZGxlcihjbGllbnQsIF9vcHRpb25zLmRvbSkpO1xuICAgICAgfVxuICAgICAgaWYgKF9vcHRpb25zLnhocikge1xuICAgICAgICBhZGRYaHJJbnN0cnVtZW50YXRpb25IYW5kbGVyKF9nZXRYaHJCcmVhZGNydW1iSGFuZGxlcihjbGllbnQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChfb3B0aW9ucy5mZXRjaCkge1xuICAgICAgICBhZGRGZXRjaEluc3RydW1lbnRhdGlvbkhhbmRsZXIoX2dldEZldGNoQnJlYWRjcnVtYkhhbmRsZXIoY2xpZW50KSk7XG4gICAgICB9XG4gICAgICBpZiAoX29wdGlvbnMuaGlzdG9yeSkge1xuICAgICAgICBhZGRIaXN0b3J5SW5zdHJ1bWVudGF0aW9uSGFuZGxlcihfZ2V0SGlzdG9yeUJyZWFkY3J1bWJIYW5kbGVyKGNsaWVudCkpO1xuICAgICAgfVxuICAgICAgaWYgKF9vcHRpb25zLnNlbnRyeSkge1xuICAgICAgICBjbGllbnQub24oJ2JlZm9yZVNlbmRFdmVudCcsIF9nZXRTZW50cnlCcmVhZGNydW1iSGFuZGxlcihjbGllbnQpKTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xufSkgO1xuXG5jb25zdCBicmVhZGNydW1ic0ludGVncmF0aW9uID0gZGVmaW5lSW50ZWdyYXRpb24oX2JyZWFkY3J1bWJzSW50ZWdyYXRpb24pO1xuXG4vKipcbiAqIEFkZHMgYSBicmVhZGNydW1iIGZvciBTZW50cnkgZXZlbnRzIG9yIHRyYW5zYWN0aW9ucyBpZiB0aGlzIG9wdGlvbiBpcyBlbmFibGVkLlxuICovXG5mdW5jdGlvbiBfZ2V0U2VudHJ5QnJlYWRjcnVtYkhhbmRsZXIoY2xpZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZGRTZW50cnlCcmVhZGNydW1iKGV2ZW50KSB7XG4gICAgaWYgKGdldENsaWVudCgpICE9PSBjbGllbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhZGRCcmVhZGNydW1iKFxuICAgICAge1xuICAgICAgICBjYXRlZ29yeTogYHNlbnRyeS4ke2V2ZW50LnR5cGUgPT09ICd0cmFuc2FjdGlvbicgPyAndHJhbnNhY3Rpb24nIDogJ2V2ZW50J31gLFxuICAgICAgICBldmVudF9pZDogZXZlbnQuZXZlbnRfaWQsXG4gICAgICAgIGxldmVsOiBldmVudC5sZXZlbCxcbiAgICAgICAgbWVzc2FnZTogZ2V0RXZlbnREZXNjcmlwdGlvbihldmVudCksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBldmVudCxcbiAgICAgIH0sXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIEhPQyB0aGF0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYnJlYWRjcnVtYnMgZnJvbSBET00gQVBJIGNhbGxzLlxuICogVGhpcyBpcyBhIEhPQyBzbyB0aGF0IHdlIGdldCBhY2Nlc3MgdG8gZG9tIG9wdGlvbnMgaW4gdGhlIGNsb3N1cmUuXG4gKi9cbmZ1bmN0aW9uIF9nZXREb21CcmVhZGNydW1iSGFuZGxlcihcbiAgY2xpZW50LFxuICBkb20sXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9pbm5lckRvbUJyZWFkY3J1bWIoaGFuZGxlckRhdGEpIHtcbiAgICBpZiAoZ2V0Q2xpZW50KCkgIT09IGNsaWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB0YXJnZXQ7XG4gICAgbGV0IGNvbXBvbmVudE5hbWU7XG4gICAgbGV0IGtleUF0dHJzID0gdHlwZW9mIGRvbSA9PT0gJ29iamVjdCcgPyBkb20uc2VyaWFsaXplQXR0cmlidXRlIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IG1heFN0cmluZ0xlbmd0aCA9XG4gICAgICB0eXBlb2YgZG9tID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZG9tLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcicgPyBkb20ubWF4U3RyaW5nTGVuZ3RoIDogdW5kZWZpbmVkO1xuICAgIGlmIChtYXhTdHJpbmdMZW5ndGggJiYgbWF4U3RyaW5nTGVuZ3RoID4gTUFYX0FMTE9XRURfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICBgXFxgZG9tLm1heFN0cmluZ0xlbmd0aFxcYCBjYW5ub3QgZXhjZWVkICR7TUFYX0FMTE9XRURfU1RSSU5HX0xFTkdUSH0sIGJ1dCBhIHZhbHVlIG9mICR7bWF4U3RyaW5nTGVuZ3RofSB3YXMgY29uZmlndXJlZC4gU2VudHJ5IHdpbGwgdXNlICR7TUFYX0FMTE9XRURfU1RSSU5HX0xFTkdUSH0gaW5zdGVhZC5gLFxuICAgICAgICApO1xuICAgICAgbWF4U3RyaW5nTGVuZ3RoID0gTUFYX0FMTE9XRURfU1RSSU5HX0xFTkdUSDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGtleUF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAga2V5QXR0cnMgPSBba2V5QXR0cnNdO1xuICAgIH1cblxuICAgIC8vIEFjY2Vzc2luZyBldmVudC50YXJnZXQgY2FuIHRocm93IChzZWUgZ2V0c2VudHJ5L3JhdmVuLWpzIzgzOCwgIzc2OClcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnQgPSBoYW5kbGVyRGF0YS5ldmVudCA7XG4gICAgICBjb25zdCBlbGVtZW50ID0gX2lzRXZlbnQoZXZlbnQpID8gZXZlbnQudGFyZ2V0IDogZXZlbnQ7XG5cbiAgICAgIHRhcmdldCA9IGh0bWxUcmVlQXNTdHJpbmcoZWxlbWVudCwgeyBrZXlBdHRycywgbWF4U3RyaW5nTGVuZ3RoIH0pO1xuICAgICAgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZWxlbWVudCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0YXJnZXQgPSAnPHVua25vd24+JztcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJyZWFkY3J1bWIgPSB7XG4gICAgICBjYXRlZ29yeTogYHVpLiR7aGFuZGxlckRhdGEubmFtZX1gLFxuICAgICAgbWVzc2FnZTogdGFyZ2V0LFxuICAgIH07XG5cbiAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgYnJlYWRjcnVtYi5kYXRhID0geyAndWkuY29tcG9uZW50X25hbWUnOiBjb21wb25lbnROYW1lIH07XG4gICAgfVxuXG4gICAgYWRkQnJlYWRjcnVtYihicmVhZGNydW1iLCB7XG4gICAgICBldmVudDogaGFuZGxlckRhdGEuZXZlbnQsXG4gICAgICBuYW1lOiBoYW5kbGVyRGF0YS5uYW1lLFxuICAgICAgZ2xvYmFsOiBoYW5kbGVyRGF0YS5nbG9iYWwsXG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBicmVhZGNydW1icyBmcm9tIGNvbnNvbGUgQVBJIGNhbGxzXG4gKi9cbmZ1bmN0aW9uIF9nZXRDb25zb2xlQnJlYWRjcnVtYkhhbmRsZXIoY2xpZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBfY29uc29sZUJyZWFkY3J1bWIoaGFuZGxlckRhdGEpIHtcbiAgICBpZiAoZ2V0Q2xpZW50KCkgIT09IGNsaWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJyZWFkY3J1bWIgPSB7XG4gICAgICBjYXRlZ29yeTogJ2NvbnNvbGUnLFxuICAgICAgZGF0YToge1xuICAgICAgICBhcmd1bWVudHM6IGhhbmRsZXJEYXRhLmFyZ3MsXG4gICAgICAgIGxvZ2dlcjogJ2NvbnNvbGUnLFxuICAgICAgfSxcbiAgICAgIGxldmVsOiBzZXZlcml0eUxldmVsRnJvbVN0cmluZyhoYW5kbGVyRGF0YS5sZXZlbCksXG4gICAgICBtZXNzYWdlOiBzYWZlSm9pbihoYW5kbGVyRGF0YS5hcmdzLCAnICcpLFxuICAgIH07XG5cbiAgICBpZiAoaGFuZGxlckRhdGEubGV2ZWwgPT09ICdhc3NlcnQnKSB7XG4gICAgICBpZiAoaGFuZGxlckRhdGEuYXJnc1swXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWRjcnVtYi5tZXNzYWdlID0gYEFzc2VydGlvbiBmYWlsZWQ6ICR7c2FmZUpvaW4oaGFuZGxlckRhdGEuYXJncy5zbGljZSgxKSwgJyAnKSB8fCAnY29uc29sZS5hc3NlcnQnfWA7XG4gICAgICAgIGJyZWFkY3J1bWIuZGF0YS5hcmd1bWVudHMgPSBoYW5kbGVyRGF0YS5hcmdzLnNsaWNlKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG9uJ3QgY2FwdHVyZSBhIGJyZWFkY3J1bWIgZm9yIHBhc3NlZCBhc3NlcnRpb25zXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRCcmVhZGNydW1iKGJyZWFkY3J1bWIsIHtcbiAgICAgIGlucHV0OiBoYW5kbGVyRGF0YS5hcmdzLFxuICAgICAgbGV2ZWw6IGhhbmRsZXJEYXRhLmxldmVsLFxuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYnJlYWRjcnVtYnMgZnJvbSBYSFIgQVBJIGNhbGxzXG4gKi9cbmZ1bmN0aW9uIF9nZXRYaHJCcmVhZGNydW1iSGFuZGxlcihjbGllbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIF94aHJCcmVhZGNydW1iKGhhbmRsZXJEYXRhKSB7XG4gICAgaWYgKGdldENsaWVudCgpICE9PSBjbGllbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHN0YXJ0VGltZXN0YW1wLCBlbmRUaW1lc3RhbXAgfSA9IGhhbmRsZXJEYXRhO1xuXG4gICAgY29uc3Qgc2VudHJ5WGhyRGF0YSA9IGhhbmRsZXJEYXRhLnhocltTRU5UUllfWEhSX0RBVEFfS0VZXTtcblxuICAgIC8vIFdlIG9ubHkgY2FwdHVyZSBjb21wbGV0ZSwgbm9uLXNlbnRyeSByZXF1ZXN0c1xuICAgIGlmICghc3RhcnRUaW1lc3RhbXAgfHwgIWVuZFRpbWVzdGFtcCB8fCAhc2VudHJ5WGhyRGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbWV0aG9kLCB1cmwsIHN0YXR1c19jb2RlLCBib2R5IH0gPSBzZW50cnlYaHJEYXRhO1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHVybCxcbiAgICAgIHN0YXR1c19jb2RlLFxuICAgIH07XG5cbiAgICBjb25zdCBoaW50ID0ge1xuICAgICAgeGhyOiBoYW5kbGVyRGF0YS54aHIsXG4gICAgICBpbnB1dDogYm9keSxcbiAgICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgICAgZW5kVGltZXN0YW1wLFxuICAgIH07XG5cbiAgICBjb25zdCBicmVhZGNydW1iID0ge1xuICAgICAgY2F0ZWdvcnk6ICd4aHInLFxuICAgICAgZGF0YSxcbiAgICAgIHR5cGU6ICdodHRwJyxcbiAgICAgIGxldmVsOiBnZXRCcmVhZGNydW1iTG9nTGV2ZWxGcm9tSHR0cFN0YXR1c0NvZGUoc3RhdHVzX2NvZGUpLFxuICAgIH07XG5cbiAgICBjbGllbnQuZW1pdCgnYmVmb3JlT3V0Z29pbmdSZXF1ZXN0QnJlYWRjcnVtYicsIGJyZWFkY3J1bWIsIGhpbnQgKTtcblxuICAgIGFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYiwgaGludCk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBicmVhZGNydW1icyBmcm9tIGZldGNoIEFQSSBjYWxsc1xuICovXG5mdW5jdGlvbiBfZ2V0RmV0Y2hCcmVhZGNydW1iSGFuZGxlcihjbGllbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9mZXRjaEJyZWFkY3J1bWIoaGFuZGxlckRhdGEpIHtcbiAgICBpZiAoZ2V0Q2xpZW50KCkgIT09IGNsaWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgc3RhcnRUaW1lc3RhbXAsIGVuZFRpbWVzdGFtcCB9ID0gaGFuZGxlckRhdGE7XG5cbiAgICAvLyBXZSBvbmx5IGNhcHR1cmUgY29tcGxldGUgZmV0Y2ggcmVxdWVzdHNcbiAgICBpZiAoIWVuZFRpbWVzdGFtcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVyRGF0YS5mZXRjaERhdGEudXJsLm1hdGNoKC9zZW50cnlfa2V5LykgJiYgaGFuZGxlckRhdGEuZmV0Y2hEYXRhLm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAvLyBXZSB3aWxsIG5vdCBjcmVhdGUgYnJlYWRjcnVtYnMgZm9yIGZldGNoIHJlcXVlc3RzIHRoYXQgY29udGFpbiBgc2VudHJ5X2tleWAgKGludGVybmFsIHNlbnRyeSByZXF1ZXN0cylcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAoe1xuICAgICAgbWV0aG9kOiBoYW5kbGVyRGF0YS5mZXRjaERhdGEubWV0aG9kLFxuICAgICAgdXJsOiBoYW5kbGVyRGF0YS5mZXRjaERhdGEudXJsLFxuICAgIH0pO1xuXG4gICAgaWYgKGhhbmRsZXJEYXRhLmVycm9yKSB7XG4gICAgICBjb25zdCBkYXRhID0gaGFuZGxlckRhdGEuZmV0Y2hEYXRhO1xuICAgICAgY29uc3QgaGludCA9IHtcbiAgICAgICAgZGF0YTogaGFuZGxlckRhdGEuZXJyb3IsXG4gICAgICAgIGlucHV0OiBoYW5kbGVyRGF0YS5hcmdzLFxuICAgICAgICBzdGFydFRpbWVzdGFtcCxcbiAgICAgICAgZW5kVGltZXN0YW1wLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYnJlYWRjcnVtYiA9IHtcbiAgICAgICAgY2F0ZWdvcnk6ICdmZXRjaCcsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGxldmVsOiAnZXJyb3InLFxuICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICB9IDtcblxuICAgICAgY2xpZW50LmVtaXQoJ2JlZm9yZU91dGdvaW5nUmVxdWVzdEJyZWFkY3J1bWInLCBicmVhZGNydW1iLCBoaW50ICk7XG5cbiAgICAgIGFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYiwgaGludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gaGFuZGxlckRhdGEucmVzcG9uc2UgO1xuICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgLi4uaGFuZGxlckRhdGEuZmV0Y2hEYXRhLFxuICAgICAgICBzdGF0dXNfY29kZTogcmVzcG9uc2U/LnN0YXR1cyxcbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZXJEYXRhLmZldGNoRGF0YS5yZXF1ZXN0X2JvZHlfc2l6ZTtcbiAgICAgIGhhbmRsZXJEYXRhLmZldGNoRGF0YS5yZXNwb25zZV9ib2R5X3NpemU7XG4gICAgICByZXNwb25zZT8uc3RhdHVzO1xuXG4gICAgICBjb25zdCBoaW50ID0ge1xuICAgICAgICBpbnB1dDogaGFuZGxlckRhdGEuYXJncyxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wLFxuICAgICAgICBlbmRUaW1lc3RhbXAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBicmVhZGNydW1iID0ge1xuICAgICAgICBjYXRlZ29yeTogJ2ZldGNoJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdHlwZTogJ2h0dHAnLFxuICAgICAgICBsZXZlbDogZ2V0QnJlYWRjcnVtYkxvZ0xldmVsRnJvbUh0dHBTdGF0dXNDb2RlKGRhdGEuc3RhdHVzX2NvZGUpLFxuICAgICAgfTtcblxuICAgICAgY2xpZW50LmVtaXQoJ2JlZm9yZU91dGdvaW5nUmVxdWVzdEJyZWFkY3J1bWInLCBicmVhZGNydW1iLCBoaW50ICk7XG5cbiAgICAgIGFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYiwgaGludCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYnJlYWRjcnVtYnMgZnJvbSBoaXN0b3J5IEFQSSBjYWxsc1xuICovXG5mdW5jdGlvbiBfZ2V0SGlzdG9yeUJyZWFkY3J1bWJIYW5kbGVyKGNsaWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gX2hpc3RvcnlCcmVhZGNydW1iKGhhbmRsZXJEYXRhKSB7XG4gICAgaWYgKGdldENsaWVudCgpICE9PSBjbGllbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZnJvbSA9IGhhbmRsZXJEYXRhLmZyb207XG4gICAgbGV0IHRvID0gaGFuZGxlckRhdGEudG87XG4gICAgY29uc3QgcGFyc2VkTG9jID0gcGFyc2VVcmwoV0lORE9XLmxvY2F0aW9uLmhyZWYpO1xuICAgIGxldCBwYXJzZWRGcm9tID0gZnJvbSA/IHBhcnNlVXJsKGZyb20pIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHBhcnNlZFRvID0gcGFyc2VVcmwodG8pO1xuXG4gICAgLy8gSW5pdGlhbCBwdXNoU3RhdGUgZG9lc24ndCBwcm92aWRlIGBmcm9tYCBpbmZvcm1hdGlvblxuICAgIGlmICghcGFyc2VkRnJvbT8ucGF0aCkge1xuICAgICAgcGFyc2VkRnJvbSA9IHBhcnNlZExvYztcbiAgICB9XG5cbiAgICAvLyBVc2Ugb25seSB0aGUgcGF0aCBjb21wb25lbnQgb2YgdGhlIFVSTCBpZiB0aGUgVVJMIG1hdGNoZXMgdGhlIGN1cnJlbnRcbiAgICAvLyBkb2N1bWVudCAoYWxtb3N0IGFsbCB0aGUgdGltZSB3aGVuIHVzaW5nIHB1c2hTdGF0ZSlcbiAgICBpZiAocGFyc2VkTG9jLnByb3RvY29sID09PSBwYXJzZWRUby5wcm90b2NvbCAmJiBwYXJzZWRMb2MuaG9zdCA9PT0gcGFyc2VkVG8uaG9zdCkge1xuICAgICAgdG8gPSBwYXJzZWRUby5yZWxhdGl2ZTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZExvYy5wcm90b2NvbCA9PT0gcGFyc2VkRnJvbS5wcm90b2NvbCAmJiBwYXJzZWRMb2MuaG9zdCA9PT0gcGFyc2VkRnJvbS5ob3N0KSB7XG4gICAgICBmcm9tID0gcGFyc2VkRnJvbS5yZWxhdGl2ZTtcbiAgICB9XG5cbiAgICBhZGRCcmVhZGNydW1iKHtcbiAgICAgIGNhdGVnb3J5OiAnbmF2aWdhdGlvbicsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2lzRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhZXZlbnQgJiYgISEoZXZlbnQgKS50YXJnZXQ7XG59XG5cbmV4cG9ydCB7IGJyZWFkY3J1bWJzSW50ZWdyYXRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFkY3J1bWJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/breadcrumbs.js\n"));
- `./frontend/.next/static/chunks/main-app.js:128` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   browserApiErrorsIntegration: () => (/* binding */ browserApiErrorsIntegration)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/index.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/helpers.js\");\n\n\n\nconst DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'BroadcastChannel',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'SharedWorker',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\nconst INTEGRATION_NAME = 'BrowserApiErrors';\n\nconst _browserApiErrorsIntegration = ((options = {}) => {\n  const _options = {\n    XMLHttpRequest: true,\n    eventTarget: true,\n    requestAnimationFrame: true,\n    setInterval: true,\n    setTimeout: true,\n    unregisterOriginalCallbacks: false,\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO: This currently only works for the first client this is setup\n    // We may want to adjust this to check for client etc.\n    setupOnce() {\n      if (_options.setTimeout) {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.fill)(_helpers_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW, 'setTimeout', _wrapTimeFunction);\n      }\n\n      if (_options.setInterval) {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.fill)(_helpers_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW, 'setInterval', _wrapTimeFunction);\n      }\n\n      if (_options.requestAnimationFrame) {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.fill)(_helpers_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW, 'requestAnimationFrame', _wrapRAF);\n      }\n\n      if (_options.XMLHttpRequest && \"XMLHttpRequest\" in _helpers_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW) {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.fill)(XMLHttpRequest.prototype, 'send', _wrapXHR);\n      }\n\n      const eventTargetOption = _options.eventTarget;\n      if (eventTargetOption) {\n        const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n        eventTarget.forEach(target => _wrapEventTarget(target, _options));\n      }\n    },\n  };\n}) ;\n\n/**\n * Wrap timer functions and event targets to catch errors and provide better meta data.\n */\nconst browserApiErrorsIntegration = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.defineIntegration)(_browserApiErrorsIntegration);\n\nfunction _wrapTimeFunction(original) {\n  return function ( ...args) {\n    const originalCallback = args[0];\n    args[0] = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(originalCallback, {\n      mechanism: {\n        data: { function: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(original) },\n        handled: false,\n        type: 'instrument',\n      },\n    });\n    return original.apply(this, args);\n  };\n}\n\nfunction _wrapRAF(original) {\n  return function ( callback) {\n    return original.apply(this, [\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(original),\n          },\n          handled: false,\n          type: 'instrument',\n        },\n      }),\n    ]);\n  };\n}\n\nfunction _wrapXHR(originalSend) {\n  return function ( ...args) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const xhr = this;\n    const xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.fill)(xhr, prop, function (original) {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(original),\n              },\n              handled: false,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before BrowserApiErrors, get the name of original function\n          const originalFunction = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getOriginalFunction)(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(original, wrapOptions);\n        });\n      }\n    });\n\n    return originalSend.apply(this, args);\n  };\n}\n\nfunction _wrapEventTarget(target, integrationOptions) {\n  const globalObject = _helpers_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW ;\n  const proto = globalObject[target]?.prototype;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (!proto?.hasOwnProperty?.('addEventListener')) {\n    return;\n  }\n\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.fill)(proto, 'addEventListener', function (original)\n\n {\n    return function ( eventName, fn, options) {\n      try {\n        if (isEventListenerObject(fn)) {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          fn.handleEvent = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(fn),\n                target,\n              },\n              handled: false,\n              type: 'instrument',\n            },\n          });\n        }\n      } catch {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      if (integrationOptions.unregisterOriginalCallbacks) {\n        unregisterOriginalCallback(this, eventName, fn);\n      }\n\n      return original.apply(this, [\n        eventName,\n        (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.wrap)(fn, {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getFunctionName)(fn),\n              target,\n            },\n            handled: false,\n            type: 'instrument',\n          },\n        }),\n        options,\n      ]);\n    };\n  });\n\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.fill)(proto, 'removeEventListener', function (originalRemoveEventListener)\n\n {\n    return function ( eventName, fn, options) {\n      /**\n       * There are 2 possible scenarios here:\n       *\n       * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n       * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n       * as a pass-through, and call original `removeEventListener` with it.\n       *\n       * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n       * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n       * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n       * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n       * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n       *\n       * When someone adds a handler prior to initialization, and then do it again, but after,\n       * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n       * to get rid of the initial handler and it'd stick there forever.\n       */\n      try {\n        const originalEventHandler = (fn ).__sentry_wrapped__;\n        if (originalEventHandler) {\n          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n        }\n      } catch {\n        // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n      }\n      return originalRemoveEventListener.call(this, eventName, fn, options);\n    };\n  });\n}\n\nfunction isEventListenerObject(obj) {\n  return typeof (obj ).handleEvent === 'function';\n}\n\nfunction unregisterOriginalCallback(target, eventName, fn) {\n  if (\n    target &&\n    typeof target === 'object' &&\n    'removeEventListener' in target &&\n    typeof target.removeEventListener === 'function'\n  ) {\n    target.removeEventListener(eventName, fn);\n  }\n}\n\n\n//# sourceMappingURL=browserapierrors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2Jyb3dzZXJAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9pbnRlZ3JhdGlvbnMvYnJvd3NlcmFwaWVycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkY7QUFDaEQ7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQUksQ0FBQywrQ0FBTTtBQUNuQjs7QUFFQTtBQUNBLFFBQVEsa0RBQUksQ0FBQywrQ0FBTTtBQUNuQjs7QUFFQTtBQUNBLFFBQVEsa0RBQUksQ0FBQywrQ0FBTTtBQUNuQjs7QUFFQSxxQ0FBcUMsbUVBQTBCO0FBQy9ELFFBQVEsa0RBQUk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0RBQWlCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFJO0FBQ2xCO0FBQ0EsZ0JBQWdCLFVBQVUsNkRBQWUsWUFBWTtBQUNyRDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpREFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBZTtBQUNwQyxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsa0RBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2REFBZTtBQUN4QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLG1DQUFtQyxpRUFBbUI7QUFDdEQ7QUFDQSxpREFBaUQsNkRBQWU7QUFDaEU7O0FBRUE7QUFDQSxpQkFBaUIsaURBQUk7QUFDckIsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsK0NBQU07QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxrREFBSTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkRBQWU7QUFDeEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsaURBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQWU7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFLGtEQUFJOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrYnJvd3NlckA5LjQ2LjAvbm9kZV9tb2R1bGVzL0BzZW50cnkvYnJvd3Nlci9idWlsZC9ucG0vZXNtL2ludGVncmF0aW9ucy9icm93c2VyYXBpZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZUludGVncmF0aW9uLCBmaWxsLCBnZXRGdW5jdGlvbk5hbWUsIGdldE9yaWdpbmFsRnVuY3Rpb24gfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHsgV0lORE9XLCB3cmFwIH0gZnJvbSAnLi4vaGVscGVycy5qcyc7XG5cbmNvbnN0IERFRkFVTFRfRVZFTlRfVEFSR0VUID0gW1xuICAnRXZlbnRUYXJnZXQnLFxuICAnV2luZG93JyxcbiAgJ05vZGUnLFxuICAnQXBwbGljYXRpb25DYWNoZScsXG4gICdBdWRpb1RyYWNrTGlzdCcsXG4gICdCcm9hZGNhc3RDaGFubmVsJyxcbiAgJ0NoYW5uZWxNZXJnZXJOb2RlJyxcbiAgJ0NyeXB0b09wZXJhdGlvbicsXG4gICdFdmVudFNvdXJjZScsXG4gICdGaWxlUmVhZGVyJyxcbiAgJ0hUTUxVbmtub3duRWxlbWVudCcsXG4gICdJREJEYXRhYmFzZScsXG4gICdJREJSZXF1ZXN0JyxcbiAgJ0lEQlRyYW5zYWN0aW9uJyxcbiAgJ0tleU9wZXJhdGlvbicsXG4gICdNZWRpYUNvbnRyb2xsZXInLFxuICAnTWVzc2FnZVBvcnQnLFxuICAnTW9kYWxXaW5kb3cnLFxuICAnTm90aWZpY2F0aW9uJyxcbiAgJ1NWR0VsZW1lbnRJbnN0YW5jZScsXG4gICdTY3JlZW4nLFxuICAnU2hhcmVkV29ya2VyJyxcbiAgJ1RleHRUcmFjaycsXG4gICdUZXh0VHJhY2tDdWUnLFxuICAnVGV4dFRyYWNrTGlzdCcsXG4gICdXZWJTb2NrZXQnLFxuICAnV2ViU29ja2V0V29ya2VyJyxcbiAgJ1dvcmtlcicsXG4gICdYTUxIdHRwUmVxdWVzdCcsXG4gICdYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0JyxcbiAgJ1hNTEh0dHBSZXF1ZXN0VXBsb2FkJyxcbl07XG5cbmNvbnN0IElOVEVHUkFUSU9OX05BTUUgPSAnQnJvd3NlckFwaUVycm9ycyc7XG5cbmNvbnN0IF9icm93c2VyQXBpRXJyb3JzSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBfb3B0aW9ucyA9IHtcbiAgICBYTUxIdHRwUmVxdWVzdDogdHJ1ZSxcbiAgICBldmVudFRhcmdldDogdHJ1ZSxcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHRydWUsXG4gICAgc2V0SW50ZXJ2YWw6IHRydWUsXG4gICAgc2V0VGltZW91dDogdHJ1ZSxcbiAgICB1bnJlZ2lzdGVyT3JpZ2luYWxDYWxsYmFja3M6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIC8vIFRPRE86IFRoaXMgY3VycmVudGx5IG9ubHkgd29ya3MgZm9yIHRoZSBmaXJzdCBjbGllbnQgdGhpcyBpcyBzZXR1cFxuICAgIC8vIFdlIG1heSB3YW50IHRvIGFkanVzdCB0aGlzIHRvIGNoZWNrIGZvciBjbGllbnQgZXRjLlxuICAgIHNldHVwT25jZSgpIHtcbiAgICAgIGlmIChfb3B0aW9ucy5zZXRUaW1lb3V0KSB7XG4gICAgICAgIGZpbGwoV0lORE9XLCAnc2V0VGltZW91dCcsIF93cmFwVGltZUZ1bmN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9vcHRpb25zLnNldEludGVydmFsKSB7XG4gICAgICAgIGZpbGwoV0lORE9XLCAnc2V0SW50ZXJ2YWwnLCBfd3JhcFRpbWVGdW5jdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgZmlsbChXSU5ET1csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLCBfd3JhcFJBRik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfb3B0aW9ucy5YTUxIdHRwUmVxdWVzdCAmJiAnWE1MSHR0cFJlcXVlc3QnIGluIFdJTkRPVykge1xuICAgICAgICBmaWxsKFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSwgJ3NlbmQnLCBfd3JhcFhIUik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0T3B0aW9uID0gX29wdGlvbnMuZXZlbnRUYXJnZXQ7XG4gICAgICBpZiAoZXZlbnRUYXJnZXRPcHRpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSBBcnJheS5pc0FycmF5KGV2ZW50VGFyZ2V0T3B0aW9uKSA/IGV2ZW50VGFyZ2V0T3B0aW9uIDogREVGQVVMVF9FVkVOVF9UQVJHRVQ7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmZvckVhY2godGFyZ2V0ID0+IF93cmFwRXZlbnRUYXJnZXQodGFyZ2V0LCBfb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG59KSA7XG5cbi8qKlxuICogV3JhcCB0aW1lciBmdW5jdGlvbnMgYW5kIGV2ZW50IHRhcmdldHMgdG8gY2F0Y2ggZXJyb3JzIGFuZCBwcm92aWRlIGJldHRlciBtZXRhIGRhdGEuXG4gKi9cbmNvbnN0IGJyb3dzZXJBcGlFcnJvcnNJbnRlZ3JhdGlvbiA9IGRlZmluZUludGVncmF0aW9uKF9icm93c2VyQXBpRXJyb3JzSW50ZWdyYXRpb24pO1xuXG5mdW5jdGlvbiBfd3JhcFRpbWVGdW5jdGlvbihvcmlnaW5hbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCAuLi5hcmdzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxDYWxsYmFjayA9IGFyZ3NbMF07XG4gICAgYXJnc1swXSA9IHdyYXAob3JpZ2luYWxDYWxsYmFjaywge1xuICAgICAgbWVjaGFuaXNtOiB7XG4gICAgICAgIGRhdGE6IHsgZnVuY3Rpb246IGdldEZ1bmN0aW9uTmFtZShvcmlnaW5hbCkgfSxcbiAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgIHR5cGU6ICdpbnN0cnVtZW50JyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfd3JhcFJBRihvcmlnaW5hbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCBjYWxsYmFjaykge1xuICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXG4gICAgICB3cmFwKGNhbGxiYWNrLCB7XG4gICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uOiAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyxcbiAgICAgICAgICAgIGhhbmRsZXI6IGdldEZ1bmN0aW9uTmFtZShvcmlnaW5hbCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVkOiBmYWxzZSxcbiAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3dyYXBYSFIob3JpZ2luYWxTZW5kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoIC4uLmFyZ3MpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBjb25zdCB4aHIgPSB0aGlzO1xuICAgIGNvbnN0IHhtbEh0dHBSZXF1ZXN0UHJvcHMgPSBbJ29ubG9hZCcsICdvbmVycm9yJywgJ29ucHJvZ3Jlc3MnLCAnb25yZWFkeXN0YXRlY2hhbmdlJ107XG5cbiAgICB4bWxIdHRwUmVxdWVzdFByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAocHJvcCBpbiB4aHIgJiYgdHlwZW9mIHhocltwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmaWxsKHhociwgcHJvcCwgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gICAgICAgICAgY29uc3Qgd3JhcE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBwcm9wLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGdldEZ1bmN0aW9uTmFtZShvcmlnaW5hbCksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBJZiBJbnN0cnVtZW50IGludGVncmF0aW9uIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUgQnJvd3NlckFwaUVycm9ycywgZ2V0IHRoZSBuYW1lIG9mIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxGdW5jdGlvbiA9IGdldE9yaWdpbmFsRnVuY3Rpb24ob3JpZ2luYWwpO1xuICAgICAgICAgIGlmIChvcmlnaW5hbEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICB3cmFwT3B0aW9ucy5tZWNoYW5pc20uZGF0YS5oYW5kbGVyID0gZ2V0RnVuY3Rpb25OYW1lKG9yaWdpbmFsRnVuY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE90aGVyd2lzZSB3cmFwIGRpcmVjdGx5XG4gICAgICAgICAgcmV0dXJuIHdyYXAob3JpZ2luYWwsIHdyYXBPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3JpZ2luYWxTZW5kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfd3JhcEV2ZW50VGFyZ2V0KHRhcmdldCwgaW50ZWdyYXRpb25PcHRpb25zKSB7XG4gIGNvbnN0IGdsb2JhbE9iamVjdCA9IFdJTkRPVyA7XG4gIGNvbnN0IHByb3RvID0gZ2xvYmFsT2JqZWN0W3RhcmdldF0/LnByb3RvdHlwZTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmICghcHJvdG8/Lmhhc093blByb3BlcnR5Py4oJ2FkZEV2ZW50TGlzdGVuZXInKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZpbGwocHJvdG8sICdhZGRFdmVudExpc3RlbmVyJywgZnVuY3Rpb24gKG9yaWdpbmFsKVxuXG4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAoIGV2ZW50TmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc0V2ZW50TGlzdGVuZXJPYmplY3QoZm4pKSB7XG4gICAgICAgICAgLy8gRVNsaW50IGRpc2FibGUgZXhwbGFuYXRpb246XG4gICAgICAgICAgLy8gIEZpcnN0LCBpdCBpcyBnZW5lcmFsbHkgc2FmZSB0byBjYWxsIGB3cmFwYCB3aXRoIGFuIHVuYm91bmQgZnVuY3Rpb24uIEZ1cnRoZXJtb3JlLCB1c2luZyBgLmJpbmQoKWAgd291bGRcbiAgICAgICAgICAvLyAgaW50cm9kdWNlIGEgYnVnIGhlcmUsIGJlY2F1c2UgYmluZCByZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQgZG9lc24ndCBoYXZlIG91clxuICAgICAgICAgIC8vICBmbGFncyhsaWtlIF9fc2VudHJ5X29yaWdpbmFsX18pIGF0dGFjaGVkLiBgd3JhcGAgY2hlY2tzIGZvciB0aG9zZSBmbGFncyB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZy5cbiAgICAgICAgICAvLyAgV2l0aG91dCB0aG9zZSBmbGFncywgZXZlcnkgY2FsbCB0byBhZGRFdmVudExpc3RlbmVyIHdyYXBzIHRoZSBmdW5jdGlvbiBhZ2FpbiwgY2F1c2luZyBhIG1lbW9yeSBsZWFrLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICBmbi5oYW5kbGVFdmVudCA9IHdyYXAoZm4uaGFuZGxlRXZlbnQsIHtcbiAgICAgICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb246ICdoYW5kbGVFdmVudCcsXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogZ2V0RnVuY3Rpb25OYW1lKGZuKSxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gY2FuIHNvbWV0aW1lcyBnZXQgJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBwcm9wZXJ0eSBcImhhbmRsZSBFdmVudCdcbiAgICAgIH1cblxuICAgICAgaWYgKGludGVncmF0aW9uT3B0aW9ucy51bnJlZ2lzdGVyT3JpZ2luYWxDYWxsYmFja3MpIHtcbiAgICAgICAgdW5yZWdpc3Rlck9yaWdpbmFsQ2FsbGJhY2sodGhpcywgZXZlbnROYW1lLCBmbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgd3JhcChmbiwge1xuICAgICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBmdW5jdGlvbjogJ2FkZEV2ZW50TGlzdGVuZXInLFxuICAgICAgICAgICAgICBoYW5kbGVyOiBnZXRGdW5jdGlvbk5hbWUoZm4pLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICBdKTtcbiAgICB9O1xuICB9KTtcblxuICBmaWxsKHByb3RvLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsIGZ1bmN0aW9uIChvcmlnaW5hbFJlbW92ZUV2ZW50TGlzdGVuZXIpXG5cbiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICggZXZlbnROYW1lLCBmbiwgb3B0aW9ucykge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGVyZSBhcmUgMiBwb3NzaWJsZSBzY2VuYXJpb3MgaGVyZTpcbiAgICAgICAqXG4gICAgICAgKiAxLiBTb21lb25lIHBhc3NlcyBhIGNhbGxiYWNrLCB3aGljaCB3YXMgYXR0YWNoZWQgcHJpb3IgdG8gU2VudHJ5IGluaXRpYWxpemF0aW9uLCBvciBieSB1c2luZyB1bm1vZGlmaWVkXG4gICAgICAgKiBtZXRob2QsIGVnLiBgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci5jYWxsKGVsLCBuYW1lLCBoYW5kbGVyKS4gSW4gdGhpcyBjYXNlLCB3ZSB0cmVhdCB0aGlzIGZ1bmN0aW9uXG4gICAgICAgKiBhcyBhIHBhc3MtdGhyb3VnaCwgYW5kIGNhbGwgb3JpZ2luYWwgYHJlbW92ZUV2ZW50TGlzdGVuZXJgIHdpdGggaXQuXG4gICAgICAgKlxuICAgICAgICogMi4gU29tZW9uZSBwYXNzZXMgYSBjYWxsYmFjaywgd2hpY2ggd2FzIGF0dGFjaGVkIGFmdGVyIFNlbnRyeSB3YXMgaW5pdGlhbGl6ZWQsIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2FzIHVzaW5nXG4gICAgICAgKiBvdXIgd3JhcHBlZCB2ZXJzaW9uIG9mIGBhZGRFdmVudExpc3RlbmVyYCwgd2hpY2ggaW50ZXJuYWxseSBjYWxscyBgd3JhcGAgaGVscGVyLlxuICAgICAgICogVGhpcyBoZWxwZXIgXCJ3cmFwc1wiIHdob2xlIGNhbGxiYWNrIGluc2lkZSBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQsIGFuZCBhdHRhY2hlZCBhcHByb3ByaWF0ZSBtZXRhZGF0YSB0byBpdCxcbiAgICAgICAqIGluIG9yZGVyIGZvciB1cyB0byBtYWtlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB3cmFwcGVkL25vbi13cmFwcGVkIGZ1bmN0aW9ucyBwb3NzaWJsZS5cbiAgICAgICAqIElmIGEgZnVuY3Rpb24gd2FzIHdyYXBwZWQsIGl0IGhhcyBhZGRpdGlvbmFsIHByb3BlcnR5IG9mIGBfX3NlbnRyeV93cmFwcGVkX19gLCBob2xkaW5nIHRoZSBoYW5kbGVyLlxuICAgICAgICpcbiAgICAgICAqIFdoZW4gc29tZW9uZSBhZGRzIGEgaGFuZGxlciBwcmlvciB0byBpbml0aWFsaXphdGlvbiwgYW5kIHRoZW4gZG8gaXQgYWdhaW4sIGJ1dCBhZnRlcixcbiAgICAgICAqIHRoZW4gd2UgaGF2ZSB0byBkZXRhY2ggYm90aCBvZiB0aGVtLiBPdGhlcndpc2UsIGlmIHdlJ2QgZGV0YWNoIG9ubHkgd3JhcHBlZCBvbmUsIGl0J2QgYmUgaW1wb3NzaWJsZVxuICAgICAgICogdG8gZ2V0IHJpZCBvZiB0aGUgaW5pdGlhbCBoYW5kbGVyIGFuZCBpdCdkIHN0aWNrIHRoZXJlIGZvcmV2ZXIuXG4gICAgICAgKi9cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXZlbnRIYW5kbGVyID0gKGZuICkuX19zZW50cnlfd3JhcHBlZF9fO1xuICAgICAgICBpZiAob3JpZ2luYWxFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgICBvcmlnaW5hbFJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIG9yaWdpbmFsRXZlbnRIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGlnbm9yZSwgYWNjZXNzaW5nIF9fc2VudHJ5X3dyYXBwZWRfXyB3aWxsIHRocm93IGluIHNvbWUgU2VsZW5pdW0gZW52aXJvbm1lbnRzXG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxSZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lLCBmbiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzRXZlbnRMaXN0ZW5lck9iamVjdChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiAob2JqICkuaGFuZGxlRXZlbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXJPcmlnaW5hbENhbGxiYWNrKHRhcmdldCwgZXZlbnROYW1lLCBmbikge1xuICBpZiAoXG4gICAgdGFyZ2V0ICYmXG4gICAgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiZcbiAgICAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gdGFyZ2V0ICYmXG4gICAgdHlwZW9mIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xuICB9XG59XG5cbmV4cG9ydCB7IGJyb3dzZXJBcGlFcnJvcnNJbnRlZ3JhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3NlcmFwaWVycm9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/browserapierrors.js\n"));
- `./frontend/.next/static/chunks/main-app.js:326` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_PROFILE_DURATION_MS: () => (/* binding */ MAX_PROFILE_DURATION_MS),\n/* harmony export */   addProfileToGlobalCache: () => (/* binding */ addProfileToGlobalCache),\n/* harmony export */   addProfilesToEnvelope: () => (/* binding */ addProfilesToEnvelope),\n/* harmony export */   applyDebugMetadata: () => (/* binding */ applyDebugMetadata),\n/* harmony export */   convertJSSelfProfileToSampledFormat: () => (/* binding */ convertJSSelfProfileToSampledFormat),\n/* harmony export */   createProfilePayload: () => (/* binding */ createProfilePayload),\n/* harmony export */   createProfilingEvent: () => (/* binding */ createProfilingEvent),\n/* harmony export */   enrichWithThreadInformation: () => (/* binding */ enrichWithThreadInformation),\n/* harmony export */   findProfiledTransactionsFromEnvelope: () => (/* binding */ findProfiledTransactionsFromEnvelope),\n/* harmony export */   getActiveProfilesCount: () => (/* binding */ getActiveProfilesCount),\n/* harmony export */   isAutomatedPageLoadSpan: () => (/* binding */ isAutomatedPageLoadSpan),\n/* harmony export */   isValidSampleRate: () => (/* binding */ isValidSampleRate),\n/* harmony export */   shouldProfileSpan: () => (/* binding */ shouldProfileSpan),\n/* harmony export */   startJSSelfProfile: () => (/* binding */ startJSSelfProfile),\n/* harmony export */   takeProfileFromGlobalCache: () => (/* binding */ takeProfileFromGlobalCache)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/index.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../debug-build.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/debug-build.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/helpers.js\");\n\n\n\n\nconst MS_TO_NS = 1e6;\n// Use 0 as main thread id which is identical to threadId in node:worker_threads\n// where main logs 0 and workers seem to log in increments of 1\nconst THREAD_ID_STRING = String(0);\nconst THREAD_NAME = 'main';\n\n// We force make this optional to be on the safe side...\nconst navigator = _helpers_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.navigator ;\n\n// Machine properties (eval only once)\nlet OS_PLATFORM = '';\nlet OS_PLATFORM_VERSION = '';\nlet OS_ARCH = '';\nlet OS_BROWSER = navigator?.userAgent || '';\nlet OS_MODEL = '';\nconst OS_LOCALE = navigator?.language || navigator?.languages?.[0] || '';\n\nfunction isUserAgentData(data) {\n  return typeof data === 'object' && data !== null && 'getHighEntropyValues' in data;\n}\n\n// @ts-expect-error userAgentData is not part of the navigator interface yet\nconst userAgentData = navigator?.userAgentData;\n\nif (isUserAgentData(userAgentData)) {\n  userAgentData\n    .getHighEntropyValues(['architecture', 'model', 'platform', 'platformVersion', 'fullVersionList'])\n    .then((ua) => {\n      OS_PLATFORM = ua.platform || '';\n      OS_ARCH = ua.architecture || '';\n      OS_MODEL = ua.model || '';\n      OS_PLATFORM_VERSION = ua.platformVersion || '';\n\n      if (ua.fullVersionList?.length) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const firstUa = ua.fullVersionList[ua.fullVersionList.length - 1];\n        OS_BROWSER = `${firstUa.brand} ${firstUa.version}`;\n      }\n    })\n    .catch(e => void 0);\n}\n\nfunction isProcessedJSSelfProfile(profile) {\n  return !('thread_metadata' in profile);\n}\n\n// Enriches the profile with threadId of the current thread.\n// This is done in node as we seem to not be able to get the info from C native code.\n/**\n *\n */\nfunction enrichWithThreadInformation(profile) {\n  if (!isProcessedJSSelfProfile(profile)) {\n    return profile;\n  }\n\n  return convertJSSelfProfileToSampledFormat(profile);\n}\n\n// Profile is marked as optional because it is deleted from the metadata\n// by the integration before the event is processed by other integrations.\n\nfunction getTraceId(event) {\n  const traceId = event.contexts?.trace?.trace_id;\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (typeof traceId === 'string' && traceId.length !== 32) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log(`[Profiling] Invalid traceId: ${traceId} on profiled event`);\n    }\n  }\n  if (typeof traceId !== 'string') {\n    return '';\n  }\n\n  return traceId;\n}\n/**\n * Creates a profiling event envelope from a Sentry event. If profile does not pass\n * validation, returns null.\n * @param event\n * @param dsn\n * @param metadata\n * @param tunnel\n * @returns {EventEnvelope | null}\n */\n\n/**\n * Creates a profiling event envelope from a Sentry event.\n */\nfunction createProfilePayload(\n  profile_id,\n  start_timestamp,\n  processed_profile,\n  event,\n) {\n  if (event.type !== 'transaction') {\n    // createProfilingEventEnvelope should only be called for transactions,\n    // we type guard this behavior with isProfiledTransactionEvent.\n    throw new TypeError('Profiling events may only be attached to transactions, this should never occur.');\n  }\n\n  if (processed_profile === undefined || processed_profile === null) {\n    throw new TypeError(\n      `Cannot construct profiling event envelope without a valid profile. Got ${processed_profile} instead.`,\n    );\n  }\n\n  const traceId = getTraceId(event);\n  const enrichedThreadProfile = enrichWithThreadInformation(processed_profile);\n  const transactionStartMs = start_timestamp\n    ? start_timestamp\n    : typeof event.start_timestamp === 'number'\n      ? event.start_timestamp * 1000\n      : (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.timestampInSeconds)() * 1000;\n  const transactionEndMs = typeof event.timestamp === 'number' ? event.timestamp * 1000 : (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.timestampInSeconds)() * 1000;\n\n  const profile = {\n    event_id: profile_id,\n    timestamp: new Date(transactionStartMs).toISOString(),\n    platform: 'javascript',\n    version: '1',\n    release: event.release || '',\n    environment: event.environment || _sentry_core__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_ENVIRONMENT,\n    runtime: {\n      name: 'javascript',\n      version: _helpers_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.navigator.userAgent,\n    },\n    os: {\n      name: OS_PLATFORM,\n      version: OS_PLATFORM_VERSION,\n      build_number: OS_BROWSER,\n    },\n    device: {\n      locale: OS_LOCALE,\n      model: OS_MODEL,\n      manufacturer: OS_BROWSER,\n      architecture: OS_ARCH,\n      is_emulator: false,\n    },\n    debug_meta: {\n      images: applyDebugMetadata(processed_profile.resources),\n    },\n    profile: enrichedThreadProfile,\n    transactions: [\n      {\n        name: event.transaction || '',\n        id: event.event_id || (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.uuid4)(),\n        trace_id: traceId,\n        active_thread_id: THREAD_ID_STRING,\n        relative_start_ns: '0',\n        relative_end_ns: ((transactionEndMs - transactionStartMs) * 1e6).toFixed(0),\n      },\n    ],\n  };\n\n  return profile;\n}\n\n/*\n  See packages/browser-utils/src/browser/router.ts\n*/\n/**\n *\n */\nfunction isAutomatedPageLoadSpan(span) {\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.spanToJSON)(span).op === 'pageload';\n}\n\n/**\n * Converts a JSSelfProfile to a our sampled format.\n * Does not currently perform stack indexing.\n */\nfunction convertJSSelfProfileToSampledFormat(input) {\n  let EMPTY_STACK_ID = undefined;\n  let STACK_ID = 0;\n\n  // Initialize the profile that we will fill with data\n  const profile = {\n    samples: [],\n    stacks: [],\n    frames: [],\n    thread_metadata: {\n      [THREAD_ID_STRING]: { name: THREAD_NAME },\n    },\n  };\n\n  const firstSample = input.samples[0];\n  if (!firstSample) {\n    return profile;\n  }\n\n  // We assert samples.length > 0 above and timestamp should always be present\n  const start = firstSample.timestamp;\n  // The JS SDK might change it's time origin based on some heuristic (see See packages/utils/src/time.ts)\n  // when that happens, we need to ensure we are correcting the profile timings so the two timelines stay in sync.\n  // Since JS self profiling time origin is always initialized to performance.timeOrigin, we need to adjust for\n  // the drift between the SDK selected value and our profile time origin.\n  const perfOrigin = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.browserPerformanceTimeOrigin)();\n  const origin = typeof performance.timeOrigin === 'number' ? performance.timeOrigin : perfOrigin || 0;\n  const adjustForOriginChange = origin - (perfOrigin || origin);\n\n  input.samples.forEach((jsSample, i) => {\n    // If sample has no stack, add an empty sample\n    if (jsSample.stackId === undefined) {\n      if (EMPTY_STACK_ID === undefined) {\n        EMPTY_STACK_ID = STACK_ID;\n        profile.stacks[EMPTY_STACK_ID] = [];\n        STACK_ID++;\n      }\n\n      profile['samples'][i] = {\n        // convert ms timestamp to ns\n        elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n        stack_id: EMPTY_STACK_ID,\n        thread_id: THREAD_ID_STRING,\n      };\n      return;\n    }\n\n    let stackTop = input.stacks[jsSample.stackId];\n\n    // Functions in top->down order (root is last)\n    // We follow the stackTop.parentId trail and collect each visited frameId\n    const stack = [];\n\n    while (stackTop) {\n      stack.push(stackTop.frameId);\n\n      const frame = input.frames[stackTop.frameId];\n\n      // If our frame has not been indexed yet, index it\n      if (frame && profile.frames[stackTop.frameId] === undefined) {\n        profile.frames[stackTop.frameId] = {\n          function: frame.name,\n          abs_path: typeof frame.resourceId === 'number' ? input.resources[frame.resourceId] : undefined,\n          lineno: frame.line,\n          colno: frame.column,\n        };\n      }\n\n      stackTop = stackTop.parentId === undefined ? undefined : input.stacks[stackTop.parentId];\n    }\n\n    const sample = {\n      // convert ms timestamp to ns\n      elapsed_since_start_ns: ((jsSample.timestamp + adjustForOriginChange - start) * MS_TO_NS).toFixed(0),\n      stack_id: STACK_ID,\n      thread_id: THREAD_ID_STRING,\n    };\n\n    profile['stacks'][STACK_ID] = stack;\n    profile['samples'][i] = sample;\n    STACK_ID++;\n  });\n\n  return profile;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param envelope\n */\nfunction addProfilesToEnvelope(envelope, profiles) {\n  if (!profiles.length) {\n    return envelope;\n  }\n\n  for (const profile of profiles) {\n    envelope[1].push([{ type: 'profile' }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param envelope\n * @returns\n */\nfunction findProfiledTransactionsFromEnvelope(envelope) {\n  const events = [];\n\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.forEachEnvelopeItem)(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j] ;\n\n      if (event?.contexts?.profile?.profile_id) {\n        events.push(item[j] );\n      }\n    }\n  });\n\n  return events;\n}\n\n/**\n * Applies debug meta data to an event from a list of paths to resources (sourcemaps)\n */\nfunction applyDebugMetadata(resource_paths) {\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n  const options = client?.getOptions();\n  const stackParser = options?.stackParser;\n\n  if (!stackParser) {\n    return [];\n  }\n\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getDebugImagesForResources)(stackParser, resource_paths);\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if ((typeof rate !== 'number' && typeof rate !== 'boolean') || (typeof rate === 'number' && isNaN(rate))) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD &&\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.warn(\n        `[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD && _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\nfunction isValidProfile(profile) {\n  if (profile.samples.length < 2) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    }\n    return false;\n  }\n\n  if (!profile.frames.length) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log('[Profiling] Discarding profile because it contains no frames');\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// Keep a flag value to avoid re-initializing the profiler constructor. If it fails\n// once, it will always fail and this allows us to early return.\nlet PROFILING_CONSTRUCTOR_FAILED = false;\nconst MAX_PROFILE_DURATION_MS = 30000;\n\n/**\n * Check if profiler constructor is available.\n * @param maybeProfiler\n */\nfunction isJSProfilerSupported(maybeProfiler) {\n  return typeof maybeProfiler === 'function';\n}\n\n/**\n * Starts the profiler and returns the profiler instance.\n */\nfunction startJSSelfProfile() {\n  // Feature support check first\n  const JSProfilerConstructor = _helpers_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.Profiler;\n\n  if (!isJSProfilerSupported(JSProfilerConstructor)) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log('[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.');\n    }\n    return;\n  }\n\n  // From initial testing, it seems that the minimum value for sampleInterval is 10ms.\n  const samplingIntervalMS = 10;\n  // Start the profiler\n  const maxSamples = Math.floor(MAX_PROFILE_DURATION_MS / samplingIntervalMS);\n\n  // Attempt to initialize the profiler constructor, if it fails, we disable profiling for the current user session.\n  // This is likely due to a missing 'Document-Policy': 'js-profiling' header. We do not want to throw an error if this happens\n  // as we risk breaking the user's application, so just disable profiling and log an error.\n  try {\n    return new JSProfilerConstructor({ sampleInterval: samplingIntervalMS, maxBufferSize: maxSamples });\n  } catch (e) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log(\n        \"[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.\",\n      );\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log('[Profiling] Disabling profiling for current user session.');\n    }\n    PROFILING_CONSTRUCTOR_FAILED = true;\n  }\n\n  return;\n}\n\n/**\n * Determine if a profile should be profiled.\n */\nfunction shouldProfileSpan(span) {\n  // If constructor failed once, it will always fail, so we can early return.\n  if (PROFILING_CONSTRUCTOR_FAILED) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log('[Profiling] Profiling has been disabled for the duration of the current user session.');\n    }\n    return false;\n  }\n\n  if (!span.isRecording()) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log('[Profiling] Discarding profile because transaction was not sampled.');\n    }\n    return false;\n  }\n\n  const client = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n  const options = client?.getOptions();\n  if (!options) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD && _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log('[Profiling] Profiling disabled, no options found.');\n    return false;\n  }\n\n  // @ts-expect-error profilesSampleRate is not part of the browser options yet\n  const profilesSampleRate = options.profilesSampleRate;\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD && _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return false;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD &&\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log(\n        '[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0',\n      );\n    return false;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  const sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD &&\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log(\n        `[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(\n          profilesSampleRate,\n        )})`,\n      );\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param event\n * @returns {Profile | null}\n */\nfunction createProfilingEvent(\n  profile_id,\n  start_timestamp,\n  profile,\n  event,\n) {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n\n  return createProfilePayload(profile_id, start_timestamp, profile, event);\n}\n\n// TODO (v8): We need to obtain profile ids in @sentry-internal/tracing,\n// but we don't have access to this map because importing this map would\n// cause a circular dependency. We need to resolve this in v8.\nconst PROFILE_MAP = new Map();\n/**\n *\n */\nfunction getActiveProfilesCount() {\n  return PROFILE_MAP.size;\n}\n\n/**\n * Retrieves profile from global cache and removes it.\n */\nfunction takeProfileFromGlobalCache(profile_id) {\n  const profile = PROFILE_MAP.get(profile_id);\n  if (profile) {\n    PROFILE_MAP.delete(profile_id);\n  }\n  return profile;\n}\n/**\n * Adds profile to global cache and evicts the oldest profile if the cache is full.\n */\nfunction addProfileToGlobalCache(profile_id, profile) {\n  PROFILE_MAP.set(profile_id, profile);\n\n  if (PROFILE_MAP.size > 30) {\n    const last = PROFILE_MAP.keys().next().value;\n    PROFILE_MAP.delete(last);\n  }\n}\n\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2Jyb3dzZXJAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9wcm9maWxpbmcvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJMO0FBQzNJO0FBQ1Q7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsK0NBQU07O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWUsRUFBRSxnQkFBZ0I7QUFDekQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFXO0FBQ25CLE1BQU0sK0NBQUsscUNBQXFDLFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGLG1CQUFtQjtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0VBQWtCO0FBQzFCLDBGQUEwRixnRUFBa0I7O0FBRTVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2REFBbUI7QUFDekQ7QUFDQTtBQUNBLGVBQWUsK0NBQU07QUFDckIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1EQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0RBQVU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBFQUE0QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLGlFQUFtQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1REFBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHdFQUEwQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFXO0FBQ2YsTUFBTSwrQ0FBSztBQUNYLDJHQUEyRztBQUMzRztBQUNBLFdBQVcsVUFBVSw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHdEQUFXLElBQUksK0NBQUssbUZBQW1GLEtBQUs7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrQ0FBSztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsTUFBTSwrQ0FBSztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0NBQU07O0FBRXRDO0FBQ0EsUUFBUSx3REFBVztBQUNuQixNQUFNLCtDQUFLO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtEQUErRDtBQUN0RyxJQUFJO0FBQ0osUUFBUSx3REFBVztBQUNuQixNQUFNLCtDQUFLO0FBQ1g7QUFDQTtBQUNBLE1BQU0sK0NBQUs7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUFXO0FBQ25CLE1BQU0sK0NBQUs7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHdEQUFXO0FBQ25CLE1BQU0sK0NBQUs7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHVEQUFTO0FBQzFCO0FBQ0E7QUFDQSxJQUFJLHdEQUFXLElBQUksK0NBQUs7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0RBQVcsSUFBSSwrQ0FBSztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHdEQUFXO0FBQ2YsTUFBTSwrQ0FBSztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFXO0FBQ2YsTUFBTSwrQ0FBSztBQUNYLDBHQUEwRztBQUMxRztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa1k7QUFDbFkiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeSticm93c2VyQDkuNDYuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS9icm93c2VyL2J1aWxkL25wbS9lc20vcHJvZmlsaW5nL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNwYW5Ub0pTT04sIGRlYnVnLCBnZXRDbGllbnQsIGZvckVhY2hFbnZlbG9wZUl0ZW0sIHRpbWVzdGFtcEluU2Vjb25kcywgdXVpZDQsIERFRkFVTFRfRU5WSVJPTk1FTlQsIGdldERlYnVnSW1hZ2VzRm9yUmVzb3VyY2VzLCBicm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgV0lORE9XIH0gZnJvbSAnLi4vaGVscGVycy5qcyc7XG5cbmNvbnN0IE1TX1RPX05TID0gMWU2O1xuLy8gVXNlIDAgYXMgbWFpbiB0aHJlYWQgaWQgd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHRocmVhZElkIGluIG5vZGU6d29ya2VyX3RocmVhZHNcbi8vIHdoZXJlIG1haW4gbG9ncyAwIGFuZCB3b3JrZXJzIHNlZW0gdG8gbG9nIGluIGluY3JlbWVudHMgb2YgMVxuY29uc3QgVEhSRUFEX0lEX1NUUklORyA9IFN0cmluZygwKTtcbmNvbnN0IFRIUkVBRF9OQU1FID0gJ21haW4nO1xuXG4vLyBXZSBmb3JjZSBtYWtlIHRoaXMgb3B0aW9uYWwgdG8gYmUgb24gdGhlIHNhZmUgc2lkZS4uLlxuY29uc3QgbmF2aWdhdG9yID0gV0lORE9XLm5hdmlnYXRvciA7XG5cbi8vIE1hY2hpbmUgcHJvcGVydGllcyAoZXZhbCBvbmx5IG9uY2UpXG5sZXQgT1NfUExBVEZPUk0gPSAnJztcbmxldCBPU19QTEFURk9STV9WRVJTSU9OID0gJyc7XG5sZXQgT1NfQVJDSCA9ICcnO1xubGV0IE9TX0JST1dTRVIgPSBuYXZpZ2F0b3I/LnVzZXJBZ2VudCB8fCAnJztcbmxldCBPU19NT0RFTCA9ICcnO1xuY29uc3QgT1NfTE9DQUxFID0gbmF2aWdhdG9yPy5sYW5ndWFnZSB8fCBuYXZpZ2F0b3I/Lmxhbmd1YWdlcz8uWzBdIHx8ICcnO1xuXG5mdW5jdGlvbiBpc1VzZXJBZ2VudERhdGEoZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwgJiYgJ2dldEhpZ2hFbnRyb3B5VmFsdWVzJyBpbiBkYXRhO1xufVxuXG4vLyBAdHMtZXhwZWN0LWVycm9yIHVzZXJBZ2VudERhdGEgaXMgbm90IHBhcnQgb2YgdGhlIG5hdmlnYXRvciBpbnRlcmZhY2UgeWV0XG5jb25zdCB1c2VyQWdlbnREYXRhID0gbmF2aWdhdG9yPy51c2VyQWdlbnREYXRhO1xuXG5pZiAoaXNVc2VyQWdlbnREYXRhKHVzZXJBZ2VudERhdGEpKSB7XG4gIHVzZXJBZ2VudERhdGFcbiAgICAuZ2V0SGlnaEVudHJvcHlWYWx1ZXMoWydhcmNoaXRlY3R1cmUnLCAnbW9kZWwnLCAncGxhdGZvcm0nLCAncGxhdGZvcm1WZXJzaW9uJywgJ2Z1bGxWZXJzaW9uTGlzdCddKVxuICAgIC50aGVuKCh1YSkgPT4ge1xuICAgICAgT1NfUExBVEZPUk0gPSB1YS5wbGF0Zm9ybSB8fCAnJztcbiAgICAgIE9TX0FSQ0ggPSB1YS5hcmNoaXRlY3R1cmUgfHwgJyc7XG4gICAgICBPU19NT0RFTCA9IHVhLm1vZGVsIHx8ICcnO1xuICAgICAgT1NfUExBVEZPUk1fVkVSU0lPTiA9IHVhLnBsYXRmb3JtVmVyc2lvbiB8fCAnJztcblxuICAgICAgaWYgKHVhLmZ1bGxWZXJzaW9uTGlzdD8ubGVuZ3RoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IGZpcnN0VWEgPSB1YS5mdWxsVmVyc2lvbkxpc3RbdWEuZnVsbFZlcnNpb25MaXN0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBPU19CUk9XU0VSID0gYCR7Zmlyc3RVYS5icmFuZH0gJHtmaXJzdFVhLnZlcnNpb259YDtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5jYXRjaChlID0+IHZvaWQgMCk7XG59XG5cbmZ1bmN0aW9uIGlzUHJvY2Vzc2VkSlNTZWxmUHJvZmlsZShwcm9maWxlKSB7XG4gIHJldHVybiAhKCd0aHJlYWRfbWV0YWRhdGEnIGluIHByb2ZpbGUpO1xufVxuXG4vLyBFbnJpY2hlcyB0aGUgcHJvZmlsZSB3aXRoIHRocmVhZElkIG9mIHRoZSBjdXJyZW50IHRocmVhZC5cbi8vIFRoaXMgaXMgZG9uZSBpbiBub2RlIGFzIHdlIHNlZW0gdG8gbm90IGJlIGFibGUgdG8gZ2V0IHRoZSBpbmZvIGZyb20gQyBuYXRpdmUgY29kZS5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZW5yaWNoV2l0aFRocmVhZEluZm9ybWF0aW9uKHByb2ZpbGUpIHtcbiAgaWYgKCFpc1Byb2Nlc3NlZEpTU2VsZlByb2ZpbGUocHJvZmlsZSkpIHtcbiAgICByZXR1cm4gcHJvZmlsZTtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0SlNTZWxmUHJvZmlsZVRvU2FtcGxlZEZvcm1hdChwcm9maWxlKTtcbn1cblxuLy8gUHJvZmlsZSBpcyBtYXJrZWQgYXMgb3B0aW9uYWwgYmVjYXVzZSBpdCBpcyBkZWxldGVkIGZyb20gdGhlIG1ldGFkYXRhXG4vLyBieSB0aGUgaW50ZWdyYXRpb24gYmVmb3JlIHRoZSBldmVudCBpcyBwcm9jZXNzZWQgYnkgb3RoZXIgaW50ZWdyYXRpb25zLlxuXG5mdW5jdGlvbiBnZXRUcmFjZUlkKGV2ZW50KSB7XG4gIGNvbnN0IHRyYWNlSWQgPSBldmVudC5jb250ZXh0cz8udHJhY2U/LnRyYWNlX2lkO1xuICAvLyBMb2cgYSB3YXJuaW5nIGlmIHRoZSBwcm9maWxlIGhhcyBhbiBpbnZhbGlkIHRyYWNlSWQgKHNob3VsZCBiZSB1dWlkdjQpLlxuICAvLyBBbGwgcHJvZmlsZXMgYW5kIHRyYW5zYWN0aW9ucyBhcmUgcmVqZWN0ZWQgaWYgdGhpcyBpcyB0aGUgY2FzZSBhbmQgd2Ugd2FudCB0b1xuICAvLyB3YXJuIHVzZXJzIHRoYXQgdGhpcyBpcyBoYXBwZW5pbmcgaWYgdGhleSBlbmFibGUgZGVidWcgZmxhZ1xuICBpZiAodHlwZW9mIHRyYWNlSWQgPT09ICdzdHJpbmcnICYmIHRyYWNlSWQubGVuZ3RoICE9PSAzMikge1xuICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgZGVidWcubG9nKGBbUHJvZmlsaW5nXSBJbnZhbGlkIHRyYWNlSWQ6ICR7dHJhY2VJZH0gb24gcHJvZmlsZWQgZXZlbnRgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB0cmFjZUlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiB0cmFjZUlkO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvZmlsaW5nIGV2ZW50IGVudmVsb3BlIGZyb20gYSBTZW50cnkgZXZlbnQuIElmIHByb2ZpbGUgZG9lcyBub3QgcGFzc1xuICogdmFsaWRhdGlvbiwgcmV0dXJucyBudWxsLlxuICogQHBhcmFtIGV2ZW50XG4gKiBAcGFyYW0gZHNuXG4gKiBAcGFyYW0gbWV0YWRhdGFcbiAqIEBwYXJhbSB0dW5uZWxcbiAqIEByZXR1cm5zIHtFdmVudEVudmVsb3BlIHwgbnVsbH1cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm9maWxpbmcgZXZlbnQgZW52ZWxvcGUgZnJvbSBhIFNlbnRyeSBldmVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJvZmlsZVBheWxvYWQoXG4gIHByb2ZpbGVfaWQsXG4gIHN0YXJ0X3RpbWVzdGFtcCxcbiAgcHJvY2Vzc2VkX3Byb2ZpbGUsXG4gIGV2ZW50LFxuKSB7XG4gIGlmIChldmVudC50eXBlICE9PSAndHJhbnNhY3Rpb24nKSB7XG4gICAgLy8gY3JlYXRlUHJvZmlsaW5nRXZlbnRFbnZlbG9wZSBzaG91bGQgb25seSBiZSBjYWxsZWQgZm9yIHRyYW5zYWN0aW9ucyxcbiAgICAvLyB3ZSB0eXBlIGd1YXJkIHRoaXMgYmVoYXZpb3Igd2l0aCBpc1Byb2ZpbGVkVHJhbnNhY3Rpb25FdmVudC5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9maWxpbmcgZXZlbnRzIG1heSBvbmx5IGJlIGF0dGFjaGVkIHRvIHRyYW5zYWN0aW9ucywgdGhpcyBzaG91bGQgbmV2ZXIgb2NjdXIuJyk7XG4gIH1cblxuICBpZiAocHJvY2Vzc2VkX3Byb2ZpbGUgPT09IHVuZGVmaW5lZCB8fCBwcm9jZXNzZWRfcHJvZmlsZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgQ2Fubm90IGNvbnN0cnVjdCBwcm9maWxpbmcgZXZlbnQgZW52ZWxvcGUgd2l0aG91dCBhIHZhbGlkIHByb2ZpbGUuIEdvdCAke3Byb2Nlc3NlZF9wcm9maWxlfSBpbnN0ZWFkLmAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHRyYWNlSWQgPSBnZXRUcmFjZUlkKGV2ZW50KTtcbiAgY29uc3QgZW5yaWNoZWRUaHJlYWRQcm9maWxlID0gZW5yaWNoV2l0aFRocmVhZEluZm9ybWF0aW9uKHByb2Nlc3NlZF9wcm9maWxlKTtcbiAgY29uc3QgdHJhbnNhY3Rpb25TdGFydE1zID0gc3RhcnRfdGltZXN0YW1wXG4gICAgPyBzdGFydF90aW1lc3RhbXBcbiAgICA6IHR5cGVvZiBldmVudC5zdGFydF90aW1lc3RhbXAgPT09ICdudW1iZXInXG4gICAgICA/IGV2ZW50LnN0YXJ0X3RpbWVzdGFtcCAqIDEwMDBcbiAgICAgIDogdGltZXN0YW1wSW5TZWNvbmRzKCkgKiAxMDAwO1xuICBjb25zdCB0cmFuc2FjdGlvbkVuZE1zID0gdHlwZW9mIGV2ZW50LnRpbWVzdGFtcCA9PT0gJ251bWJlcicgPyBldmVudC50aW1lc3RhbXAgKiAxMDAwIDogdGltZXN0YW1wSW5TZWNvbmRzKCkgKiAxMDAwO1xuXG4gIGNvbnN0IHByb2ZpbGUgPSB7XG4gICAgZXZlbnRfaWQ6IHByb2ZpbGVfaWQsXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh0cmFuc2FjdGlvblN0YXJ0TXMpLnRvSVNPU3RyaW5nKCksXG4gICAgcGxhdGZvcm06ICdqYXZhc2NyaXB0JyxcbiAgICB2ZXJzaW9uOiAnMScsXG4gICAgcmVsZWFzZTogZXZlbnQucmVsZWFzZSB8fCAnJyxcbiAgICBlbnZpcm9ubWVudDogZXZlbnQuZW52aXJvbm1lbnQgfHwgREVGQVVMVF9FTlZJUk9OTUVOVCxcbiAgICBydW50aW1lOiB7XG4gICAgICBuYW1lOiAnamF2YXNjcmlwdCcsXG4gICAgICB2ZXJzaW9uOiBXSU5ET1cubmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICB9LFxuICAgIG9zOiB7XG4gICAgICBuYW1lOiBPU19QTEFURk9STSxcbiAgICAgIHZlcnNpb246IE9TX1BMQVRGT1JNX1ZFUlNJT04sXG4gICAgICBidWlsZF9udW1iZXI6IE9TX0JST1dTRVIsXG4gICAgfSxcbiAgICBkZXZpY2U6IHtcbiAgICAgIGxvY2FsZTogT1NfTE9DQUxFLFxuICAgICAgbW9kZWw6IE9TX01PREVMLFxuICAgICAgbWFudWZhY3R1cmVyOiBPU19CUk9XU0VSLFxuICAgICAgYXJjaGl0ZWN0dXJlOiBPU19BUkNILFxuICAgICAgaXNfZW11bGF0b3I6IGZhbHNlLFxuICAgIH0sXG4gICAgZGVidWdfbWV0YToge1xuICAgICAgaW1hZ2VzOiBhcHBseURlYnVnTWV0YWRhdGEocHJvY2Vzc2VkX3Byb2ZpbGUucmVzb3VyY2VzKSxcbiAgICB9LFxuICAgIHByb2ZpbGU6IGVucmljaGVkVGhyZWFkUHJvZmlsZSxcbiAgICB0cmFuc2FjdGlvbnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogZXZlbnQudHJhbnNhY3Rpb24gfHwgJycsXG4gICAgICAgIGlkOiBldmVudC5ldmVudF9pZCB8fCB1dWlkNCgpLFxuICAgICAgICB0cmFjZV9pZDogdHJhY2VJZCxcbiAgICAgICAgYWN0aXZlX3RocmVhZF9pZDogVEhSRUFEX0lEX1NUUklORyxcbiAgICAgICAgcmVsYXRpdmVfc3RhcnRfbnM6ICcwJyxcbiAgICAgICAgcmVsYXRpdmVfZW5kX25zOiAoKHRyYW5zYWN0aW9uRW5kTXMgLSB0cmFuc2FjdGlvblN0YXJ0TXMpICogMWU2KS50b0ZpeGVkKDApLFxuICAgICAgfSxcbiAgICBdLFxuICB9O1xuXG4gIHJldHVybiBwcm9maWxlO1xufVxuXG4vKlxuICBTZWUgcGFja2FnZXMvYnJvd3Nlci11dGlscy9zcmMvYnJvd3Nlci9yb3V0ZXIudHNcbiovXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGlzQXV0b21hdGVkUGFnZUxvYWRTcGFuKHNwYW4pIHtcbiAgcmV0dXJuIHNwYW5Ub0pTT04oc3Bhbikub3AgPT09ICdwYWdlbG9hZCc7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBKU1NlbGZQcm9maWxlIHRvIGEgb3VyIHNhbXBsZWQgZm9ybWF0LlxuICogRG9lcyBub3QgY3VycmVudGx5IHBlcmZvcm0gc3RhY2sgaW5kZXhpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRKU1NlbGZQcm9maWxlVG9TYW1wbGVkRm9ybWF0KGlucHV0KSB7XG4gIGxldCBFTVBUWV9TVEFDS19JRCA9IHVuZGVmaW5lZDtcbiAgbGV0IFNUQUNLX0lEID0gMDtcblxuICAvLyBJbml0aWFsaXplIHRoZSBwcm9maWxlIHRoYXQgd2Ugd2lsbCBmaWxsIHdpdGggZGF0YVxuICBjb25zdCBwcm9maWxlID0ge1xuICAgIHNhbXBsZXM6IFtdLFxuICAgIHN0YWNrczogW10sXG4gICAgZnJhbWVzOiBbXSxcbiAgICB0aHJlYWRfbWV0YWRhdGE6IHtcbiAgICAgIFtUSFJFQURfSURfU1RSSU5HXTogeyBuYW1lOiBUSFJFQURfTkFNRSB9LFxuICAgIH0sXG4gIH07XG5cbiAgY29uc3QgZmlyc3RTYW1wbGUgPSBpbnB1dC5zYW1wbGVzWzBdO1xuICBpZiAoIWZpcnN0U2FtcGxlKSB7XG4gICAgcmV0dXJuIHByb2ZpbGU7XG4gIH1cblxuICAvLyBXZSBhc3NlcnQgc2FtcGxlcy5sZW5ndGggPiAwIGFib3ZlIGFuZCB0aW1lc3RhbXAgc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50XG4gIGNvbnN0IHN0YXJ0ID0gZmlyc3RTYW1wbGUudGltZXN0YW1wO1xuICAvLyBUaGUgSlMgU0RLIG1pZ2h0IGNoYW5nZSBpdCdzIHRpbWUgb3JpZ2luIGJhc2VkIG9uIHNvbWUgaGV1cmlzdGljIChzZWUgU2VlIHBhY2thZ2VzL3V0aWxzL3NyYy90aW1lLnRzKVxuICAvLyB3aGVuIHRoYXQgaGFwcGVucywgd2UgbmVlZCB0byBlbnN1cmUgd2UgYXJlIGNvcnJlY3RpbmcgdGhlIHByb2ZpbGUgdGltaW5ncyBzbyB0aGUgdHdvIHRpbWVsaW5lcyBzdGF5IGluIHN5bmMuXG4gIC8vIFNpbmNlIEpTIHNlbGYgcHJvZmlsaW5nIHRpbWUgb3JpZ2luIGlzIGFsd2F5cyBpbml0aWFsaXplZCB0byBwZXJmb3JtYW5jZS50aW1lT3JpZ2luLCB3ZSBuZWVkIHRvIGFkanVzdCBmb3JcbiAgLy8gdGhlIGRyaWZ0IGJldHdlZW4gdGhlIFNESyBzZWxlY3RlZCB2YWx1ZSBhbmQgb3VyIHByb2ZpbGUgdGltZSBvcmlnaW4uXG4gIGNvbnN0IHBlcmZPcmlnaW4gPSBicm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luKCk7XG4gIGNvbnN0IG9yaWdpbiA9IHR5cGVvZiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luID09PSAnbnVtYmVyJyA/IHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gOiBwZXJmT3JpZ2luIHx8IDA7XG4gIGNvbnN0IGFkanVzdEZvck9yaWdpbkNoYW5nZSA9IG9yaWdpbiAtIChwZXJmT3JpZ2luIHx8IG9yaWdpbik7XG5cbiAgaW5wdXQuc2FtcGxlcy5mb3JFYWNoKChqc1NhbXBsZSwgaSkgPT4ge1xuICAgIC8vIElmIHNhbXBsZSBoYXMgbm8gc3RhY2ssIGFkZCBhbiBlbXB0eSBzYW1wbGVcbiAgICBpZiAoanNTYW1wbGUuc3RhY2tJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoRU1QVFlfU1RBQ0tfSUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBFTVBUWV9TVEFDS19JRCA9IFNUQUNLX0lEO1xuICAgICAgICBwcm9maWxlLnN0YWNrc1tFTVBUWV9TVEFDS19JRF0gPSBbXTtcbiAgICAgICAgU1RBQ0tfSUQrKztcbiAgICAgIH1cblxuICAgICAgcHJvZmlsZVsnc2FtcGxlcyddW2ldID0ge1xuICAgICAgICAvLyBjb252ZXJ0IG1zIHRpbWVzdGFtcCB0byBuc1xuICAgICAgICBlbGFwc2VkX3NpbmNlX3N0YXJ0X25zOiAoKGpzU2FtcGxlLnRpbWVzdGFtcCArIGFkanVzdEZvck9yaWdpbkNoYW5nZSAtIHN0YXJ0KSAqIE1TX1RPX05TKS50b0ZpeGVkKDApLFxuICAgICAgICBzdGFja19pZDogRU1QVFlfU1RBQ0tfSUQsXG4gICAgICAgIHRocmVhZF9pZDogVEhSRUFEX0lEX1NUUklORyxcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHN0YWNrVG9wID0gaW5wdXQuc3RhY2tzW2pzU2FtcGxlLnN0YWNrSWRdO1xuXG4gICAgLy8gRnVuY3Rpb25zIGluIHRvcC0+ZG93biBvcmRlciAocm9vdCBpcyBsYXN0KVxuICAgIC8vIFdlIGZvbGxvdyB0aGUgc3RhY2tUb3AucGFyZW50SWQgdHJhaWwgYW5kIGNvbGxlY3QgZWFjaCB2aXNpdGVkIGZyYW1lSWRcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuXG4gICAgd2hpbGUgKHN0YWNrVG9wKSB7XG4gICAgICBzdGFjay5wdXNoKHN0YWNrVG9wLmZyYW1lSWQpO1xuXG4gICAgICBjb25zdCBmcmFtZSA9IGlucHV0LmZyYW1lc1tzdGFja1RvcC5mcmFtZUlkXTtcblxuICAgICAgLy8gSWYgb3VyIGZyYW1lIGhhcyBub3QgYmVlbiBpbmRleGVkIHlldCwgaW5kZXggaXRcbiAgICAgIGlmIChmcmFtZSAmJiBwcm9maWxlLmZyYW1lc1tzdGFja1RvcC5mcmFtZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb2ZpbGUuZnJhbWVzW3N0YWNrVG9wLmZyYW1lSWRdID0ge1xuICAgICAgICAgIGZ1bmN0aW9uOiBmcmFtZS5uYW1lLFxuICAgICAgICAgIGFic19wYXRoOiB0eXBlb2YgZnJhbWUucmVzb3VyY2VJZCA9PT0gJ251bWJlcicgPyBpbnB1dC5yZXNvdXJjZXNbZnJhbWUucmVzb3VyY2VJZF0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgbGluZW5vOiBmcmFtZS5saW5lLFxuICAgICAgICAgIGNvbG5vOiBmcmFtZS5jb2x1bW4sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHN0YWNrVG9wID0gc3RhY2tUb3AucGFyZW50SWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGlucHV0LnN0YWNrc1tzdGFja1RvcC5wYXJlbnRJZF07XG4gICAgfVxuXG4gICAgY29uc3Qgc2FtcGxlID0ge1xuICAgICAgLy8gY29udmVydCBtcyB0aW1lc3RhbXAgdG8gbnNcbiAgICAgIGVsYXBzZWRfc2luY2Vfc3RhcnRfbnM6ICgoanNTYW1wbGUudGltZXN0YW1wICsgYWRqdXN0Rm9yT3JpZ2luQ2hhbmdlIC0gc3RhcnQpICogTVNfVE9fTlMpLnRvRml4ZWQoMCksXG4gICAgICBzdGFja19pZDogU1RBQ0tfSUQsXG4gICAgICB0aHJlYWRfaWQ6IFRIUkVBRF9JRF9TVFJJTkcsXG4gICAgfTtcblxuICAgIHByb2ZpbGVbJ3N0YWNrcyddW1NUQUNLX0lEXSA9IHN0YWNrO1xuICAgIHByb2ZpbGVbJ3NhbXBsZXMnXVtpXSA9IHNhbXBsZTtcbiAgICBTVEFDS19JRCsrO1xuICB9KTtcblxuICByZXR1cm4gcHJvZmlsZTtcbn1cblxuLyoqXG4gKiBBZGRzIGl0ZW1zIHRvIGVudmVsb3BlIGlmIHRoZXkgYXJlIG5vdCBhbHJlYWR5IHByZXNlbnQgLSBtdXRhdGVzIHRoZSBlbnZlbG9wZS5cbiAqIEBwYXJhbSBlbnZlbG9wZVxuICovXG5mdW5jdGlvbiBhZGRQcm9maWxlc1RvRW52ZWxvcGUoZW52ZWxvcGUsIHByb2ZpbGVzKSB7XG4gIGlmICghcHJvZmlsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGVudmVsb3BlO1xuICB9XG5cbiAgZm9yIChjb25zdCBwcm9maWxlIG9mIHByb2ZpbGVzKSB7XG4gICAgZW52ZWxvcGVbMV0ucHVzaChbeyB0eXBlOiAncHJvZmlsZScgfSwgcHJvZmlsZV0pO1xuICB9XG4gIHJldHVybiBlbnZlbG9wZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0cmFuc2FjdGlvbnMgd2l0aCBwcm9maWxlX2lkIGNvbnRleHQgaW4gdGhlIGVudmVsb3BlXG4gKiBAcGFyYW0gZW52ZWxvcGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGZpbmRQcm9maWxlZFRyYW5zYWN0aW9uc0Zyb21FbnZlbG9wZShlbnZlbG9wZSkge1xuICBjb25zdCBldmVudHMgPSBbXTtcblxuICBmb3JFYWNoRW52ZWxvcGVJdGVtKGVudmVsb3BlLCAoaXRlbSwgdHlwZSkgPT4ge1xuICAgIGlmICh0eXBlICE9PSAndHJhbnNhY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPCBpdGVtLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBldmVudCA9IGl0ZW1bal0gO1xuXG4gICAgICBpZiAoZXZlbnQ/LmNvbnRleHRzPy5wcm9maWxlPy5wcm9maWxlX2lkKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGl0ZW1bal0gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBldmVudHM7XG59XG5cbi8qKlxuICogQXBwbGllcyBkZWJ1ZyBtZXRhIGRhdGEgdG8gYW4gZXZlbnQgZnJvbSBhIGxpc3Qgb2YgcGF0aHMgdG8gcmVzb3VyY2VzIChzb3VyY2VtYXBzKVxuICovXG5mdW5jdGlvbiBhcHBseURlYnVnTWV0YWRhdGEocmVzb3VyY2VfcGF0aHMpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50KCk7XG4gIGNvbnN0IG9wdGlvbnMgPSBjbGllbnQ/LmdldE9wdGlvbnMoKTtcbiAgY29uc3Qgc3RhY2tQYXJzZXIgPSBvcHRpb25zPy5zdGFja1BhcnNlcjtcblxuICBpZiAoIXN0YWNrUGFyc2VyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGdldERlYnVnSW1hZ2VzRm9yUmVzb3VyY2VzKHN0YWNrUGFyc2VyLCByZXNvdXJjZV9wYXRocyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBnaXZlbiBzYW1wbGUgcmF0ZSB0byBtYWtlIHN1cmUgaXQgaXMgdmFsaWQgdHlwZSBhbmQgdmFsdWUgKGEgYm9vbGVhbiwgb3IgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxKS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNhbXBsZVJhdGUocmF0ZSkge1xuICAvLyB3ZSBuZWVkIHRvIGNoZWNrIE5hTiBleHBsaWNpdGx5IGJlY2F1c2UgaXQncyBvZiB0eXBlICdudW1iZXInIGFuZCB0aGVyZWZvcmUgd291bGRuJ3QgZ2V0IGNhdWdodCBieSB0aGlzIHR5cGVjaGVja1xuICBpZiAoKHR5cGVvZiByYXRlICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgcmF0ZSAhPT0gJ2Jvb2xlYW4nKSB8fCAodHlwZW9mIHJhdGUgPT09ICdudW1iZXInICYmIGlzTmFOKHJhdGUpKSkge1xuICAgIERFQlVHX0JVSUxEICYmXG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICBgW1Byb2ZpbGluZ10gSW52YWxpZCBzYW1wbGUgcmF0ZS4gU2FtcGxlIHJhdGUgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiBHb3QgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICByYXRlLFxuICAgICAgICApfSBvZiB0eXBlICR7SlNPTi5zdHJpbmdpZnkodHlwZW9mIHJhdGUpfS5gLFxuICAgICAgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBCb29sZWFuIHNhbXBsZSByYXRlcyBhcmUgYWx3YXlzIHZhbGlkXG4gIGlmIChyYXRlID09PSB0cnVlIHx8IHJhdGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpbiBjYXNlIHNhbXBsZVJhdGUgaXMgYSBib29sZWFuLCBpdCB3aWxsIGdldCBhdXRvbWF0aWNhbGx5IGNhc3QgdG8gMSBpZiBpdCdzIHRydWUgYW5kIDAgaWYgaXQncyBmYWxzZVxuICBpZiAocmF0ZSA8IDAgfHwgcmF0ZSA+IDEpIHtcbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy53YXJuKGBbUHJvZmlsaW5nXSBJbnZhbGlkIHNhbXBsZSByYXRlLiBTYW1wbGUgcmF0ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS4gR290ICR7cmF0ZX0uYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUHJvZmlsZShwcm9maWxlKSB7XG4gIGlmIChwcm9maWxlLnNhbXBsZXMubGVuZ3RoIDwgMikge1xuICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgLy8gTG9nIGEgd2FybmluZyBpZiB0aGUgcHJvZmlsZSBoYXMgbGVzcyB0aGFuIDIgc2FtcGxlcyBzbyB1c2VycyBjYW4ga25vdyB3aHlcbiAgICAgIC8vIHRoZXkgYXJlIG5vdCBzZWVpbmcgYW55IHByb2ZpbGluZyBkYXRhIGFuZCB3ZSBjYW50IGF2b2lkIHRoZSBiYWNrIGFuZCBmb3J0aFxuICAgICAgLy8gb2YgYXNraW5nIHRoZW0gdG8gcHJvdmlkZSB1cyB3aXRoIGEgZHVtcCBvZiB0aGUgcHJvZmlsZSBkYXRhLlxuICAgICAgZGVidWcubG9nKCdbUHJvZmlsaW5nXSBEaXNjYXJkaW5nIHByb2ZpbGUgYmVjYXVzZSBpdCBjb250YWlucyBsZXNzIHRoYW4gMiBzYW1wbGVzJyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghcHJvZmlsZS5mcmFtZXMubGVuZ3RoKSB7XG4gICAgaWYgKERFQlVHX0JVSUxEKSB7XG4gICAgICBkZWJ1Zy5sb2coJ1tQcm9maWxpbmddIERpc2NhcmRpbmcgcHJvZmlsZSBiZWNhdXNlIGl0IGNvbnRhaW5zIG5vIGZyYW1lcycpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gS2VlcCBhIGZsYWcgdmFsdWUgdG8gYXZvaWQgcmUtaW5pdGlhbGl6aW5nIHRoZSBwcm9maWxlciBjb25zdHJ1Y3Rvci4gSWYgaXQgZmFpbHNcbi8vIG9uY2UsIGl0IHdpbGwgYWx3YXlzIGZhaWwgYW5kIHRoaXMgYWxsb3dzIHVzIHRvIGVhcmx5IHJldHVybi5cbmxldCBQUk9GSUxJTkdfQ09OU1RSVUNUT1JfRkFJTEVEID0gZmFsc2U7XG5jb25zdCBNQVhfUFJPRklMRV9EVVJBVElPTl9NUyA9IDMwMDAwO1xuXG4vKipcbiAqIENoZWNrIGlmIHByb2ZpbGVyIGNvbnN0cnVjdG9yIGlzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSBtYXliZVByb2ZpbGVyXG4gKi9cbmZ1bmN0aW9uIGlzSlNQcm9maWxlclN1cHBvcnRlZChtYXliZVByb2ZpbGVyKSB7XG4gIHJldHVybiB0eXBlb2YgbWF5YmVQcm9maWxlciA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBTdGFydHMgdGhlIHByb2ZpbGVyIGFuZCByZXR1cm5zIHRoZSBwcm9maWxlciBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhcnRKU1NlbGZQcm9maWxlKCkge1xuICAvLyBGZWF0dXJlIHN1cHBvcnQgY2hlY2sgZmlyc3RcbiAgY29uc3QgSlNQcm9maWxlckNvbnN0cnVjdG9yID0gV0lORE9XLlByb2ZpbGVyO1xuXG4gIGlmICghaXNKU1Byb2ZpbGVyU3VwcG9ydGVkKEpTUHJvZmlsZXJDb25zdHJ1Y3RvcikpIHtcbiAgICBpZiAoREVCVUdfQlVJTEQpIHtcbiAgICAgIGRlYnVnLmxvZygnW1Byb2ZpbGluZ10gUHJvZmlsaW5nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLCBQcm9maWxlciBpbnRlcmZhY2UgbWlzc2luZyBvbiB3aW5kb3cgb2JqZWN0LicpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGcm9tIGluaXRpYWwgdGVzdGluZywgaXQgc2VlbXMgdGhhdCB0aGUgbWluaW11bSB2YWx1ZSBmb3Igc2FtcGxlSW50ZXJ2YWwgaXMgMTBtcy5cbiAgY29uc3Qgc2FtcGxpbmdJbnRlcnZhbE1TID0gMTA7XG4gIC8vIFN0YXJ0IHRoZSBwcm9maWxlclxuICBjb25zdCBtYXhTYW1wbGVzID0gTWF0aC5mbG9vcihNQVhfUFJPRklMRV9EVVJBVElPTl9NUyAvIHNhbXBsaW5nSW50ZXJ2YWxNUyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBpbml0aWFsaXplIHRoZSBwcm9maWxlciBjb25zdHJ1Y3RvciwgaWYgaXQgZmFpbHMsIHdlIGRpc2FibGUgcHJvZmlsaW5nIGZvciB0aGUgY3VycmVudCB1c2VyIHNlc3Npb24uXG4gIC8vIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBhIG1pc3NpbmcgJ0RvY3VtZW50LVBvbGljeSc6ICdqcy1wcm9maWxpbmcnIGhlYWRlci4gV2UgZG8gbm90IHdhbnQgdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhpcyBoYXBwZW5zXG4gIC8vIGFzIHdlIHJpc2sgYnJlYWtpbmcgdGhlIHVzZXIncyBhcHBsaWNhdGlvbiwgc28ganVzdCBkaXNhYmxlIHByb2ZpbGluZyBhbmQgbG9nIGFuIGVycm9yLlxuICB0cnkge1xuICAgIHJldHVybiBuZXcgSlNQcm9maWxlckNvbnN0cnVjdG9yKHsgc2FtcGxlSW50ZXJ2YWw6IHNhbXBsaW5nSW50ZXJ2YWxNUywgbWF4QnVmZmVyU2l6ZTogbWF4U2FtcGxlcyB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgZGVidWcubG9nKFxuICAgICAgICBcIltQcm9maWxpbmddIEZhaWxlZCB0byBpbml0aWFsaXplIHRoZSBQcm9maWxpbmcgY29uc3RydWN0b3IsIHRoaXMgaXMgbGlrZWx5IGR1ZSB0byBhIG1pc3NpbmcgJ0RvY3VtZW50LVBvbGljeSc6ICdqcy1wcm9maWxpbmcnIGhlYWRlci5cIixcbiAgICAgICk7XG4gICAgICBkZWJ1Zy5sb2coJ1tQcm9maWxpbmddIERpc2FibGluZyBwcm9maWxpbmcgZm9yIGN1cnJlbnQgdXNlciBzZXNzaW9uLicpO1xuICAgIH1cbiAgICBQUk9GSUxJTkdfQ09OU1RSVUNUT1JfRkFJTEVEID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBwcm9maWxlIHNob3VsZCBiZSBwcm9maWxlZC5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkUHJvZmlsZVNwYW4oc3Bhbikge1xuICAvLyBJZiBjb25zdHJ1Y3RvciBmYWlsZWQgb25jZSwgaXQgd2lsbCBhbHdheXMgZmFpbCwgc28gd2UgY2FuIGVhcmx5IHJldHVybi5cbiAgaWYgKFBST0ZJTElOR19DT05TVFJVQ1RPUl9GQUlMRUQpIHtcbiAgICBpZiAoREVCVUdfQlVJTEQpIHtcbiAgICAgIGRlYnVnLmxvZygnW1Byb2ZpbGluZ10gUHJvZmlsaW5nIGhhcyBiZWVuIGRpc2FibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgdXNlciBzZXNzaW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIXNwYW4uaXNSZWNvcmRpbmcoKSkge1xuICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgZGVidWcubG9nKCdbUHJvZmlsaW5nXSBEaXNjYXJkaW5nIHByb2ZpbGUgYmVjYXVzZSB0cmFuc2FjdGlvbiB3YXMgbm90IHNhbXBsZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudCgpO1xuICBjb25zdCBvcHRpb25zID0gY2xpZW50Py5nZXRPcHRpb25zKCk7XG4gIGlmICghb3B0aW9ucykge1xuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnW1Byb2ZpbGluZ10gUHJvZmlsaW5nIGRpc2FibGVkLCBubyBvcHRpb25zIGZvdW5kLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgcHJvZmlsZXNTYW1wbGVSYXRlIGlzIG5vdCBwYXJ0IG9mIHRoZSBicm93c2VyIG9wdGlvbnMgeWV0XG4gIGNvbnN0IHByb2ZpbGVzU2FtcGxlUmF0ZSA9IG9wdGlvbnMucHJvZmlsZXNTYW1wbGVSYXRlO1xuXG4gIC8vIFNpbmNlIHRoaXMgaXMgY29taW5nIGZyb20gdGhlIHVzZXIgKG9yIGZyb20gYSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciksIHdobyBrbm93cyB3aGF0IHdlIG1pZ2h0IGdldC4gKFRoZVxuICAvLyBvbmx5IHZhbGlkIHZhbHVlcyBhcmUgYm9vbGVhbnMgb3IgbnVtYmVycyBiZXR3ZWVuIDAgYW5kIDEuKVxuICBpZiAoIWlzVmFsaWRTYW1wbGVSYXRlKHByb2ZpbGVzU2FtcGxlUmF0ZSkpIHtcbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy53YXJuKCdbUHJvZmlsaW5nXSBEaXNjYXJkaW5nIHByb2ZpbGUgYmVjYXVzZSBvZiBpbnZhbGlkIHNhbXBsZSByYXRlLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCAwIChvciBmYWxzZSksIG9yIGlmIGBwcm9maWxlU2FtcGxlUmF0ZWAgaXMgMCwgaXQncyBhIHNpZ24gdGhlIHByb2ZpbGUgc2hvdWxkIGJlIGRyb3BwZWRcbiAgaWYgKCFwcm9maWxlc1NhbXBsZVJhdGUpIHtcbiAgICBERUJVR19CVUlMRCAmJlxuICAgICAgZGVidWcubG9nKFxuICAgICAgICAnW1Byb2ZpbGluZ10gRGlzY2FyZGluZyBwcm9maWxlIGJlY2F1c2UgYSBuZWdhdGl2ZSBzYW1wbGluZyBkZWNpc2lvbiB3YXMgaW5oZXJpdGVkIG9yIHByb2ZpbGVTYW1wbGVSYXRlIGlzIHNldCB0byAwJyxcbiAgICAgICk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTm93IHdlIHJvbGwgdGhlIGRpY2UuIE1hdGgucmFuZG9tIGlzIGluY2x1c2l2ZSBvZiAwLCBidXQgbm90IG9mIDEsIHNvIHN0cmljdCA8IGlzIHNhZmUgaGVyZS4gSW4gY2FzZSBzYW1wbGVSYXRlIGlzXG4gIC8vIGEgYm9vbGVhbiwgdGhlIDwgY29tcGFyaXNvbiB3aWxsIGNhdXNlIGl0IHRvIGJlIGF1dG9tYXRpY2FsbHkgY2FzdCB0byAxIGlmIGl0J3MgdHJ1ZSBhbmQgMCBpZiBpdCdzIGZhbHNlLlxuICBjb25zdCBzYW1wbGVkID0gcHJvZmlsZXNTYW1wbGVSYXRlID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgucmFuZG9tKCkgPCBwcm9maWxlc1NhbXBsZVJhdGU7XG4gIC8vIENoZWNrIGlmIHdlIHNob3VsZCBzYW1wbGUgdGhpcyBwcm9maWxlXG4gIGlmICghc2FtcGxlZCkge1xuICAgIERFQlVHX0JVSUxEICYmXG4gICAgICBkZWJ1Zy5sb2coXG4gICAgICAgIGBbUHJvZmlsaW5nXSBEaXNjYXJkaW5nIHByb2ZpbGUgYmVjYXVzZSBpdCdzIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmFuZG9tIHNhbXBsZSAoc2FtcGxpbmcgcmF0ZSA9ICR7TnVtYmVyKFxuICAgICAgICAgIHByb2ZpbGVzU2FtcGxlUmF0ZSxcbiAgICAgICAgKX0pYCxcbiAgICAgICk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb2ZpbGluZyBlbnZlbG9wZSBpdGVtLCBpZiB0aGUgcHJvZmlsZSBkb2VzIG5vdCBwYXNzIHZhbGlkYXRpb24sIHJldHVybnMgbnVsbC5cbiAqIEBwYXJhbSBldmVudFxuICogQHJldHVybnMge1Byb2ZpbGUgfCBudWxsfVxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9maWxpbmdFdmVudChcbiAgcHJvZmlsZV9pZCxcbiAgc3RhcnRfdGltZXN0YW1wLFxuICBwcm9maWxlLFxuICBldmVudCxcbikge1xuICBpZiAoIWlzVmFsaWRQcm9maWxlKHByb2ZpbGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUHJvZmlsZVBheWxvYWQocHJvZmlsZV9pZCwgc3RhcnRfdGltZXN0YW1wLCBwcm9maWxlLCBldmVudCk7XG59XG5cbi8vIFRPRE8gKHY4KTogV2UgbmVlZCB0byBvYnRhaW4gcHJvZmlsZSBpZHMgaW4gQHNlbnRyeS1pbnRlcm5hbC90cmFjaW5nLFxuLy8gYnV0IHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoaXMgbWFwIGJlY2F1c2UgaW1wb3J0aW5nIHRoaXMgbWFwIHdvdWxkXG4vLyBjYXVzZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3kuIFdlIG5lZWQgdG8gcmVzb2x2ZSB0aGlzIGluIHY4LlxuY29uc3QgUFJPRklMRV9NQVAgPSBuZXcgTWFwKCk7XG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZVByb2ZpbGVzQ291bnQoKSB7XG4gIHJldHVybiBQUk9GSUxFX01BUC5zaXplO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyBwcm9maWxlIGZyb20gZ2xvYmFsIGNhY2hlIGFuZCByZW1vdmVzIGl0LlxuICovXG5mdW5jdGlvbiB0YWtlUHJvZmlsZUZyb21HbG9iYWxDYWNoZShwcm9maWxlX2lkKSB7XG4gIGNvbnN0IHByb2ZpbGUgPSBQUk9GSUxFX01BUC5nZXQocHJvZmlsZV9pZCk7XG4gIGlmIChwcm9maWxlKSB7XG4gICAgUFJPRklMRV9NQVAuZGVsZXRlKHByb2ZpbGVfaWQpO1xuICB9XG4gIHJldHVybiBwcm9maWxlO1xufVxuLyoqXG4gKiBBZGRzIHByb2ZpbGUgdG8gZ2xvYmFsIGNhY2hlIGFuZCBldmljdHMgdGhlIG9sZGVzdCBwcm9maWxlIGlmIHRoZSBjYWNoZSBpcyBmdWxsLlxuICovXG5mdW5jdGlvbiBhZGRQcm9maWxlVG9HbG9iYWxDYWNoZShwcm9maWxlX2lkLCBwcm9maWxlKSB7XG4gIFBST0ZJTEVfTUFQLnNldChwcm9maWxlX2lkLCBwcm9maWxlKTtcblxuICBpZiAoUFJPRklMRV9NQVAuc2l6ZSA+IDMwKSB7XG4gICAgY29uc3QgbGFzdCA9IFBST0ZJTEVfTUFQLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgUFJPRklMRV9NQVAuZGVsZXRlKGxhc3QpO1xuICB9XG59XG5cbmV4cG9ydCB7IE1BWF9QUk9GSUxFX0RVUkFUSU9OX01TLCBhZGRQcm9maWxlVG9HbG9iYWxDYWNoZSwgYWRkUHJvZmlsZXNUb0VudmVsb3BlLCBhcHBseURlYnVnTWV0YWRhdGEsIGNvbnZlcnRKU1NlbGZQcm9maWxlVG9TYW1wbGVkRm9ybWF0LCBjcmVhdGVQcm9maWxlUGF5bG9hZCwgY3JlYXRlUHJvZmlsaW5nRXZlbnQsIGVucmljaFdpdGhUaHJlYWRJbmZvcm1hdGlvbiwgZmluZFByb2ZpbGVkVHJhbnNhY3Rpb25zRnJvbUVudmVsb3BlLCBnZXRBY3RpdmVQcm9maWxlc0NvdW50LCBpc0F1dG9tYXRlZFBhZ2VMb2FkU3BhbiwgaXNWYWxpZFNhbXBsZVJhdGUsIHNob3VsZFByb2ZpbGVTcGFuLCBzdGFydEpTU2VsZlByb2ZpbGUsIHRha2VQcm9maWxlRnJvbUdsb2JhbENhY2hlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/profiling/utils.js\n"));
- `./frontend/.next/static/chunks/main-app.js:348` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   forceLoad: () => (/* binding */ forceLoad),\n/* harmony export */   getDefaultIntegrations: () => (/* binding */ getDefaultIntegrations),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   onLoad: () => (/* binding */ onLoad)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/index.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/client.js\");\n/* harmony import */ var _integrations_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./integrations/breadcrumbs.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/breadcrumbs.js\");\n/* harmony import */ var _integrations_browserapierrors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./integrations/browserapierrors.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/browserapierrors.js\");\n/* harmony import */ var _integrations_browsersession_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./integrations/browsersession.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/browsersession.js\");\n/* harmony import */ var _integrations_globalhandlers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./integrations/globalhandlers.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/globalhandlers.js\");\n/* harmony import */ var _integrations_httpcontext_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./integrations/httpcontext.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/httpcontext.js\");\n/* harmony import */ var _integrations_linkederrors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./integrations/linkederrors.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/linkederrors.js\");\n/* harmony import */ var _stack_parsers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./stack-parsers.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/stack-parsers.js\");\n/* harmony import */ var _transports_fetch_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./transports/fetch.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/transports/fetch.js\");\n/* harmony import */ var _utils_detectBrowserExtension_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/detectBrowserExtension.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/utils/detectBrowserExtension.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/** Get the default integrations for the browser SDK. */\nfunction getDefaultIntegrations(_options) {\n  /**\n   * Note: Please make sure this stays in sync with Angular SDK, which re-exports\n   * `getDefaultIntegrations` but with an adjusted set of integrations.\n   */\n  return [\n    // TODO(v10): Replace with `eventFiltersIntegration` once we remove the deprecated `inboundFiltersIntegration`\n    // eslint-disable-next-line deprecation/deprecation\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.inboundFiltersIntegration)(),\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.functionToStringIntegration)(),\n    (0,_integrations_browserapierrors_js__WEBPACK_IMPORTED_MODULE_3__.browserApiErrorsIntegration)(),\n    (0,_integrations_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_2__.breadcrumbsIntegration)(),\n    (0,_integrations_globalhandlers_js__WEBPACK_IMPORTED_MODULE_5__.globalHandlersIntegration)(),\n    (0,_integrations_linkederrors_js__WEBPACK_IMPORTED_MODULE_7__.linkedErrorsIntegration)(),\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.dedupeIntegration)(),\n    (0,_integrations_httpcontext_js__WEBPACK_IMPORTED_MODULE_6__.httpContextIntegration)(),\n    (0,_integrations_browsersession_js__WEBPACK_IMPORTED_MODULE_4__.browserSessionIntegration)(),\n  ];\n}\n\n/**\n * The Sentry Browser SDK Client.\n *\n * To use this SDK, call the {@link init} function as early as possible when\n * loading the web page. To set context information or send manual events, use\n * the provided methods.\n *\n * @example\n *\n * ```\n *\n * import { init } from '@sentry/browser';\n *\n * init({\n *   dsn: '__DSN__',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * import { addBreadcrumb } from '@sentry/browser';\n * addBreadcrumb({\n *   message: 'My Breadcrumb',\n *   // ...\n * });\n * ```\n *\n * @example\n *\n * ```\n *\n * import * as Sentry from '@sentry/browser';\n * Sentry.captureMessage('Hello, world!');\n * Sentry.captureException(new Error('Good bye'));\n * Sentry.captureEvent({\n *   message: 'Manual',\n *   stacktrace: [\n *     // ...\n *   ],\n * });\n * ```\n *\n * @see {@link BrowserOptions} for documentation on configuration options.\n */\nfunction init(options = {}) {\n  const shouldDisableBecauseIsBrowserExtenstion =\n    !options.skipBrowserExtensionCheck && (0,_utils_detectBrowserExtension_js__WEBPACK_IMPORTED_MODULE_10__.checkAndWarnIfIsEmbeddedBrowserExtension)();\n\n  const clientOptions = {\n    ...options,\n    enabled: shouldDisableBecauseIsBrowserExtenstion ? false : options.enabled,\n    stackParser: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.stackParserFromStackParserOptions)(options.stackParser || _stack_parsers_js__WEBPACK_IMPORTED_MODULE_8__.defaultStackParser),\n    integrations: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getIntegrationsToSetup)({\n      integrations: options.integrations,\n      defaultIntegrations:\n        options.defaultIntegrations == null ? getDefaultIntegrations() : options.defaultIntegrations,\n    }),\n    transport: options.transport || _transports_fetch_js__WEBPACK_IMPORTED_MODULE_9__.makeFetchTransport,\n  };\n  return (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.initAndBind)(_client_js__WEBPACK_IMPORTED_MODULE_1__.BrowserClient, clientOptions);\n}\n\n/**\n * This function is here to be API compatible with the loader.\n * @hidden\n */\nfunction forceLoad() {\n  // Noop\n}\n\n/**\n * This function is here to be API compatible with the loader.\n * @hidden\n */\nfunction onLoad(callback) {\n  callback();\n}\n\n\n//# sourceMappingURL=sdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2Jyb3dzZXJAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS9zZGsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlMO0FBQ3JJO0FBQzJCO0FBQ1U7QUFDSjtBQUNBO0FBQ047QUFDRTtBQUNqQjtBQUNHO0FBQ2tDOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUF5QjtBQUM3QixJQUFJLHlFQUEyQjtBQUMvQixJQUFJLDhGQUEyQjtBQUMvQixJQUFJLG9GQUFzQjtBQUMxQixJQUFJLDBGQUF5QjtBQUM3QixJQUFJLHNGQUF1QjtBQUMzQixJQUFJLCtEQUFpQjtBQUNyQixJQUFJLG9GQUFzQjtBQUMxQixJQUFJLDBGQUF5QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0I7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQ0FBMEMsMkdBQXdDOztBQUVsRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0VBQWlDLHdCQUF3QixpRUFBa0I7QUFDNUYsa0JBQWtCLG9FQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DLG9FQUFrQjtBQUN0RDtBQUNBLFNBQVMseURBQVcsQ0FBQyxxREFBYTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkQ7QUFDM0QiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeSticm93c2VyQDkuNDYuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS9icm93c2VyL2J1aWxkL25wbS9lc20vc2RrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluYm91bmRGaWx0ZXJzSW50ZWdyYXRpb24sIGZ1bmN0aW9uVG9TdHJpbmdJbnRlZ3JhdGlvbiwgZGVkdXBlSW50ZWdyYXRpb24sIGdldEludGVncmF0aW9uc1RvU2V0dXAsIHN0YWNrUGFyc2VyRnJvbVN0YWNrUGFyc2VyT3B0aW9ucywgaW5pdEFuZEJpbmQgfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHsgQnJvd3NlckNsaWVudCB9IGZyb20gJy4vY2xpZW50LmpzJztcbmltcG9ydCB7IGJyZWFkY3J1bWJzSW50ZWdyYXRpb24gfSBmcm9tICcuL2ludGVncmF0aW9ucy9icmVhZGNydW1icy5qcyc7XG5pbXBvcnQgeyBicm93c2VyQXBpRXJyb3JzSW50ZWdyYXRpb24gfSBmcm9tICcuL2ludGVncmF0aW9ucy9icm93c2VyYXBpZXJyb3JzLmpzJztcbmltcG9ydCB7IGJyb3dzZXJTZXNzaW9uSW50ZWdyYXRpb24gfSBmcm9tICcuL2ludGVncmF0aW9ucy9icm93c2Vyc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBnbG9iYWxIYW5kbGVyc0ludGVncmF0aW9uIH0gZnJvbSAnLi9pbnRlZ3JhdGlvbnMvZ2xvYmFsaGFuZGxlcnMuanMnO1xuaW1wb3J0IHsgaHR0cENvbnRleHRJbnRlZ3JhdGlvbiB9IGZyb20gJy4vaW50ZWdyYXRpb25zL2h0dHBjb250ZXh0LmpzJztcbmltcG9ydCB7IGxpbmtlZEVycm9yc0ludGVncmF0aW9uIH0gZnJvbSAnLi9pbnRlZ3JhdGlvbnMvbGlua2VkZXJyb3JzLmpzJztcbmltcG9ydCB7IGRlZmF1bHRTdGFja1BhcnNlciB9IGZyb20gJy4vc3RhY2stcGFyc2Vycy5qcyc7XG5pbXBvcnQgeyBtYWtlRmV0Y2hUcmFuc3BvcnQgfSBmcm9tICcuL3RyYW5zcG9ydHMvZmV0Y2guanMnO1xuaW1wb3J0IHsgY2hlY2tBbmRXYXJuSWZJc0VtYmVkZGVkQnJvd3NlckV4dGVuc2lvbiB9IGZyb20gJy4vdXRpbHMvZGV0ZWN0QnJvd3NlckV4dGVuc2lvbi5qcyc7XG5cbi8qKiBHZXQgdGhlIGRlZmF1bHQgaW50ZWdyYXRpb25zIGZvciB0aGUgYnJvd3NlciBTREsuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0SW50ZWdyYXRpb25zKF9vcHRpb25zKSB7XG4gIC8qKlxuICAgKiBOb3RlOiBQbGVhc2UgbWFrZSBzdXJlIHRoaXMgc3RheXMgaW4gc3luYyB3aXRoIEFuZ3VsYXIgU0RLLCB3aGljaCByZS1leHBvcnRzXG4gICAqIGBnZXREZWZhdWx0SW50ZWdyYXRpb25zYCBidXQgd2l0aCBhbiBhZGp1c3RlZCBzZXQgb2YgaW50ZWdyYXRpb25zLlxuICAgKi9cbiAgcmV0dXJuIFtcbiAgICAvLyBUT0RPKHYxMCk6IFJlcGxhY2Ugd2l0aCBgZXZlbnRGaWx0ZXJzSW50ZWdyYXRpb25gIG9uY2Ugd2UgcmVtb3ZlIHRoZSBkZXByZWNhdGVkIGBpbmJvdW5kRmlsdGVyc0ludGVncmF0aW9uYFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGluYm91bmRGaWx0ZXJzSW50ZWdyYXRpb24oKSxcbiAgICBmdW5jdGlvblRvU3RyaW5nSW50ZWdyYXRpb24oKSxcbiAgICBicm93c2VyQXBpRXJyb3JzSW50ZWdyYXRpb24oKSxcbiAgICBicmVhZGNydW1ic0ludGVncmF0aW9uKCksXG4gICAgZ2xvYmFsSGFuZGxlcnNJbnRlZ3JhdGlvbigpLFxuICAgIGxpbmtlZEVycm9yc0ludGVncmF0aW9uKCksXG4gICAgZGVkdXBlSW50ZWdyYXRpb24oKSxcbiAgICBodHRwQ29udGV4dEludGVncmF0aW9uKCksXG4gICAgYnJvd3NlclNlc3Npb25JbnRlZ3JhdGlvbigpLFxuICBdO1xufVxuXG4vKipcbiAqIFRoZSBTZW50cnkgQnJvd3NlciBTREsgQ2xpZW50LlxuICpcbiAqIFRvIHVzZSB0aGlzIFNESywgY2FsbCB0aGUge0BsaW5rIGluaXR9IGZ1bmN0aW9uIGFzIGVhcmx5IGFzIHBvc3NpYmxlIHdoZW5cbiAqIGxvYWRpbmcgdGhlIHdlYiBwYWdlLiBUbyBzZXQgY29udGV4dCBpbmZvcm1hdGlvbiBvciBzZW5kIG1hbnVhbCBldmVudHMsIHVzZVxuICogdGhlIHByb3ZpZGVkIG1ldGhvZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqXG4gKiBpbXBvcnQgeyBpbml0IH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbiAqXG4gKiBpbml0KHtcbiAqICAgZHNuOiAnX19EU05fXycsXG4gKiAgIC8vIC4uLlxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogaW1wb3J0IHsgYWRkQnJlYWRjcnVtYiB9IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XG4gKiBhZGRCcmVhZGNydW1iKHtcbiAqICAgbWVzc2FnZTogJ015IEJyZWFkY3J1bWInLFxuICogICAvLyAuLi5cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqXG4gKiBpbXBvcnQgKiBhcyBTZW50cnkgZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbiAqIFNlbnRyeS5jYXB0dXJlTWVzc2FnZSgnSGVsbG8sIHdvcmxkIScpO1xuICogU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24obmV3IEVycm9yKCdHb29kIGJ5ZScpKTtcbiAqIFNlbnRyeS5jYXB0dXJlRXZlbnQoe1xuICogICBtZXNzYWdlOiAnTWFudWFsJyxcbiAqICAgc3RhY2t0cmFjZTogW1xuICogICAgIC8vIC4uLlxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBCcm93c2VyT3B0aW9uc30gZm9yIGRvY3VtZW50YXRpb24gb24gY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBpbml0KG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzaG91bGREaXNhYmxlQmVjYXVzZUlzQnJvd3NlckV4dGVuc3Rpb24gPVxuICAgICFvcHRpb25zLnNraXBCcm93c2VyRXh0ZW5zaW9uQ2hlY2sgJiYgY2hlY2tBbmRXYXJuSWZJc0VtYmVkZGVkQnJvd3NlckV4dGVuc2lvbigpO1xuXG4gIGNvbnN0IGNsaWVudE9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBlbmFibGVkOiBzaG91bGREaXNhYmxlQmVjYXVzZUlzQnJvd3NlckV4dGVuc3Rpb24gPyBmYWxzZSA6IG9wdGlvbnMuZW5hYmxlZCxcbiAgICBzdGFja1BhcnNlcjogc3RhY2tQYXJzZXJGcm9tU3RhY2tQYXJzZXJPcHRpb25zKG9wdGlvbnMuc3RhY2tQYXJzZXIgfHwgZGVmYXVsdFN0YWNrUGFyc2VyKSxcbiAgICBpbnRlZ3JhdGlvbnM6IGdldEludGVncmF0aW9uc1RvU2V0dXAoe1xuICAgICAgaW50ZWdyYXRpb25zOiBvcHRpb25zLmludGVncmF0aW9ucyxcbiAgICAgIGRlZmF1bHRJbnRlZ3JhdGlvbnM6XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdEludGVncmF0aW9ucyA9PSBudWxsID8gZ2V0RGVmYXVsdEludGVncmF0aW9ucygpIDogb3B0aW9ucy5kZWZhdWx0SW50ZWdyYXRpb25zLFxuICAgIH0pLFxuICAgIHRyYW5zcG9ydDogb3B0aW9ucy50cmFuc3BvcnQgfHwgbWFrZUZldGNoVHJhbnNwb3J0LFxuICB9O1xuICByZXR1cm4gaW5pdEFuZEJpbmQoQnJvd3NlckNsaWVudCwgY2xpZW50T3B0aW9ucyk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBoZXJlIHRvIGJlIEFQSSBjb21wYXRpYmxlIHdpdGggdGhlIGxvYWRlci5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZm9yY2VMb2FkKCkge1xuICAvLyBOb29wXG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBoZXJlIHRvIGJlIEFQSSBjb21wYXRpYmxlIHdpdGggdGhlIGxvYWRlci5cbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gb25Mb2FkKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5cbmV4cG9ydCB7IGZvcmNlTG9hZCwgZ2V0RGVmYXVsdEludGVncmF0aW9ucywgaW5pdCwgb25Mb2FkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZGsuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/sdk.js\n"));
- `./frontend/.next/static/chunks/main-app.js:392` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PREVIOUS_TRACE_KEY: () => (/* binding */ PREVIOUS_TRACE_KEY),\n/* harmony export */   PREVIOUS_TRACE_MAX_DURATION: () => (/* binding */ PREVIOUS_TRACE_MAX_DURATION),\n/* harmony export */   PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE: () => (/* binding */ PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE),\n/* harmony export */   addPreviousTraceSpanLink: () => (/* binding */ addPreviousTraceSpanLink),\n/* harmony export */   getPreviousTraceFromSessionStorage: () => (/* binding */ getPreviousTraceFromSessionStorage),\n/* harmony export */   linkTraces: () => (/* binding */ linkTraces),\n/* harmony export */   spanContextSampled: () => (/* binding */ spanContextSampled),\n/* harmony export */   storePreviousTraceInSessionStorage: () => (/* binding */ storePreviousTraceInSessionStorage)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/index.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../debug-build.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/debug-build.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/helpers.js\");\n/* harmony import */ var _sentry_internal_browser_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry-internal/browser-utils */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry-internal+browser-utils@9.46.0/node_modules/@sentry-internal/browser-utils/build/esm/index.js\");\n/* harmony import */ var _stack_parsers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../stack-parsers.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/stack-parsers.js\");\n/* harmony import */ var _integrations_breadcrumbs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../integrations/breadcrumbs.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/breadcrumbs.js\");\n/* harmony import */ var _integrations_browserapierrors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../integrations/browserapierrors.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/browserapierrors.js\");\n/* harmony import */ var _integrations_browsersession_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../integrations/browsersession.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/browsersession.js\");\n/* harmony import */ var _integrations_globalhandlers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../integrations/globalhandlers.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/globalhandlers.js\");\n/* harmony import */ var _integrations_httpcontext_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../integrations/httpcontext.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/httpcontext.js\");\n/* harmony import */ var _integrations_linkederrors_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../integrations/linkederrors.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/integrations/linkederrors.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n// 1h in seconds\nconst PREVIOUS_TRACE_MAX_DURATION = 3600;\n\n// session storage key\nconst PREVIOUS_TRACE_KEY = 'sentry_previous_trace';\n\nconst PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE = 'sentry.previous_trace';\n\n/**\n * Takes care of linking traces and applying the (consistent) sampling behavoiour based on the passed options\n * @param options - options for linking traces and consistent trace sampling (@see BrowserTracingOptions)\n * @param client - Sentry client\n */\nfunction linkTraces(\n  client,\n  {\n    linkPreviousTrace,\n    consistentTraceSampling,\n  }\n\n,\n) {\n  const useSessionStorage = linkPreviousTrace === 'session-storage';\n\n  let inMemoryPreviousTraceInfo = useSessionStorage ? getPreviousTraceFromSessionStorage() : undefined;\n\n  client.on('spanStart', span => {\n    if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getRootSpan)(span) !== span) {\n      return;\n    }\n\n    const oldPropagationContext = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)().getPropagationContext();\n    inMemoryPreviousTraceInfo = addPreviousTraceSpanLink(inMemoryPreviousTraceInfo, span, oldPropagationContext);\n\n    if (useSessionStorage) {\n      storePreviousTraceInSessionStorage(inMemoryPreviousTraceInfo);\n    }\n  });\n\n  let isFirstTraceOnPageload = true;\n  if (consistentTraceSampling) {\n    /*\n    When users opt into `consistentTraceSampling`, we need to ensure that we propagate\n    the previous trace's sample rate and rand to the current trace. This is necessary because otherwise, span\n    metric extrapolation is inaccurate, as we'd propagate too high of a sample rate for the subsequent traces.\n\n    So therefore, we pretend that the previous trace was the parent trace of the newly started trace. To do that,\n    we mutate the propagation context of the current trace and set the sample rate and sample rand of the previous trace.\n    Timing-wise, it is fine because it happens before we even sample the root span.\n\n    @see https://github.com/getsentry/sentry-javascript/issues/15754\n    */\n    client.on('beforeSampling', mutableSamplingContextData => {\n      if (!inMemoryPreviousTraceInfo) {\n        return;\n      }\n\n      const scope = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)();\n      const currentPropagationContext = scope.getPropagationContext();\n\n      // We do not want to force-continue the sampling decision if we continue a trace\n      // that was started on the backend. Most prominently, this will happen in MPAs where\n      // users hard-navigate between pages. In this case, the sampling decision of a potentially\n      // started trace on the server takes precedence.\n      // Why? We want to prioritize inter-trace consistency over intra-trace consistency.\n      if (isFirstTraceOnPageload && currentPropagationContext.parentSpanId) {\n        isFirstTraceOnPageload = false;\n        return;\n      }\n\n      scope.setPropagationContext({\n        ...currentPropagationContext,\n        dsc: {\n          ...currentPropagationContext.dsc,\n          sample_rate: String(inMemoryPreviousTraceInfo.sampleRate),\n          sampled: String(spanContextSampled(inMemoryPreviousTraceInfo.spanContext)),\n        },\n        sampleRand: inMemoryPreviousTraceInfo.sampleRand,\n      });\n\n      mutableSamplingContextData.parentSampled = spanContextSampled(inMemoryPreviousTraceInfo.spanContext);\n      mutableSamplingContextData.parentSampleRate = inMemoryPreviousTraceInfo.sampleRate;\n\n      mutableSamplingContextData.spanAttributes = {\n        ...mutableSamplingContextData.spanAttributes,\n        [_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE]: inMemoryPreviousTraceInfo.sampleRate,\n      };\n    });\n  }\n}\n\n/**\n * Adds a previous_trace span link to the passed span if the passed\n * previousTraceInfo is still valid.\n *\n * @returns the updated previous trace info (based on the current span/trace) to\n * be used on the next call\n */\nfunction addPreviousTraceSpanLink(\n  previousTraceInfo,\n  span,\n  oldPropagationContext,\n) {\n  const spanJson = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.spanToJSON)(span);\n\n  function getSampleRate() {\n    try {\n      return (\n        Number(oldPropagationContext.dsc?.sample_rate) ?? Number(spanJson.data?.[_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE])\n      );\n    } catch {\n      return 0;\n    }\n  }\n\n  const updatedPreviousTraceInfo = {\n    spanContext: span.spanContext(),\n    startTimestamp: spanJson.start_timestamp,\n    sampleRate: getSampleRate(),\n    sampleRand: oldPropagationContext.sampleRand,\n  };\n\n  if (!previousTraceInfo) {\n    return updatedPreviousTraceInfo;\n  }\n\n  const previousTraceSpanCtx = previousTraceInfo.spanContext;\n  if (previousTraceSpanCtx.traceId === spanJson.trace_id) {\n    // This means, we're still in the same trace so let's not update the previous trace info\n    // or add a link to the current span.\n    // Once we move away from the long-lived, route-based trace model, we can remove this cases\n    return previousTraceInfo;\n  }\n\n  // Only add the link if the startTimeStamp of the previous trace's root span is within\n  // PREVIOUS_TRACE_MAX_DURATION (1h) of the current root span's startTimestamp\n  // This is done to\n  // - avoid adding links to \"stale\" traces\n  // - enable more efficient querying for previous/next traces in Sentry\n  if (Date.now() / 1000 - previousTraceInfo.startTimestamp <= PREVIOUS_TRACE_MAX_DURATION) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD) {\n      _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.log(\n        `Adding previous_trace ${previousTraceSpanCtx} link to span ${{\n          op: spanJson.op,\n          ...span.spanContext(),\n        }}`,\n      );\n    }\n\n    span.addLink({\n      context: previousTraceSpanCtx,\n      attributes: {\n        [_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE]: 'previous_trace',\n      },\n    });\n\n    // TODO: Remove this once EAP can store span links. We currently only set this attribute so that we\n    // can obtain the previous trace information from the EAP store. Long-term, EAP will handle\n    // span links and then we should remove this again. Also throwing in a TODO(v10), to remind us\n    // to check this at v10 time :)\n    span.setAttribute(\n      PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE,\n      `${previousTraceSpanCtx.traceId}-${previousTraceSpanCtx.spanId}-${\n        spanContextSampled(previousTraceSpanCtx) ? 1 : 0\n      }`,\n    );\n  }\n\n  return updatedPreviousTraceInfo;\n}\n\n/**\n * Stores @param previousTraceInfo in sessionStorage.\n */\nfunction storePreviousTraceInSessionStorage(previousTraceInfo) {\n  try {\n    _helpers_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.sessionStorage.setItem(PREVIOUS_TRACE_KEY, JSON.stringify(previousTraceInfo));\n  } catch (e) {\n    // Ignore potential errors (e.g. if sessionStorage is not available)\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_1__.DEBUG_BUILD && _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.warn('Could not store previous trace in sessionStorage', e);\n  }\n}\n\n/**\n * Retrieves the previous trace from sessionStorage if available.\n */\nfunction getPreviousTraceFromSessionStorage() {\n  try {\n    const previousTraceInfo = _helpers_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.sessionStorage?.getItem(PREVIOUS_TRACE_KEY);\n    // @ts-expect-error - intentionally risking JSON.parse throwing when previousTraceInfo is null to save bundle size\n    return JSON.parse(previousTraceInfo);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * see {@link import('@sentry/core').spanIsSampled}\n */\nfunction spanContextSampled(ctx) {\n  return ctx.traceFlags === 0x1;\n}\n\n\n//# sourceMappingURL=linkedTraces.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2Jyb3dzZXJAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2Jyb3dzZXIvYnVpbGQvbnBtL2VzbS90cmFjaW5nL2xpbmtlZFRyYWNlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStNO0FBQy9KO0FBQ1Q7QUFDQztBQUNYO0FBQ1c7QUFDSztBQUNGO0FBQ0E7QUFDSDtBQUNDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRLHlEQUFXO0FBQ25CO0FBQ0E7O0FBRUEsa0NBQWtDLDZEQUFlO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDZEQUFlO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsOEZBQW9EO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFVOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsK0VBQXFDO0FBQ3RIO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQVc7QUFDbkIsTUFBTSwrQ0FBSztBQUNYLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkVBQWlDO0FBQzFDLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkJBQTZCLEdBQUcsNEJBQTRCO0FBQ3JFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQ0FBTTtBQUNWLElBQUk7QUFDSjtBQUNBLElBQUksd0RBQVcsSUFBSSwrQ0FBSztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQU07QUFDcEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRWdPO0FBQ2hPIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrYnJvd3NlckA5LjQ2LjAvbm9kZV9tb2R1bGVzL0BzZW50cnkvYnJvd3Nlci9idWlsZC9ucG0vZXNtL3RyYWNpbmcvbGlua2VkVHJhY2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFJvb3RTcGFuLCBnZXRDdXJyZW50U2NvcGUsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUFJFVklPVVNfVFJBQ0VfU0FNUExFX1JBVEUsIHNwYW5Ub0pTT04sIGRlYnVnLCBTRU1BTlRJQ19MSU5LX0FUVFJJQlVURV9MSU5LX1RZUEUsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEUgfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHsgREVCVUdfQlVJTEQgfSBmcm9tICcuLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBXSU5ET1cgfSBmcm9tICcuLi9oZWxwZXJzLmpzJztcbmltcG9ydCAnQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzJztcbmltcG9ydCAnLi4vc3RhY2stcGFyc2Vycy5qcyc7XG5pbXBvcnQgJy4uL2ludGVncmF0aW9ucy9icmVhZGNydW1icy5qcyc7XG5pbXBvcnQgJy4uL2ludGVncmF0aW9ucy9icm93c2VyYXBpZXJyb3JzLmpzJztcbmltcG9ydCAnLi4vaW50ZWdyYXRpb25zL2Jyb3dzZXJzZXNzaW9uLmpzJztcbmltcG9ydCAnLi4vaW50ZWdyYXRpb25zL2dsb2JhbGhhbmRsZXJzLmpzJztcbmltcG9ydCAnLi4vaW50ZWdyYXRpb25zL2h0dHBjb250ZXh0LmpzJztcbmltcG9ydCAnLi4vaW50ZWdyYXRpb25zL2xpbmtlZGVycm9ycy5qcyc7XG5cbi8vIDFoIGluIHNlY29uZHNcbmNvbnN0IFBSRVZJT1VTX1RSQUNFX01BWF9EVVJBVElPTiA9IDM2MDA7XG5cbi8vIHNlc3Npb24gc3RvcmFnZSBrZXlcbmNvbnN0IFBSRVZJT1VTX1RSQUNFX0tFWSA9ICdzZW50cnlfcHJldmlvdXNfdHJhY2UnO1xuXG5jb25zdCBQUkVWSU9VU19UUkFDRV9UTVBfU1BBTl9BVFRSSUJVVEUgPSAnc2VudHJ5LnByZXZpb3VzX3RyYWNlJztcblxuLyoqXG4gKiBUYWtlcyBjYXJlIG9mIGxpbmtpbmcgdHJhY2VzIGFuZCBhcHBseWluZyB0aGUgKGNvbnNpc3RlbnQpIHNhbXBsaW5nIGJlaGF2b2lvdXIgYmFzZWQgb24gdGhlIHBhc3NlZCBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGxpbmtpbmcgdHJhY2VzIGFuZCBjb25zaXN0ZW50IHRyYWNlIHNhbXBsaW5nIChAc2VlIEJyb3dzZXJUcmFjaW5nT3B0aW9ucylcbiAqIEBwYXJhbSBjbGllbnQgLSBTZW50cnkgY2xpZW50XG4gKi9cbmZ1bmN0aW9uIGxpbmtUcmFjZXMoXG4gIGNsaWVudCxcbiAge1xuICAgIGxpbmtQcmV2aW91c1RyYWNlLFxuICAgIGNvbnNpc3RlbnRUcmFjZVNhbXBsaW5nLFxuICB9XG5cbixcbikge1xuICBjb25zdCB1c2VTZXNzaW9uU3RvcmFnZSA9IGxpbmtQcmV2aW91c1RyYWNlID09PSAnc2Vzc2lvbi1zdG9yYWdlJztcblxuICBsZXQgaW5NZW1vcnlQcmV2aW91c1RyYWNlSW5mbyA9IHVzZVNlc3Npb25TdG9yYWdlID8gZ2V0UHJldmlvdXNUcmFjZUZyb21TZXNzaW9uU3RvcmFnZSgpIDogdW5kZWZpbmVkO1xuXG4gIGNsaWVudC5vbignc3BhblN0YXJ0Jywgc3BhbiA9PiB7XG4gICAgaWYgKGdldFJvb3RTcGFuKHNwYW4pICE9PSBzcGFuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkUHJvcGFnYXRpb25Db250ZXh0ID0gZ2V0Q3VycmVudFNjb3BlKCkuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG4gICAgaW5NZW1vcnlQcmV2aW91c1RyYWNlSW5mbyA9IGFkZFByZXZpb3VzVHJhY2VTcGFuTGluayhpbk1lbW9yeVByZXZpb3VzVHJhY2VJbmZvLCBzcGFuLCBvbGRQcm9wYWdhdGlvbkNvbnRleHQpO1xuXG4gICAgaWYgKHVzZVNlc3Npb25TdG9yYWdlKSB7XG4gICAgICBzdG9yZVByZXZpb3VzVHJhY2VJblNlc3Npb25TdG9yYWdlKGluTWVtb3J5UHJldmlvdXNUcmFjZUluZm8pO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGlzRmlyc3RUcmFjZU9uUGFnZWxvYWQgPSB0cnVlO1xuICBpZiAoY29uc2lzdGVudFRyYWNlU2FtcGxpbmcpIHtcbiAgICAvKlxuICAgIFdoZW4gdXNlcnMgb3B0IGludG8gYGNvbnNpc3RlbnRUcmFjZVNhbXBsaW5nYCwgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB3ZSBwcm9wYWdhdGVcbiAgICB0aGUgcHJldmlvdXMgdHJhY2UncyBzYW1wbGUgcmF0ZSBhbmQgcmFuZCB0byB0aGUgY3VycmVudCB0cmFjZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvdGhlcndpc2UsIHNwYW5cbiAgICBtZXRyaWMgZXh0cmFwb2xhdGlvbiBpcyBpbmFjY3VyYXRlLCBhcyB3ZSdkIHByb3BhZ2F0ZSB0b28gaGlnaCBvZiBhIHNhbXBsZSByYXRlIGZvciB0aGUgc3Vic2VxdWVudCB0cmFjZXMuXG5cbiAgICBTbyB0aGVyZWZvcmUsIHdlIHByZXRlbmQgdGhhdCB0aGUgcHJldmlvdXMgdHJhY2Ugd2FzIHRoZSBwYXJlbnQgdHJhY2Ugb2YgdGhlIG5ld2x5IHN0YXJ0ZWQgdHJhY2UuIFRvIGRvIHRoYXQsXG4gICAgd2UgbXV0YXRlIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0IG9mIHRoZSBjdXJyZW50IHRyYWNlIGFuZCBzZXQgdGhlIHNhbXBsZSByYXRlIGFuZCBzYW1wbGUgcmFuZCBvZiB0aGUgcHJldmlvdXMgdHJhY2UuXG4gICAgVGltaW5nLXdpc2UsIGl0IGlzIGZpbmUgYmVjYXVzZSBpdCBoYXBwZW5zIGJlZm9yZSB3ZSBldmVuIHNhbXBsZSB0aGUgcm9vdCBzcGFuLlxuXG4gICAgQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8xNTc1NFxuICAgICovXG4gICAgY2xpZW50Lm9uKCdiZWZvcmVTYW1wbGluZycsIG11dGFibGVTYW1wbGluZ0NvbnRleHREYXRhID0+IHtcbiAgICAgIGlmICghaW5NZW1vcnlQcmV2aW91c1RyYWNlSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gICAgICBjb25zdCBjdXJyZW50UHJvcGFnYXRpb25Db250ZXh0ID0gc2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG5cbiAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIGZvcmNlLWNvbnRpbnVlIHRoZSBzYW1wbGluZyBkZWNpc2lvbiBpZiB3ZSBjb250aW51ZSBhIHRyYWNlXG4gICAgICAvLyB0aGF0IHdhcyBzdGFydGVkIG9uIHRoZSBiYWNrZW5kLiBNb3N0IHByb21pbmVudGx5LCB0aGlzIHdpbGwgaGFwcGVuIGluIE1QQXMgd2hlcmVcbiAgICAgIC8vIHVzZXJzIGhhcmQtbmF2aWdhdGUgYmV0d2VlbiBwYWdlcy4gSW4gdGhpcyBjYXNlLCB0aGUgc2FtcGxpbmcgZGVjaXNpb24gb2YgYSBwb3RlbnRpYWxseVxuICAgICAgLy8gc3RhcnRlZCB0cmFjZSBvbiB0aGUgc2VydmVyIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAvLyBXaHk/IFdlIHdhbnQgdG8gcHJpb3JpdGl6ZSBpbnRlci10cmFjZSBjb25zaXN0ZW5jeSBvdmVyIGludHJhLXRyYWNlIGNvbnNpc3RlbmN5LlxuICAgICAgaWYgKGlzRmlyc3RUcmFjZU9uUGFnZWxvYWQgJiYgY3VycmVudFByb3BhZ2F0aW9uQ29udGV4dC5wYXJlbnRTcGFuSWQpIHtcbiAgICAgICAgaXNGaXJzdFRyYWNlT25QYWdlbG9hZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLnNldFByb3BhZ2F0aW9uQ29udGV4dCh7XG4gICAgICAgIC4uLmN1cnJlbnRQcm9wYWdhdGlvbkNvbnRleHQsXG4gICAgICAgIGRzYzoge1xuICAgICAgICAgIC4uLmN1cnJlbnRQcm9wYWdhdGlvbkNvbnRleHQuZHNjLFxuICAgICAgICAgIHNhbXBsZV9yYXRlOiBTdHJpbmcoaW5NZW1vcnlQcmV2aW91c1RyYWNlSW5mby5zYW1wbGVSYXRlKSxcbiAgICAgICAgICBzYW1wbGVkOiBTdHJpbmcoc3BhbkNvbnRleHRTYW1wbGVkKGluTWVtb3J5UHJldmlvdXNUcmFjZUluZm8uc3BhbkNvbnRleHQpKSxcbiAgICAgICAgfSxcbiAgICAgICAgc2FtcGxlUmFuZDogaW5NZW1vcnlQcmV2aW91c1RyYWNlSW5mby5zYW1wbGVSYW5kLFxuICAgICAgfSk7XG5cbiAgICAgIG11dGFibGVTYW1wbGluZ0NvbnRleHREYXRhLnBhcmVudFNhbXBsZWQgPSBzcGFuQ29udGV4dFNhbXBsZWQoaW5NZW1vcnlQcmV2aW91c1RyYWNlSW5mby5zcGFuQ29udGV4dCk7XG4gICAgICBtdXRhYmxlU2FtcGxpbmdDb250ZXh0RGF0YS5wYXJlbnRTYW1wbGVSYXRlID0gaW5NZW1vcnlQcmV2aW91c1RyYWNlSW5mby5zYW1wbGVSYXRlO1xuXG4gICAgICBtdXRhYmxlU2FtcGxpbmdDb250ZXh0RGF0YS5zcGFuQXR0cmlidXRlcyA9IHtcbiAgICAgICAgLi4ubXV0YWJsZVNhbXBsaW5nQ29udGV4dERhdGEuc3BhbkF0dHJpYnV0ZXMsXG4gICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BSRVZJT1VTX1RSQUNFX1NBTVBMRV9SQVRFXTogaW5NZW1vcnlQcmV2aW91c1RyYWNlSW5mby5zYW1wbGVSYXRlLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYSBwcmV2aW91c190cmFjZSBzcGFuIGxpbmsgdG8gdGhlIHBhc3NlZCBzcGFuIGlmIHRoZSBwYXNzZWRcbiAqIHByZXZpb3VzVHJhY2VJbmZvIGlzIHN0aWxsIHZhbGlkLlxuICpcbiAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIHByZXZpb3VzIHRyYWNlIGluZm8gKGJhc2VkIG9uIHRoZSBjdXJyZW50IHNwYW4vdHJhY2UpIHRvXG4gKiBiZSB1c2VkIG9uIHRoZSBuZXh0IGNhbGxcbiAqL1xuZnVuY3Rpb24gYWRkUHJldmlvdXNUcmFjZVNwYW5MaW5rKFxuICBwcmV2aW91c1RyYWNlSW5mbyxcbiAgc3BhbixcbiAgb2xkUHJvcGFnYXRpb25Db250ZXh0LFxuKSB7XG4gIGNvbnN0IHNwYW5Kc29uID0gc3BhblRvSlNPTihzcGFuKTtcblxuICBmdW5jdGlvbiBnZXRTYW1wbGVSYXRlKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBOdW1iZXIob2xkUHJvcGFnYXRpb25Db250ZXh0LmRzYz8uc2FtcGxlX3JhdGUpID8/IE51bWJlcihzcGFuSnNvbi5kYXRhPy5bU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV0pXG4gICAgICApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXBkYXRlZFByZXZpb3VzVHJhY2VJbmZvID0ge1xuICAgIHNwYW5Db250ZXh0OiBzcGFuLnNwYW5Db250ZXh0KCksXG4gICAgc3RhcnRUaW1lc3RhbXA6IHNwYW5Kc29uLnN0YXJ0X3RpbWVzdGFtcCxcbiAgICBzYW1wbGVSYXRlOiBnZXRTYW1wbGVSYXRlKCksXG4gICAgc2FtcGxlUmFuZDogb2xkUHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZVJhbmQsXG4gIH07XG5cbiAgaWYgKCFwcmV2aW91c1RyYWNlSW5mbykge1xuICAgIHJldHVybiB1cGRhdGVkUHJldmlvdXNUcmFjZUluZm87XG4gIH1cblxuICBjb25zdCBwcmV2aW91c1RyYWNlU3BhbkN0eCA9IHByZXZpb3VzVHJhY2VJbmZvLnNwYW5Db250ZXh0O1xuICBpZiAocHJldmlvdXNUcmFjZVNwYW5DdHgudHJhY2VJZCA9PT0gc3Bhbkpzb24udHJhY2VfaWQpIHtcbiAgICAvLyBUaGlzIG1lYW5zLCB3ZSdyZSBzdGlsbCBpbiB0aGUgc2FtZSB0cmFjZSBzbyBsZXQncyBub3QgdXBkYXRlIHRoZSBwcmV2aW91cyB0cmFjZSBpbmZvXG4gICAgLy8gb3IgYWRkIGEgbGluayB0byB0aGUgY3VycmVudCBzcGFuLlxuICAgIC8vIE9uY2Ugd2UgbW92ZSBhd2F5IGZyb20gdGhlIGxvbmctbGl2ZWQsIHJvdXRlLWJhc2VkIHRyYWNlIG1vZGVsLCB3ZSBjYW4gcmVtb3ZlIHRoaXMgY2FzZXNcbiAgICByZXR1cm4gcHJldmlvdXNUcmFjZUluZm87XG4gIH1cblxuICAvLyBPbmx5IGFkZCB0aGUgbGluayBpZiB0aGUgc3RhcnRUaW1lU3RhbXAgb2YgdGhlIHByZXZpb3VzIHRyYWNlJ3Mgcm9vdCBzcGFuIGlzIHdpdGhpblxuICAvLyBQUkVWSU9VU19UUkFDRV9NQVhfRFVSQVRJT04gKDFoKSBvZiB0aGUgY3VycmVudCByb290IHNwYW4ncyBzdGFydFRpbWVzdGFtcFxuICAvLyBUaGlzIGlzIGRvbmUgdG9cbiAgLy8gLSBhdm9pZCBhZGRpbmcgbGlua3MgdG8gXCJzdGFsZVwiIHRyYWNlc1xuICAvLyAtIGVuYWJsZSBtb3JlIGVmZmljaWVudCBxdWVyeWluZyBmb3IgcHJldmlvdXMvbmV4dCB0cmFjZXMgaW4gU2VudHJ5XG4gIGlmIChEYXRlLm5vdygpIC8gMTAwMCAtIHByZXZpb3VzVHJhY2VJbmZvLnN0YXJ0VGltZXN0YW1wIDw9IFBSRVZJT1VTX1RSQUNFX01BWF9EVVJBVElPTikge1xuICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgZGVidWcubG9nKFxuICAgICAgICBgQWRkaW5nIHByZXZpb3VzX3RyYWNlICR7cHJldmlvdXNUcmFjZVNwYW5DdHh9IGxpbmsgdG8gc3BhbiAke3tcbiAgICAgICAgICBvcDogc3Bhbkpzb24ub3AsXG4gICAgICAgICAgLi4uc3Bhbi5zcGFuQ29udGV4dCgpLFxuICAgICAgICB9fWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHNwYW4uYWRkTGluayh7XG4gICAgICBjb250ZXh0OiBwcmV2aW91c1RyYWNlU3BhbkN0eCxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgW1NFTUFOVElDX0xJTktfQVRUUklCVVRFX0xJTktfVFlQRV06ICdwcmV2aW91c190cmFjZScsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgb25jZSBFQVAgY2FuIHN0b3JlIHNwYW4gbGlua3MuIFdlIGN1cnJlbnRseSBvbmx5IHNldCB0aGlzIGF0dHJpYnV0ZSBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIG9idGFpbiB0aGUgcHJldmlvdXMgdHJhY2UgaW5mb3JtYXRpb24gZnJvbSB0aGUgRUFQIHN0b3JlLiBMb25nLXRlcm0sIEVBUCB3aWxsIGhhbmRsZVxuICAgIC8vIHNwYW4gbGlua3MgYW5kIHRoZW4gd2Ugc2hvdWxkIHJlbW92ZSB0aGlzIGFnYWluLiBBbHNvIHRocm93aW5nIGluIGEgVE9ETyh2MTApLCB0byByZW1pbmQgdXNcbiAgICAvLyB0byBjaGVjayB0aGlzIGF0IHYxMCB0aW1lIDopXG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBQUkVWSU9VU19UUkFDRV9UTVBfU1BBTl9BVFRSSUJVVEUsXG4gICAgICBgJHtwcmV2aW91c1RyYWNlU3BhbkN0eC50cmFjZUlkfS0ke3ByZXZpb3VzVHJhY2VTcGFuQ3R4LnNwYW5JZH0tJHtcbiAgICAgICAgc3BhbkNvbnRleHRTYW1wbGVkKHByZXZpb3VzVHJhY2VTcGFuQ3R4KSA/IDEgOiAwXG4gICAgICB9YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZWRQcmV2aW91c1RyYWNlSW5mbztcbn1cblxuLyoqXG4gKiBTdG9yZXMgQHBhcmFtIHByZXZpb3VzVHJhY2VJbmZvIGluIHNlc3Npb25TdG9yYWdlLlxuICovXG5mdW5jdGlvbiBzdG9yZVByZXZpb3VzVHJhY2VJblNlc3Npb25TdG9yYWdlKHByZXZpb3VzVHJhY2VJbmZvKSB7XG4gIHRyeSB7XG4gICAgV0lORE9XLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUFJFVklPVVNfVFJBQ0VfS0VZLCBKU09OLnN0cmluZ2lmeShwcmV2aW91c1RyYWNlSW5mbykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlIHBvdGVudGlhbCBlcnJvcnMgKGUuZy4gaWYgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSlcbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy53YXJuKCdDb3VsZCBub3Qgc3RvcmUgcHJldmlvdXMgdHJhY2UgaW4gc2Vzc2lvblN0b3JhZ2UnLCBlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgcHJldmlvdXMgdHJhY2UgZnJvbSBzZXNzaW9uU3RvcmFnZSBpZiBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZXZpb3VzVHJhY2VGcm9tU2Vzc2lvblN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJldmlvdXNUcmFjZUluZm8gPSBXSU5ET1cuc2Vzc2lvblN0b3JhZ2U/LmdldEl0ZW0oUFJFVklPVVNfVFJBQ0VfS0VZKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gaW50ZW50aW9uYWxseSByaXNraW5nIEpTT04ucGFyc2UgdGhyb3dpbmcgd2hlbiBwcmV2aW91c1RyYWNlSW5mbyBpcyBudWxsIHRvIHNhdmUgYnVuZGxlIHNpemVcbiAgICByZXR1cm4gSlNPTi5wYXJzZShwcmV2aW91c1RyYWNlSW5mbyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBzZWUge0BsaW5rIGltcG9ydCgnQHNlbnRyeS9jb3JlJykuc3BhbklzU2FtcGxlZH1cbiAqL1xuZnVuY3Rpb24gc3BhbkNvbnRleHRTYW1wbGVkKGN0eCkge1xuICByZXR1cm4gY3R4LnRyYWNlRmxhZ3MgPT09IDB4MTtcbn1cblxuZXhwb3J0IHsgUFJFVklPVVNfVFJBQ0VfS0VZLCBQUkVWSU9VU19UUkFDRV9NQVhfRFVSQVRJT04sIFBSRVZJT1VTX1RSQUNFX1RNUF9TUEFOX0FUVFJJQlVURSwgYWRkUHJldmlvdXNUcmFjZVNwYW5MaW5rLCBnZXRQcmV2aW91c1RyYWNlRnJvbVNlc3Npb25TdG9yYWdlLCBsaW5rVHJhY2VzLCBzcGFuQ29udGV4dFNhbXBsZWQsIHN0b3JlUHJldmlvdXNUcmFjZUluU2Vzc2lvblN0b3JhZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmtlZFRyYWNlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+browser@9.46.0/node_modules/@sentry/browser/build/npm/esm/tracing/linkedTraces.js\n"));
- `./frontend/.next/static/chunks/main-app.js:546` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: () => (/* binding */ BaseClient),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   _getTraceInfoFromScope: () => (/* binding */ _getTraceInfoFromScope)\n/* harmony export */ });\n/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/api.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/constants.js\");\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./currentScopes.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./debug-build.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/debug-build.js\");\n/* harmony import */ var _envelope_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./envelope.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/envelope.js\");\n/* harmony import */ var _integration_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./integration.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/integration.js\");\n/* harmony import */ var _session_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./session.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/session.js\");\n/* harmony import */ var _tracing_dynamicSamplingContext_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tracing/dynamicSamplingContext.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/tracing/dynamicSamplingContext.js\");\n/* harmony import */ var _utils_clientreport_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/clientreport.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/clientreport.js\");\n/* harmony import */ var _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/debug-logger.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/debug-logger.js\");\n/* harmony import */ var _utils_dsn_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/dsn.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/dsn.js\");\n/* harmony import */ var _utils_envelope_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/envelope.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/envelope.js\");\n/* harmony import */ var _utils_eventUtils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/eventUtils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/eventUtils.js\");\n/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/is.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/is.js\");\n/* harmony import */ var _utils_merge_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/merge.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/merge.js\");\n/* harmony import */ var _utils_misc_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/misc.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/misc.js\");\n/* harmony import */ var _utils_parseSampleRate_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/parseSampleRate.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/parseSampleRate.js\");\n/* harmony import */ var _utils_prepareEvent_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/prepareEvent.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/prepareEvent.js\");\n/* harmony import */ var _utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./utils/spanUtils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/spanUtils.js\");\n/* harmony import */ var _utils_syncpromise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils/syncpromise.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/syncpromise.js\");\n/* harmony import */ var _utils_transactionEvent_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/transactionEvent.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/transactionEvent.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* eslint-disable max-lines */\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\nconst MISSING_RELEASE_FOR_SESSION_ERROR = 'Discarded session because of missing or non-string release';\n\nconst INTERNAL_ERROR_SYMBOL = Symbol.for('SentryInternalError');\nconst DO_NOT_SEND_EVENT_SYMBOL = Symbol.for('SentryDoNotSendEventError');\n\nfunction _makeInternalError(message) {\n  return {\n    message,\n    [INTERNAL_ERROR_SYMBOL]: true,\n  };\n}\n\nfunction _makeDoNotSendEventError(message) {\n  return {\n    message,\n    [DO_NOT_SEND_EVENT_SYMBOL]: true,\n  };\n}\n\nfunction _isInternalError(error) {\n  return !!error && typeof error === 'object' && INTERNAL_ERROR_SYMBOL in error;\n}\n\nfunction _isDoNotSendEventError(error) {\n  return !!error && typeof error === 'object' && DO_NOT_SEND_EVENT_SYMBOL in error;\n}\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link Client._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends Client<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass Client {\n  /** Options passed to the SDK. */\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n  /** Array of set up integrations. */\n\n  /** Number of calls being processed */\n\n  /** Holds flushable  */\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n   constructor(options) {\n    this._options = options;\n    this._integrations = {};\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n\n    if (options.dsn) {\n      this._dsn = (0,_utils_dsn_js__WEBPACK_IMPORTED_MODULE_10__.makeDsn)(options.dsn);\n    } else {\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.warn('No DSN provided, client will not send events.');\n    }\n\n    if (this._dsn) {\n      const url = (0,_api_js__WEBPACK_IMPORTED_MODULE_0__.getEnvelopeEndpointWithUrlEncodedAuth)(\n        this._dsn,\n        options.tunnel,\n        options._metadata ? options._metadata.sdk : undefined,\n      );\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    }\n  }\n\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureException(exception, hint, scope) {\n    const eventId = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_15__.uuid4)();\n\n    // ensure we haven't captured this very object before\n    if ((0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_15__.checkOrSetAlreadyCaught)(exception)) {\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    this._process(\n      this.eventFromException(exception, hintWithEventId).then(event =>\n        this._captureEvent(event, hintWithEventId, scope),\n      ),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureMessage(\n    message,\n    level,\n    hint,\n    currentScope,\n  ) {\n    const hintWithEventId = {\n      event_id: (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_15__.uuid4)(),\n      ...hint,\n    };\n\n    const eventMessage = (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_13__.isParameterizedString)(message) ? message : String(message);\n\n    const promisedEvent = (0,_utils_is_js__WEBPACK_IMPORTED_MODULE_13__.isPrimitive)(message)\n      ? this.eventFromMessage(eventMessage, level, hintWithEventId)\n      : this.eventFromException(message, hintWithEventId);\n\n    this._process(promisedEvent.then(event => this._captureEvent(event, hintWithEventId, currentScope)));\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.\n   */\n   captureEvent(event, hint, currentScope) {\n    const eventId = (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_15__.uuid4)();\n\n    // ensure we haven't captured this very object before\n    if (hint?.originalException && (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_15__.checkOrSetAlreadyCaught)(hint.originalException)) {\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;\n    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;\n\n    this._process(\n      this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a session.\n   */\n   captureSession(session) {\n    this.sendSession(session);\n    // After sending, we set init false to indicate it's not the first occurrence\n    (0,_session_js__WEBPACK_IMPORTED_MODULE_6__.updateSession)(session, { init: false });\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   * @param scope An optional scope containing event metadata.\n   * @returns A string representing the id of the check in.\n   */\n\n  /**\n   * Get the current Dsn.\n   */\n   getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * Get the current options.\n   */\n   getOptions() {\n    return this._options;\n  }\n\n  /**\n   * Get the SDK metadata.\n   * @see SdkMetadata\n   */\n   getSdkMetadata() {\n    return this._options._metadata;\n  }\n\n  /**\n   * Returns the transport that is used by the client.\n   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n   */\n   getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n   *   cause the client to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n   flush(timeout) {\n    const transport = this._transport;\n    if (transport) {\n      this.emit('flush');\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return (0,_utils_syncpromise_js__WEBPACK_IMPORTED_MODULE_19__.resolvedSyncPromise)(true);\n    }\n  }\n\n  /**\n   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n   *\n   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n   *   the client to wait until all events are sent before disabling itself.\n   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n   * it doesn't.\n   */\n   close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      this.emit('close');\n      return result;\n    });\n  }\n\n  /**\n   * Get all installed event processors.\n   */\n   getEventProcessors() {\n    return this._eventProcessors;\n  }\n\n  /**\n   * Adds an event processor that applies to any event processed by this client.\n   */\n   addEventProcessor(eventProcessor) {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * Initialize this client.\n   * Call this after the client was set on a scope.\n   */\n   init() {\n    if (\n      this._isEnabled() ||\n      // Force integrations to be setup even if no DSN was set when we have\n      // Spotlight enabled. This is particularly important for browser as we\n      // don't support the `spotlight` option there and rely on the users\n      // adding the `spotlightBrowserIntegration()` to their integrations which\n      // wouldn't get initialized with the check below when there's no DSN set.\n      this._options.integrations.some(({ name }) => name.startsWith('Spotlight'))\n    ) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n   getIntegrationByName(integrationName) {\n    return this._integrations[integrationName] ;\n  }\n\n  /**\n   * Add an integration to the client.\n   * This can be used to e.g. lazy load integrations.\n   * In most cases, this should not be necessary,\n   * and you're better off just passing the integrations via `integrations: []` at initialization time.\n   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.\n   */\n   addIntegration(integration) {\n    const isAlreadyInstalled = this._integrations[integration.name];\n\n    // This hook takes care of only installing if not already installed\n    (0,_integration_js__WEBPACK_IMPORTED_MODULE_5__.setupIntegration)(this, integration, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      (0,_integration_js__WEBPACK_IMPORTED_MODULE_5__.afterSetupIntegrations)(this, [integration]);\n    }\n  }\n\n  /**\n   * Send a fully prepared event to Sentry.\n   */\n   sendEvent(event, hint = {}) {\n    this.emit('beforeSendEvent', event, hint);\n\n    let env = (0,_envelope_js__WEBPACK_IMPORTED_MODULE_4__.createEventEnvelope)(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n    for (const attachment of hint.attachments || []) {\n      env = (0,_utils_envelope_js__WEBPACK_IMPORTED_MODULE_11__.addItemToEnvelope)(env, (0,_utils_envelope_js__WEBPACK_IMPORTED_MODULE_11__.createAttachmentEnvelopeItem)(attachment));\n    }\n\n    const promise = this.sendEnvelope(env);\n    if (promise) {\n      promise.then(sendResponse => this.emit('afterSendEvent', event, sendResponse), null);\n    }\n  }\n\n  /**\n   * Send a session or session aggregrates to Sentry.\n   */\n   sendSession(session) {\n    // Backfill release and environment on session\n    const { release: clientReleaseOption, environment: clientEnvironmentOption = _constants_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ENVIRONMENT } = this._options;\n    if ('aggregates' in session) {\n      const sessionAttrs = session.attrs || {};\n      if (!sessionAttrs.release && !clientReleaseOption) {\n        _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;\n      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;\n      session.attrs = sessionAttrs;\n    } else {\n      if (!session.release && !clientReleaseOption) {\n        _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      session.release = session.release || clientReleaseOption;\n      session.environment = session.environment || clientEnvironmentOption;\n    }\n\n    this.emit('beforeSendSession', session);\n\n    const env = (0,_envelope_js__WEBPACK_IMPORTED_MODULE_4__.createSessionEnvelope)(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(env);\n  }\n\n  /**\n   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).\n   */\n   recordDroppedEvent(reason, category, count = 1) {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log(`Recording outcome: \"${key}\"${count > 1 ? ` (${count} times)` : ''}`);\n      this._outcomes[key] = (this._outcomes[key] || 0) + count;\n    }\n  }\n\n  /* eslint-disable @typescript-eslint/unified-signatures */\n  /**\n   * Register a callback for whenever a span is started.\n   * Receives the span as argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n\n  /**\n   * Register a hook on this client.\n   */\n   on(hook, callback) {\n    const hooks = (this._hooks[hook] = this._hooks[hook] || []);\n\n    // @ts-expect-error We assume the types are correct\n    hooks.push(callback);\n\n    // This function returns a callback execution handler that, when invoked,\n    // deregisters a callback. This is crucial for managing instances where callbacks\n    // need to be unregistered to prevent self-referencing in callback closures,\n    // ensuring proper garbage collection.\n    return () => {\n      // @ts-expect-error We assume the types are correct\n      const cbIndex = hooks.indexOf(callback);\n      if (cbIndex > -1) {\n        hooks.splice(cbIndex, 1);\n      }\n    };\n  }\n\n  /** Fire a hook whenever a span starts. */\n\n  /**\n   * Emit a hook that was previously registered via `on()`.\n   */\n   emit(hook, ...rest) {\n    const callbacks = this._hooks[hook];\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...rest));\n    }\n  }\n\n  /**\n   * Send an envelope to Sentry.\n   */\n   sendEnvelope(envelope) {\n    this.emit('beforeEnvelope', envelope);\n\n    if (this._isEnabled() && this._transport) {\n      return this._transport.send(envelope).then(null, reason => {\n        _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.error('Error while sending envelope:', reason);\n        return reason;\n      });\n    }\n\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.error('Transport disabled');\n\n    return (0,_utils_syncpromise_js__WEBPACK_IMPORTED_MODULE_19__.resolvedSyncPromise)({});\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n   _setupIntegrations() {\n    const { integrations } = this._options;\n    this._integrations = (0,_integration_js__WEBPACK_IMPORTED_MODULE_5__.setupIntegrations)(this, integrations);\n    (0,_integration_js__WEBPACK_IMPORTED_MODULE_5__.afterSetupIntegrations)(this, integrations);\n  }\n\n  /** Updates existing session based on the provided event */\n   _updateSessionFromEvent(session, event) {\n    let crashed = event.level === 'fatal';\n    let errored = false;\n    const exceptions = event.exception?.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism?.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      (0,_session_js__WEBPACK_IMPORTED_MODULE_6__.updateSession)(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n   _isClientDoneProcessing(timeout) {\n    return new _utils_syncpromise_js__WEBPACK_IMPORTED_MODULE_19__.SyncPromise(resolve => {\n      let ticked = 0;\n      const tick = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n   _isEnabled() {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n   _prepareEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations?.length) {\n      hint.integrations = integrations;\n    }\n\n    this.emit('preprocessEvent', event, hint);\n\n    if (!event.type) {\n      isolationScope.setLastEventId(event.event_id || hint.event_id);\n    }\n\n    return (0,_utils_prepareEvent_js__WEBPACK_IMPORTED_MODULE_17__.prepareEvent)(options, event, hint, currentScope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n\n      this.emit('postprocessEvent', evt, hint);\n\n      evt.contexts = {\n        trace: (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_2__.getTraceContextFromScope)(currentScope),\n        ...evt.contexts,\n      };\n\n      const dynamicSamplingContext = (0,_tracing_dynamicSamplingContext_js__WEBPACK_IMPORTED_MODULE_7__.getDynamicSamplingContextFromScope)(this, currentScope);\n\n      evt.sdkProcessingMetadata = {\n        dynamicSamplingContext,\n        ...evt.sdkProcessingMetadata,\n      };\n\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n   _captureEvent(\n    event,\n    hint = {},\n    currentScope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_2__.getCurrentScope)(),\n    isolationScope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_2__.getIsolationScope)(),\n  ) {\n    if (_debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && isErrorEvent(event)) {\n      _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log(`Captured error event \\`${(0,_utils_eventUtils_js__WEBPACK_IMPORTED_MODULE_12__.getPossibleEventMessages)(event)[0] || '<unknown>'}\\``);\n    }\n\n    return this._processEvent(event, hint, currentScope, isolationScope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (_debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD) {\n          if (_isDoNotSendEventError(reason)) {\n            _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log(reason.message);\n          } else if (_isInternalError(reason)) {\n            _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.warn(reason.message);\n          } else {\n            _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.warn(reason);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n   _processEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    const parsedSampleRate = typeof sampleRate === 'undefined' ? undefined : (0,_utils_parseSampleRate_js__WEBPACK_IMPORTED_MODULE_16__.parseSampleRate)(sampleRate);\n    if (isError && typeof parsedSampleRate === 'number' && Math.random() > parsedSampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return (0,_utils_syncpromise_js__WEBPACK_IMPORTED_MODULE_19__.rejectedSyncPromise)(\n        _makeDoNotSendEventError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    const dataCategory = (eventType === 'replay_event' ? 'replay' : eventType) ;\n\n    return this._prepareEvent(event, hint, currentScope, isolationScope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory);\n          throw _makeDoNotSendEventError('An event processor returned `null`, will not send event.');\n        }\n\n        const isInternalException = hint.data && (hint.data ).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(this, options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory);\n          if (isTransaction) {\n            const spans = event.spans || [];\n            // the transaction itself counts as one span, plus all the child spans that are added\n            const spanCount = 1 + spans.length;\n            this.recordDroppedEvent('before_send', 'span', spanCount);\n          }\n          throw _makeDoNotSendEventError(`${beforeSendLabel} returned \\`null\\`, will not send event.`);\n        }\n\n        const session = currentScope.getSession() || isolationScope.getSession();\n        if (isError && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        if (isTransaction) {\n          const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;\n          const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;\n\n          const droppedSpanCount = spanCountBefore - spanCountAfter;\n          if (droppedSpanCount > 0) {\n            this.recordDroppedEvent('before_send', 'span', droppedSpanCount);\n          }\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason,\n        });\n        throw _makeInternalError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n   _process(promise) {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n   _clearOutcomes() {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.entries(outcomes).map(([key, quantity]) => {\n      const [reason, category] = key.split(':') ;\n      return {\n        reason,\n        category,\n        quantity,\n      };\n    });\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n   _flushOutcomes() {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log('Flushing outcomes...');\n\n    const outcomes = this._clearOutcomes();\n\n    if (outcomes.length === 0) {\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log('No outcomes to send');\n      return;\n    }\n\n    // This is really the only place where we want to check for a DSN and only send outcomes then\n    if (!this._dsn) {\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log('No dsn provided, will not send outcomes');\n      return;\n    }\n\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_9__.debug.log('Sending outcomes:', outcomes);\n\n    const envelope = (0,_utils_clientreport_js__WEBPACK_IMPORTED_MODULE_8__.createClientReportEnvelope)(outcomes, this._options.tunnel && (0,_utils_dsn_js__WEBPACK_IMPORTED_MODULE_10__.dsnToString)(this._dsn));\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n  }\n\n  /**\n   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n   */\n\n}\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\n\n/**\n * @deprecated Use `Client` instead. This alias may be removed in a future major version.\n */\n// TODO(v10): Remove\nconst BaseClient = Client;\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult,\n  beforeSendLabel,\n) {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_13__.isThenable)(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_13__.isPlainObject)(event) && event !== null) {\n          throw _makeInternalError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_13__.isPlainObject)(beforeSendResult) && beforeSendResult !== null) {\n    throw _makeInternalError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  client,\n  options,\n  event,\n  hint,\n) {\n  const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;\n  let processedEvent = event;\n\n  if (isErrorEvent(processedEvent) && beforeSend) {\n    return beforeSend(processedEvent, hint);\n  }\n\n  if (isTransactionEvent(processedEvent)) {\n    if (beforeSendSpan) {\n      // process root span\n      const processedRootSpanJson = beforeSendSpan((0,_utils_transactionEvent_js__WEBPACK_IMPORTED_MODULE_20__.convertTransactionEventToSpanJson)(processedEvent));\n      if (!processedRootSpanJson) {\n        (0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_18__.showSpanDropWarning)();\n      } else {\n        // update event with processed root span values\n        processedEvent = (0,_utils_merge_js__WEBPACK_IMPORTED_MODULE_14__.merge)(event, (0,_utils_transactionEvent_js__WEBPACK_IMPORTED_MODULE_20__.convertSpanJsonToTransactionEvent)(processedRootSpanJson));\n      }\n\n      // process child spans\n      if (processedEvent.spans) {\n        const processedSpans = [];\n        for (const span of processedEvent.spans) {\n          const processedSpan = beforeSendSpan(span);\n          if (!processedSpan) {\n            (0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_18__.showSpanDropWarning)();\n            processedSpans.push(span);\n          } else {\n            processedSpans.push(processedSpan);\n          }\n        }\n        processedEvent.spans = processedSpans;\n      }\n    }\n\n    if (beforeSendTransaction) {\n      if (processedEvent.spans) {\n        // We store the # of spans before processing in SDK metadata,\n        // so we can compare it afterwards to determine how many spans were dropped\n        const spanCountBefore = processedEvent.spans.length;\n        processedEvent.sdkProcessingMetadata = {\n          ...event.sdkProcessingMetadata,\n          spanCountBeforeProcessing: spanCountBefore,\n        };\n      }\n      return beforeSendTransaction(processedEvent , hint);\n    }\n  }\n\n  return processedEvent;\n}\n\nfunction isErrorEvent(event) {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event) {\n  return event.type === 'transaction';\n}\n\n/** Extract trace information from scope */\nfunction _getTraceInfoFromScope(\n  client,\n  scope,\n) {\n  if (!scope) {\n    return [undefined, undefined];\n  }\n\n  return (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_2__.withScope)(scope, () => {\n    const span = (0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_18__.getActiveSpan)();\n    const traceContext = span ? (0,_utils_spanUtils_js__WEBPACK_IMPORTED_MODULE_18__.spanToTraceContext)(span) : (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_2__.getTraceContextFromScope)(scope);\n    const dynamicSamplingContext = span\n      ? (0,_tracing_dynamicSamplingContext_js__WEBPACK_IMPORTED_MODULE_7__.getDynamicSamplingContextFromSpan)(span)\n      : (0,_tracing_dynamicSamplingContext_js__WEBPACK_IMPORTED_MODULE_7__.getDynamicSamplingContextFromScope)(client, scope);\n    return [dynamicSamplingContext, traceContext];\n  });\n}\n\n\n//# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDWjtBQUN3RDtBQUM5RDtBQUM0QjtBQUNvQjtBQUNsRDtBQUMrRTtBQUN2RDtBQUNyQjtBQUNNO0FBQ2dDO0FBQ3JCO0FBQzZCO0FBQ3JEO0FBQ3dCO0FBQ0o7QUFDTjtBQUN1QztBQUNDO0FBQ29COztBQUVuSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekIsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMEJBQTBCO0FBQzlCO0FBQ0EsSUFBSSwyQkFBMkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix1REFBTztBQUN6QixNQUFNO0FBQ04sTUFBTSx3REFBVyxJQUFJLHlEQUFLO0FBQzFCOztBQUVBO0FBQ0Esa0JBQWtCLDhFQUFxQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUs7O0FBRXpCO0FBQ0EsUUFBUSx3RUFBdUI7QUFDL0IsTUFBTSx3REFBVyxJQUFJLHlEQUFLO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBSztBQUNyQjtBQUNBOztBQUVBLHlCQUF5QixvRUFBcUI7O0FBRTlDLDBCQUEwQiwwREFBVztBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFLOztBQUV6QjtBQUNBLG1DQUFtQyx3RUFBdUI7QUFDMUQsTUFBTSx3REFBVyxJQUFJLHlEQUFLO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQWEsWUFBWSxhQUFhO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLGFBQWEsMkVBQW1CO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsbUJBQW1CO0FBQzVGO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGlFQUFnQjtBQUNwQjtBQUNBO0FBQ0EsTUFBTSx1RUFBc0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUEsY0FBYyxpRUFBbUI7O0FBRWpDO0FBQ0EsWUFBWSxzRUFBaUIsTUFBTSxpRkFBNEI7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRUFBcUUsOERBQW1CLEdBQUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3REFBVyxJQUFJLHlEQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxRQUFRLHdEQUFXLElBQUkseURBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsbUVBQXFCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU8sR0FBRyxTQUFTO0FBQ3hDLE1BQU0sd0RBQVcsSUFBSSx5REFBSyw0QkFBNEIsSUFBSSxHQUFHLGlCQUFpQixPQUFPLGFBQWE7QUFDbEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsd0RBQVcsSUFBSSx5REFBSztBQUM1QjtBQUNBLE9BQU87QUFDUDs7QUFFQSxJQUFJLHdEQUFXLElBQUkseURBQUs7O0FBRXhCLFdBQVcsMkVBQW1CLEdBQUc7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQix5QkFBeUIsa0VBQWlCO0FBQzFDLElBQUksdUVBQXNCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDBEQUFhO0FBQ25CLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFXO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxxRUFBWTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLDJFQUF3QjtBQUN2QztBQUNBOztBQUVBLHFDQUFxQyxzR0FBa0M7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUJBQW1CLGtFQUFlO0FBQ2xDLHFCQUFxQixvRUFBaUI7QUFDdEM7QUFDQSxRQUFRLHdEQUFXO0FBQ25CLE1BQU0seURBQUssK0JBQStCLCtFQUF3QiwwQkFBMEI7QUFDNUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsWUFBWSx3REFBVztBQUN2QjtBQUNBLFlBQVkseURBQUs7QUFDakIsWUFBWTtBQUNaLFlBQVkseURBQUs7QUFDakIsWUFBWTtBQUNaLFlBQVkseURBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTs7QUFFekI7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwyRUFBZTtBQUM1RjtBQUNBO0FBQ0EsYUFBYSwyRUFBbUI7QUFDaEM7QUFDQSw4RkFBOEYsV0FBVztBQUN6RztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0lBQXdJLE9BQU87QUFDL0k7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3REFBVyxJQUFJLHlEQUFLOztBQUV4Qjs7QUFFQTtBQUNBLE1BQU0sd0RBQVcsSUFBSSx5REFBSztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHdEQUFXLElBQUkseURBQUs7QUFDMUI7QUFDQTs7QUFFQSxJQUFJLHdEQUFXLElBQUkseURBQUs7O0FBRXhCLHFCQUFxQixrRkFBMEIsbUNBQW1DLDJEQUFXOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hELE1BQU0seURBQVU7QUFDaEI7QUFDQTtBQUNBLGFBQWEsNERBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0NBQW9DLGlCQUFpQixnQkFBZ0IsRUFBRTtBQUN2RSxPQUFPO0FBQ1A7QUFDQSxJQUFJLFVBQVUsNERBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBb0Q7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw4RkFBaUM7QUFDcEY7QUFDQSxRQUFRLHlFQUFtQjtBQUMzQixRQUFRO0FBQ1I7QUFDQSx5QkFBeUIsdURBQUssUUFBUSw4RkFBaUM7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5RUFBbUI7QUFDL0I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsNERBQVM7QUFDbEIsaUJBQWlCLG1FQUFhO0FBQzlCLGdDQUFnQyx3RUFBa0IsU0FBUywyRUFBd0I7QUFDbkY7QUFDQSxRQUFRLHFHQUFpQztBQUN6QyxRQUFRLHNHQUFrQztBQUMxQztBQUNBLEdBQUc7QUFDSDs7QUFFc0Q7QUFDdEQiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStjb3JlQDkuNDYuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RW52ZWxvcGVFbmRwb2ludFdpdGhVcmxFbmNvZGVkQXV0aCB9IGZyb20gJy4vYXBpLmpzJztcbmltcG9ydCB7IERFRkFVTFRfRU5WSVJPTk1FTlQgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRUcmFjZUNvbnRleHRGcm9tU2NvcGUsIGdldEN1cnJlbnRTY29wZSwgZ2V0SXNvbGF0aW9uU2NvcGUsIHdpdGhTY29wZSB9IGZyb20gJy4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuaW1wb3J0IHsgY3JlYXRlRXZlbnRFbnZlbG9wZSwgY3JlYXRlU2Vzc2lvbkVudmVsb3BlIH0gZnJvbSAnLi9lbnZlbG9wZS5qcyc7XG5pbXBvcnQgeyBzZXR1cEludGVncmF0aW9uLCBhZnRlclNldHVwSW50ZWdyYXRpb25zLCBzZXR1cEludGVncmF0aW9ucyB9IGZyb20gJy4vaW50ZWdyYXRpb24uanMnO1xuaW1wb3J0IHsgdXBkYXRlU2Vzc2lvbiB9IGZyb20gJy4vc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNjb3BlLCBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4gfSBmcm9tICcuL3RyYWNpbmcvZHluYW1pY1NhbXBsaW5nQ29udGV4dC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnRSZXBvcnRFbnZlbG9wZSB9IGZyb20gJy4vdXRpbHMvY2xpZW50cmVwb3J0LmpzJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi91dGlscy9kZWJ1Zy1sb2dnZXIuanMnO1xuaW1wb3J0IHsgbWFrZURzbiwgZHNuVG9TdHJpbmcgfSBmcm9tICcuL3V0aWxzL2Rzbi5qcyc7XG5pbXBvcnQgeyBhZGRJdGVtVG9FbnZlbG9wZSwgY3JlYXRlQXR0YWNobWVudEVudmVsb3BlSXRlbSB9IGZyb20gJy4vdXRpbHMvZW52ZWxvcGUuanMnO1xuaW1wb3J0IHsgZ2V0UG9zc2libGVFdmVudE1lc3NhZ2VzIH0gZnJvbSAnLi91dGlscy9ldmVudFV0aWxzLmpzJztcbmltcG9ydCB7IGlzUHJpbWl0aXZlLCBpc1BhcmFtZXRlcml6ZWRTdHJpbmcsIGlzVGhlbmFibGUsIGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL3V0aWxzL2lzLmpzJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnLi91dGlscy9tZXJnZS5qcyc7XG5pbXBvcnQgeyB1dWlkNCwgY2hlY2tPclNldEFscmVhZHlDYXVnaHQgfSBmcm9tICcuL3V0aWxzL21pc2MuanMnO1xuaW1wb3J0IHsgcGFyc2VTYW1wbGVSYXRlIH0gZnJvbSAnLi91dGlscy9wYXJzZVNhbXBsZVJhdGUuanMnO1xuaW1wb3J0IHsgcHJlcGFyZUV2ZW50IH0gZnJvbSAnLi91dGlscy9wcmVwYXJlRXZlbnQuanMnO1xuaW1wb3J0IHsgc2hvd1NwYW5Ecm9wV2FybmluZywgZ2V0QWN0aXZlU3Bhbiwgc3BhblRvVHJhY2VDb250ZXh0IH0gZnJvbSAnLi91dGlscy9zcGFuVXRpbHMuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZWRTeW5jUHJvbWlzZSwgU3luY1Byb21pc2UsIHJlamVjdGVkU3luY1Byb21pc2UgfSBmcm9tICcuL3V0aWxzL3N5bmNwcm9taXNlLmpzJztcbmltcG9ydCB7IGNvbnZlcnRUcmFuc2FjdGlvbkV2ZW50VG9TcGFuSnNvbiwgY29udmVydFNwYW5Kc29uVG9UcmFuc2FjdGlvbkV2ZW50IH0gZnJvbSAnLi91dGlscy90cmFuc2FjdGlvbkV2ZW50LmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxpbmVzICovXG5cbmNvbnN0IEFMUkVBRFlfU0VFTl9FUlJPUiA9IFwiTm90IGNhcHR1cmluZyBleGNlcHRpb24gYmVjYXVzZSBpdCdzIGFscmVhZHkgYmVlbiBjYXB0dXJlZC5cIjtcbmNvbnN0IE1JU1NJTkdfUkVMRUFTRV9GT1JfU0VTU0lPTl9FUlJPUiA9ICdEaXNjYXJkZWQgc2Vzc2lvbiBiZWNhdXNlIG9mIG1pc3Npbmcgb3Igbm9uLXN0cmluZyByZWxlYXNlJztcblxuY29uc3QgSU5URVJOQUxfRVJST1JfU1lNQk9MID0gU3ltYm9sLmZvcignU2VudHJ5SW50ZXJuYWxFcnJvcicpO1xuY29uc3QgRE9fTk9UX1NFTkRfRVZFTlRfU1lNQk9MID0gU3ltYm9sLmZvcignU2VudHJ5RG9Ob3RTZW5kRXZlbnRFcnJvcicpO1xuXG5mdW5jdGlvbiBfbWFrZUludGVybmFsRXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2UsXG4gICAgW0lOVEVSTkFMX0VSUk9SX1NZTUJPTF06IHRydWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIF9tYWtlRG9Ob3RTZW5kRXZlbnRFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZSxcbiAgICBbRE9fTk9UX1NFTkRfRVZFTlRfU1lNQk9MXTogdHJ1ZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2lzSW50ZXJuYWxFcnJvcihlcnJvcikge1xuICByZXR1cm4gISFlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIElOVEVSTkFMX0VSUk9SX1NZTUJPTCBpbiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX2lzRG9Ob3RTZW5kRXZlbnRFcnJvcihlcnJvcikge1xuICByZXR1cm4gISFlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIERPX05PVF9TRU5EX0VWRU5UX1NZTUJPTCBpbiBlcnJvcjtcbn1cblxuLyoqXG4gKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciBhbGwgSmF2YVNjcmlwdCBTREsgY2xpZW50cy5cbiAqXG4gKiBDYWxsIHRoZSBjb25zdHJ1Y3RvciB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG9wdGlvbnNcbiAqIHNwZWNpZmljIHRvIHRoZSBjbGllbnQgc3ViY2xhc3MuIFRvIGFjY2VzcyB0aGVzZSBvcHRpb25zIGxhdGVyLCB1c2VcbiAqIHtAbGluayBDbGllbnQuZ2V0T3B0aW9uc30uXG4gKlxuICogSWYgYSBEc24gaXMgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zLCBpdCB3aWxsIGJlIHBhcnNlZCBhbmQgc3RvcmVkLiBVc2VcbiAqIHtAbGluayBDbGllbnQuZ2V0RHNufSB0byByZXRyaWV2ZSB0aGUgRHNuIGF0IGFueSBtb21lbnQuIEluIGNhc2UgdGhlIERzbiBpc1xuICogaW52YWxpZCwgdGhlIGNvbnN0cnVjdG9yIHdpbGwgdGhyb3cgYSB7QGxpbmsgU2VudHJ5RXhjZXB0aW9ufS4gTm90ZSB0aGF0XG4gKiB3aXRob3V0IGEgdmFsaWQgRHNuLCB0aGUgU0RLIHdpbGwgbm90IHNlbmQgYW55IGV2ZW50cyB0byBTZW50cnkuXG4gKlxuICogQmVmb3JlIHNlbmRpbmcgYW4gZXZlbnQsIGl0IGlzIHBhc3NlZCB0aHJvdWdoXG4gKiB7QGxpbmsgQ2xpZW50Ll9wcmVwYXJlRXZlbnR9IHRvIGFkZCBTREsgaW5mb3JtYXRpb24gYW5kIHNjb3BlIGRhdGFcbiAqIChicmVhZGNydW1icyBhbmQgY29udGV4dCkuIFRvIGFkZCBtb3JlIGN1c3RvbSBpbmZvcm1hdGlvbiwgb3ZlcnJpZGUgdGhpc1xuICogbWV0aG9kIGFuZCBleHRlbmQgdGhlIHJlc3VsdGluZyBwcmVwYXJlZCBldmVudC5cbiAqXG4gKiBUbyBpc3N1ZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgZXZlbnRzIChlLmcuIHZpYSBpbnN0cnVtZW50YXRpb24pLCB1c2VcbiAqIHtAbGluayBDbGllbnQuY2FwdHVyZUV2ZW50fS4gSXQgd2lsbCBwcmVwYXJlIHRoZSBldmVudCBhbmQgcGFzcyBpdCB0aHJvdWdoXG4gKiB0aGUgY2FsbGJhY2sgbGlmZWN5Y2xlLiBUbyBpc3N1ZSBhdXRvLWJyZWFkY3J1bWJzLCB1c2VcbiAqIHtAbGluayBDbGllbnQuYWRkQnJlYWRjcnVtYn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNsYXNzIE5vZGVDbGllbnQgZXh0ZW5kcyBDbGllbnQ8Tm9kZU9wdGlvbnM+IHtcbiAqICAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE5vZGVPcHRpb25zKSB7XG4gKiAgICAgc3VwZXIob3B0aW9ucyk7XG4gKiAgIH1cbiAqXG4gKiAgIC8vIC4uLlxuICogfVxuICovXG5jbGFzcyBDbGllbnQge1xuICAvKiogT3B0aW9ucyBwYXNzZWQgdG8gdGhlIFNESy4gKi9cblxuICAvKiogVGhlIGNsaWVudCBEc24sIGlmIHNwZWNpZmllZCBpbiBvcHRpb25zLiBXaXRob3V0IHRoaXMgRHNuLCB0aGUgU0RLIHdpbGwgYmUgZGlzYWJsZWQuICovXG5cbiAgLyoqIEFycmF5IG9mIHNldCB1cCBpbnRlZ3JhdGlvbnMuICovXG5cbiAgLyoqIE51bWJlciBvZiBjYWxscyBiZWluZyBwcm9jZXNzZWQgKi9cblxuICAvKiogSG9sZHMgZmx1c2hhYmxlICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoaXMgY2xpZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgY2xpZW50LlxuICAgKi9cbiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9pbnRlZ3JhdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9udW1Qcm9jZXNzaW5nID0gMDtcbiAgICB0aGlzLl9vdXRjb21lcyA9IHt9O1xuICAgIHRoaXMuX2hvb2tzID0ge307XG4gICAgdGhpcy5fZXZlbnRQcm9jZXNzb3JzID0gW107XG5cbiAgICBpZiAob3B0aW9ucy5kc24pIHtcbiAgICAgIHRoaXMuX2RzbiA9IG1ha2VEc24ob3B0aW9ucy5kc24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy53YXJuKCdObyBEU04gcHJvdmlkZWQsIGNsaWVudCB3aWxsIG5vdCBzZW5kIGV2ZW50cy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZHNuKSB7XG4gICAgICBjb25zdCB1cmwgPSBnZXRFbnZlbG9wZUVuZHBvaW50V2l0aFVybEVuY29kZWRBdXRoKFxuICAgICAgICB0aGlzLl9kc24sXG4gICAgICAgIG9wdGlvbnMudHVubmVsLFxuICAgICAgICBvcHRpb25zLl9tZXRhZGF0YSA/IG9wdGlvbnMuX21ldGFkYXRhLnNkayA6IHVuZGVmaW5lZCxcbiAgICAgICk7XG4gICAgICB0aGlzLl90cmFuc3BvcnQgPSBvcHRpb25zLnRyYW5zcG9ydCh7XG4gICAgICAgIHR1bm5lbDogdGhpcy5fb3B0aW9ucy50dW5uZWwsXG4gICAgICAgIHJlY29yZERyb3BwZWRFdmVudDogdGhpcy5yZWNvcmREcm9wcGVkRXZlbnQuYmluZCh0aGlzKSxcbiAgICAgICAgLi4ub3B0aW9ucy50cmFuc3BvcnRPcHRpb25zLFxuICAgICAgICB1cmwsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZXMgYW4gZXhjZXB0aW9uIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gICAqXG4gICAqIFVubGlrZSBgY2FwdHVyZUV4Y2VwdGlvbmAgZXhwb3J0ZWQgZnJvbSBldmVyeSBTREssIHRoaXMgbWV0aG9kIHJlcXVpcmVzIHRoYXQgeW91IHBhc3MgaXQgdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAqL1xuICAgY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24sIGhpbnQsIHNjb3BlKSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IHV1aWQ0KCk7XG5cbiAgICAvLyBlbnN1cmUgd2UgaGF2ZW4ndCBjYXB0dXJlZCB0aGlzIHZlcnkgb2JqZWN0IGJlZm9yZVxuICAgIGlmIChjaGVja09yU2V0QWxyZWFkeUNhdWdodChleGNlcHRpb24pKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5sb2coQUxSRUFEWV9TRUVOX0VSUk9SKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIGNvbnN0IGhpbnRXaXRoRXZlbnRJZCA9IHtcbiAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgICAgLi4uaGludCxcbiAgICB9O1xuXG4gICAgdGhpcy5fcHJvY2VzcyhcbiAgICAgIHRoaXMuZXZlbnRGcm9tRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludFdpdGhFdmVudElkKS50aGVuKGV2ZW50ID0+XG4gICAgICAgIHRoaXMuX2NhcHR1cmVFdmVudChldmVudCwgaGludFdpdGhFdmVudElkLCBzY29wZSksXG4gICAgICApLFxuICAgICk7XG5cbiAgICByZXR1cm4gaGludFdpdGhFdmVudElkLmV2ZW50X2lkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmVzIGEgbWVzc2FnZSBldmVudCBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICAgKlxuICAgKiBVbmxpa2UgYGNhcHR1cmVNZXNzYWdlYCBleHBvcnRlZCBmcm9tIGV2ZXJ5IFNESywgdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCB5b3UgcGFzcyBpdCB0aGUgY3VycmVudCBzY29wZS5cbiAgICovXG4gICBjYXB0dXJlTWVzc2FnZShcbiAgICBtZXNzYWdlLFxuICAgIGxldmVsLFxuICAgIGhpbnQsXG4gICAgY3VycmVudFNjb3BlLFxuICApIHtcbiAgICBjb25zdCBoaW50V2l0aEV2ZW50SWQgPSB7XG4gICAgICBldmVudF9pZDogdXVpZDQoKSxcbiAgICAgIC4uLmhpbnQsXG4gICAgfTtcblxuICAgIGNvbnN0IGV2ZW50TWVzc2FnZSA9IGlzUGFyYW1ldGVyaXplZFN0cmluZyhtZXNzYWdlKSA/IG1lc3NhZ2UgOiBTdHJpbmcobWVzc2FnZSk7XG5cbiAgICBjb25zdCBwcm9taXNlZEV2ZW50ID0gaXNQcmltaXRpdmUobWVzc2FnZSlcbiAgICAgID8gdGhpcy5ldmVudEZyb21NZXNzYWdlKGV2ZW50TWVzc2FnZSwgbGV2ZWwsIGhpbnRXaXRoRXZlbnRJZClcbiAgICAgIDogdGhpcy5ldmVudEZyb21FeGNlcHRpb24obWVzc2FnZSwgaGludFdpdGhFdmVudElkKTtcblxuICAgIHRoaXMuX3Byb2Nlc3MocHJvbWlzZWRFdmVudC50aGVuKGV2ZW50ID0+IHRoaXMuX2NhcHR1cmVFdmVudChldmVudCwgaGludFdpdGhFdmVudElkLCBjdXJyZW50U2NvcGUpKSk7XG5cbiAgICByZXR1cm4gaGludFdpdGhFdmVudElkLmV2ZW50X2lkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmVzIGEgbWFudWFsbHkgY3JlYXRlZCBldmVudCBhbmQgc2VuZHMgaXQgdG8gU2VudHJ5LlxuICAgKlxuICAgKiBVbmxpa2UgYGNhcHR1cmVFdmVudGAgZXhwb3J0ZWQgZnJvbSBldmVyeSBTREssIHRoaXMgbWV0aG9kIHJlcXVpcmVzIHRoYXQgeW91IHBhc3MgaXQgdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAqL1xuICAgY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUpIHtcbiAgICBjb25zdCBldmVudElkID0gdXVpZDQoKTtcblxuICAgIC8vIGVuc3VyZSB3ZSBoYXZlbid0IGNhcHR1cmVkIHRoaXMgdmVyeSBvYmplY3QgYmVmb3JlXG4gICAgaWYgKGhpbnQ/Lm9yaWdpbmFsRXhjZXB0aW9uICYmIGNoZWNrT3JTZXRBbHJlYWR5Q2F1Z2h0KGhpbnQub3JpZ2luYWxFeGNlcHRpb24pKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5sb2coQUxSRUFEWV9TRUVOX0VSUk9SKTtcbiAgICAgIHJldHVybiBldmVudElkO1xuICAgIH1cblxuICAgIGNvbnN0IGhpbnRXaXRoRXZlbnRJZCA9IHtcbiAgICAgIGV2ZW50X2lkOiBldmVudElkLFxuICAgICAgLi4uaGludCxcbiAgICB9O1xuXG4gICAgY29uc3Qgc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0gZXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhIHx8IHt9O1xuICAgIGNvbnN0IGNhcHR1cmVkU3BhblNjb3BlID0gc2RrUHJvY2Vzc2luZ01ldGFkYXRhLmNhcHR1cmVkU3BhblNjb3BlO1xuICAgIGNvbnN0IGNhcHR1cmVkU3Bhbklzb2xhdGlvblNjb3BlID0gc2RrUHJvY2Vzc2luZ01ldGFkYXRhLmNhcHR1cmVkU3Bhbklzb2xhdGlvblNjb3BlO1xuXG4gICAgdGhpcy5fcHJvY2VzcyhcbiAgICAgIHRoaXMuX2NhcHR1cmVFdmVudChldmVudCwgaGludFdpdGhFdmVudElkLCBjYXB0dXJlZFNwYW5TY29wZSB8fCBjdXJyZW50U2NvcGUsIGNhcHR1cmVkU3Bhbklzb2xhdGlvblNjb3BlKSxcbiAgICApO1xuXG4gICAgcmV0dXJuIGhpbnRXaXRoRXZlbnRJZC5ldmVudF9pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlcyBhIHNlc3Npb24uXG4gICAqL1xuICAgY2FwdHVyZVNlc3Npb24oc2Vzc2lvbikge1xuICAgIHRoaXMuc2VuZFNlc3Npb24oc2Vzc2lvbik7XG4gICAgLy8gQWZ0ZXIgc2VuZGluZywgd2Ugc2V0IGluaXQgZmFsc2UgdG8gaW5kaWNhdGUgaXQncyBub3QgdGhlIGZpcnN0IG9jY3VycmVuY2VcbiAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIHsgaW5pdDogZmFsc2UgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY3JvbiBtb25pdG9yIGNoZWNrIGluIGFuZCBzZW5kIGl0IHRvIFNlbnRyeS4gVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSBvbiBhbGwgY2xpZW50cy5cbiAgICpcbiAgICogQHBhcmFtIGNoZWNrSW4gQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgY2hlY2sgaW4uXG4gICAqIEBwYXJhbSB1cHNlcnRNb25pdG9yQ29uZmlnIEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIG1vbml0b3IgY29uZmlnLiBVc2UgdGhpcyBpZiB5b3Ugd2FudFxuICAgKiB0byBjcmVhdGUgYSBtb25pdG9yIGF1dG9tYXRpY2FsbHkgd2hlbiBzZW5kaW5nIGEgY2hlY2sgaW4uXG4gICAqIEBwYXJhbSBzY29wZSBBbiBvcHRpb25hbCBzY29wZSBjb250YWluaW5nIGV2ZW50IG1ldGFkYXRhLlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGlkIG9mIHRoZSBjaGVjayBpbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBEc24uXG4gICAqL1xuICAgZ2V0RHNuKCkge1xuICAgIHJldHVybiB0aGlzLl9kc247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAqL1xuICAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFNESyBtZXRhZGF0YS5cbiAgICogQHNlZSBTZGtNZXRhZGF0YVxuICAgKi9cbiAgIGdldFNka01ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLl9tZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0cmFuc3BvcnQgdGhhdCBpcyB1c2VkIGJ5IHRoZSBjbGllbnQuXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIHRyYW5zcG9ydCBnZXRzIGxhenkgaW5pdGlhbGl6ZWQgc28gaXQgd2lsbCBvbmx5IGJlIHRoZXJlIG9uY2UgdGhlIGZpcnN0IGV2ZW50IGhhcyBiZWVuIHNlbnQuXG4gICAqL1xuICAgZ2V0VHJhbnNwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQ7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCBmb3IgYWxsIGV2ZW50cyB0byBiZSBzZW50IG9yIHRoZSB0aW1lb3V0IHRvIGV4cGlyZSwgd2hpY2hldmVyIGNvbWVzIGZpcnN0LlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dCBNYXhpbXVtIHRpbWUgaW4gbXMgdGhlIGNsaWVudCBzaG91bGQgd2FpdCBmb3IgZXZlbnRzIHRvIGJlIGZsdXNoZWQuIE9taXR0aW5nIHRoaXMgcGFyYW1ldGVyIHdpbGxcbiAgICogICBjYXVzZSB0aGUgY2xpZW50IHRvIHdhaXQgdW50aWwgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgcmVzb2x2aW5nIHRoZSBwcm9taXNlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2l0aCBgdHJ1ZWAgaWYgYWxsIGV2ZW50cyBhcmUgc2VudCBiZWZvcmUgdGhlIHRpbWVvdXQsIG9yIGBmYWxzZWAgaWYgdGhlcmUgYXJlXG4gICAqIHN0aWxsIGV2ZW50cyBpbiB0aGUgcXVldWUgd2hlbiB0aGUgdGltZW91dCBpcyByZWFjaGVkLlxuICAgKi9cbiAgIGZsdXNoKHRpbWVvdXQpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQ7XG4gICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICAgICAgcmV0dXJuIHRoaXMuX2lzQ2xpZW50RG9uZVByb2Nlc3NpbmcodGltZW91dCkudGhlbihjbGllbnRGaW5pc2hlZCA9PiB7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQuZmx1c2godGltZW91dCkudGhlbih0cmFuc3BvcnRGbHVzaGVkID0+IGNsaWVudEZpbmlzaGVkICYmIHRyYW5zcG9ydEZsdXNoZWQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNvbHZlZFN5bmNQcm9taXNlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgZXZlbnQgcXVldWUgYW5kIHNldCB0aGUgY2xpZW50IHRvIGBlbmFibGVkID0gZmFsc2VgLiBTZWUge0BsaW5rIENsaWVudC5mbHVzaH0uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IE1heGltdW0gdGltZSBpbiBtcyB0aGUgY2xpZW50IHNob3VsZCB3YWl0IGJlZm9yZSBzaHV0dGluZyBkb3duLiBPbWl0dGluZyB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlXG4gICAqICAgdGhlIGNsaWVudCB0byB3YWl0IHVudGlsIGFsbCBldmVudHMgYXJlIHNlbnQgYmVmb3JlIGRpc2FibGluZyBpdHNlbGYuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gYHRydWVgIGlmIHRoZSBmbHVzaCBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5IGJlZm9yZSB0aGUgdGltZW91dCwgb3IgYGZhbHNlYCBpZlxuICAgKiBpdCBkb2Vzbid0LlxuICAgKi9cbiAgIGNsb3NlKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mbHVzaCh0aW1lb3V0KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLmdldE9wdGlvbnMoKS5lbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgaW5zdGFsbGVkIGV2ZW50IHByb2Nlc3NvcnMuXG4gICAqL1xuICAgZ2V0RXZlbnRQcm9jZXNzb3JzKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudFByb2Nlc3NvcnM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBwcm9jZXNzb3IgdGhhdCBhcHBsaWVzIHRvIGFueSBldmVudCBwcm9jZXNzZWQgYnkgdGhpcyBjbGllbnQuXG4gICAqL1xuICAgYWRkRXZlbnRQcm9jZXNzb3IoZXZlbnRQcm9jZXNzb3IpIHtcbiAgICB0aGlzLl9ldmVudFByb2Nlc3NvcnMucHVzaChldmVudFByb2Nlc3Nvcik7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGlzIGNsaWVudC5cbiAgICogQ2FsbCB0aGlzIGFmdGVyIHRoZSBjbGllbnQgd2FzIHNldCBvbiBhIHNjb3BlLlxuICAgKi9cbiAgIGluaXQoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5faXNFbmFibGVkKCkgfHxcbiAgICAgIC8vIEZvcmNlIGludGVncmF0aW9ucyB0byBiZSBzZXR1cCBldmVuIGlmIG5vIERTTiB3YXMgc2V0IHdoZW4gd2UgaGF2ZVxuICAgICAgLy8gU3BvdGxpZ2h0IGVuYWJsZWQuIFRoaXMgaXMgcGFydGljdWxhcmx5IGltcG9ydGFudCBmb3IgYnJvd3NlciBhcyB3ZVxuICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGUgYHNwb3RsaWdodGAgb3B0aW9uIHRoZXJlIGFuZCByZWx5IG9uIHRoZSB1c2Vyc1xuICAgICAgLy8gYWRkaW5nIHRoZSBgc3BvdGxpZ2h0QnJvd3NlckludGVncmF0aW9uKClgIHRvIHRoZWlyIGludGVncmF0aW9ucyB3aGljaFxuICAgICAgLy8gd291bGRuJ3QgZ2V0IGluaXRpYWxpemVkIHdpdGggdGhlIGNoZWNrIGJlbG93IHdoZW4gdGhlcmUncyBubyBEU04gc2V0LlxuICAgICAgdGhpcy5fb3B0aW9ucy5pbnRlZ3JhdGlvbnMuc29tZSgoeyBuYW1lIH0pID0+IG5hbWUuc3RhcnRzV2l0aCgnU3BvdGxpZ2h0JykpXG4gICAgKSB7XG4gICAgICB0aGlzLl9zZXR1cEludGVncmF0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGluc3RhbGxlZCBpbnRlZ3JhdGlvbiBieSBpdHMgbmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge0ludGVncmF0aW9ufHVuZGVmaW5lZH0gVGhlIGluc3RhbGxlZCBpbnRlZ3JhdGlvbiBvciBgdW5kZWZpbmVkYCBpZiBubyBpbnRlZ3JhdGlvbiB3aXRoIHRoYXQgYG5hbWVgIHdhcyBpbnN0YWxsZWQuXG4gICAqL1xuICAgZ2V0SW50ZWdyYXRpb25CeU5hbWUoaW50ZWdyYXRpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVncmF0aW9uc1tpbnRlZ3JhdGlvbk5hbWVdIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gaW50ZWdyYXRpb24gdG8gdGhlIGNsaWVudC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBlLmcuIGxhenkgbG9hZCBpbnRlZ3JhdGlvbnMuXG4gICAqIEluIG1vc3QgY2FzZXMsIHRoaXMgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnksXG4gICAqIGFuZCB5b3UncmUgYmV0dGVyIG9mZiBqdXN0IHBhc3NpbmcgdGhlIGludGVncmF0aW9ucyB2aWEgYGludGVncmF0aW9uczogW11gIGF0IGluaXRpYWxpemF0aW9uIHRpbWUuXG4gICAqIEhvd2V2ZXIsIGlmIHlvdSBmaW5kIHRoZSBuZWVkIHRvIGNvbmRpdGlvbmFsbHkgbG9hZCAmIGFkZCBhbiBpbnRlZ3JhdGlvbiwgeW91IGNhbiB1c2UgYGFkZEludGVncmF0aW9uYCB0byBkbyBzby5cbiAgICovXG4gICBhZGRJbnRlZ3JhdGlvbihpbnRlZ3JhdGlvbikge1xuICAgIGNvbnN0IGlzQWxyZWFkeUluc3RhbGxlZCA9IHRoaXMuX2ludGVncmF0aW9uc1tpbnRlZ3JhdGlvbi5uYW1lXTtcblxuICAgIC8vIFRoaXMgaG9vayB0YWtlcyBjYXJlIG9mIG9ubHkgaW5zdGFsbGluZyBpZiBub3QgYWxyZWFkeSBpbnN0YWxsZWRcbiAgICBzZXR1cEludGVncmF0aW9uKHRoaXMsIGludGVncmF0aW9uLCB0aGlzLl9pbnRlZ3JhdGlvbnMpO1xuICAgIC8vIEhlcmUgd2UgbmVlZCB0byBjaGVjayBtYW51YWxseSB0byBtYWtlIHN1cmUgdG8gbm90IHJ1biB0aGlzIG11bHRpcGxlIHRpbWVzXG4gICAgaWYgKCFpc0FscmVhZHlJbnN0YWxsZWQpIHtcbiAgICAgIGFmdGVyU2V0dXBJbnRlZ3JhdGlvbnModGhpcywgW2ludGVncmF0aW9uXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBmdWxseSBwcmVwYXJlZCBldmVudCB0byBTZW50cnkuXG4gICAqL1xuICAgc2VuZEV2ZW50KGV2ZW50LCBoaW50ID0ge30pIHtcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZVNlbmRFdmVudCcsIGV2ZW50LCBoaW50KTtcblxuICAgIGxldCBlbnYgPSBjcmVhdGVFdmVudEVudmVsb3BlKGV2ZW50LCB0aGlzLl9kc24sIHRoaXMuX29wdGlvbnMuX21ldGFkYXRhLCB0aGlzLl9vcHRpb25zLnR1bm5lbCk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgaGludC5hdHRhY2htZW50cyB8fCBbXSkge1xuICAgICAgZW52ID0gYWRkSXRlbVRvRW52ZWxvcGUoZW52LCBjcmVhdGVBdHRhY2htZW50RW52ZWxvcGVJdGVtKGF0dGFjaG1lbnQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZW5kRW52ZWxvcGUoZW52KTtcbiAgICBpZiAocHJvbWlzZSkge1xuICAgICAgcHJvbWlzZS50aGVuKHNlbmRSZXNwb25zZSA9PiB0aGlzLmVtaXQoJ2FmdGVyU2VuZEV2ZW50JywgZXZlbnQsIHNlbmRSZXNwb25zZSksIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgc2Vzc2lvbiBvciBzZXNzaW9uIGFnZ3JlZ3JhdGVzIHRvIFNlbnRyeS5cbiAgICovXG4gICBzZW5kU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgLy8gQmFja2ZpbGwgcmVsZWFzZSBhbmQgZW52aXJvbm1lbnQgb24gc2Vzc2lvblxuICAgIGNvbnN0IHsgcmVsZWFzZTogY2xpZW50UmVsZWFzZU9wdGlvbiwgZW52aXJvbm1lbnQ6IGNsaWVudEVudmlyb25tZW50T3B0aW9uID0gREVGQVVMVF9FTlZJUk9OTUVOVCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAoJ2FnZ3JlZ2F0ZXMnIGluIHNlc3Npb24pIHtcbiAgICAgIGNvbnN0IHNlc3Npb25BdHRycyA9IHNlc3Npb24uYXR0cnMgfHwge307XG4gICAgICBpZiAoIXNlc3Npb25BdHRycy5yZWxlYXNlICYmICFjbGllbnRSZWxlYXNlT3B0aW9uKSB7XG4gICAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLndhcm4oTUlTU0lOR19SRUxFQVNFX0ZPUl9TRVNTSU9OX0VSUk9SKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vzc2lvbkF0dHJzLnJlbGVhc2UgPSBzZXNzaW9uQXR0cnMucmVsZWFzZSB8fCBjbGllbnRSZWxlYXNlT3B0aW9uO1xuICAgICAgc2Vzc2lvbkF0dHJzLmVudmlyb25tZW50ID0gc2Vzc2lvbkF0dHJzLmVudmlyb25tZW50IHx8IGNsaWVudEVudmlyb25tZW50T3B0aW9uO1xuICAgICAgc2Vzc2lvbi5hdHRycyA9IHNlc3Npb25BdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzZXNzaW9uLnJlbGVhc2UgJiYgIWNsaWVudFJlbGVhc2VPcHRpb24pIHtcbiAgICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcud2FybihNSVNTSU5HX1JFTEVBU0VfRk9SX1NFU1NJT05fRVJST1IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXNzaW9uLnJlbGVhc2UgPSBzZXNzaW9uLnJlbGVhc2UgfHwgY2xpZW50UmVsZWFzZU9wdGlvbjtcbiAgICAgIHNlc3Npb24uZW52aXJvbm1lbnQgPSBzZXNzaW9uLmVudmlyb25tZW50IHx8IGNsaWVudEVudmlyb25tZW50T3B0aW9uO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYmVmb3JlU2VuZFNlc3Npb24nLCBzZXNzaW9uKTtcblxuICAgIGNvbnN0IGVudiA9IGNyZWF0ZVNlc3Npb25FbnZlbG9wZShzZXNzaW9uLCB0aGlzLl9kc24sIHRoaXMuX29wdGlvbnMuX21ldGFkYXRhLCB0aGlzLl9vcHRpb25zLnR1bm5lbCk7XG5cbiAgICAvLyBzZW5kRW52ZWxvcGUgc2hvdWxkIG5vdCB0aHJvd1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnNlbmRFbnZlbG9wZShlbnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCBvbiB0aGUgY2xpZW50IHRoYXQgYW4gZXZlbnQgZ290IGRyb3BwZWQgKGllLCBhbiBldmVudCB0aGF0IHdpbGwgbm90IGJlIHNlbnQgdG8gU2VudHJ5KS5cbiAgICovXG4gICByZWNvcmREcm9wcGVkRXZlbnQocmVhc29uLCBjYXRlZ29yeSwgY291bnQgPSAxKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VuZENsaWVudFJlcG9ydHMpIHtcbiAgICAgIC8vIFdlIHdhbnQgdG8gdHJhY2sgZWFjaCBjYXRlZ29yeSAoZXJyb3IsIHRyYW5zYWN0aW9uLCBzZXNzaW9uLCByZXBsYXlfZXZlbnQpIHNlcGFyYXRlbHlcbiAgICAgIC8vIGJ1dCBzdGlsbCBrZWVwIHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIGRpZmZlcmVudCB0eXBlIG9mIG91dGNvbWVzLlxuICAgICAgLy8gV2UgY291bGQgdXNlIG5lc3RlZCBtYXBzLCBidXQgaXQncyBtdWNoIGVhc2llciB0byByZWFkIGFuZCB0eXBlIHRoaXMgd2F5LlxuICAgICAgLy8gQSBjb3JyZWN0IHR5cGUgZm9yIG1hcC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBpZiB3ZSB3YW50IHRvIGdvIHRoYXQgcm91dGVcbiAgICAgIC8vIHdvdWxkIGJlIGBQYXJ0aWFsPFJlY29yZDxTZW50cnlSZXF1ZXN0VHlwZSwgUGFydGlhbDxSZWNvcmQ8T3V0Y29tZSwgbnVtYmVyPj4+PmBcbiAgICAgIC8vIFdpdGggdHlwZXNjcmlwdCA0LjEgd2UgY291bGQgZXZlbiB1c2UgdGVtcGxhdGUgbGl0ZXJhbCB0eXBlc1xuICAgICAgY29uc3Qga2V5ID0gYCR7cmVhc29ufToke2NhdGVnb3J5fWA7XG4gICAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5sb2coYFJlY29yZGluZyBvdXRjb21lOiBcIiR7a2V5fVwiJHtjb3VudCA+IDEgPyBgICgke2NvdW50fSB0aW1lcylgIDogJyd9YCk7XG4gICAgICB0aGlzLl9vdXRjb21lc1trZXldID0gKHRoaXMuX291dGNvbWVzW2tleV0gfHwgMCkgKyBjb3VudDtcbiAgICB9XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzICovXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB3aGVuZXZlciBhIHNwYW4gaXMgc3RhcnRlZC5cbiAgICogUmVjZWl2ZXMgdGhlIHNwYW4gYXMgYXJndW1lbnQuXG4gICAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfSBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHJlbW92ZXMgdGhlIHJlZ2lzdGVyZWQgY2FsbGJhY2suXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGhvb2sgb24gdGhpcyBjbGllbnQuXG4gICAqL1xuICAgb24oaG9vaywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBob29rcyA9ICh0aGlzLl9ob29rc1tob29rXSA9IHRoaXMuX2hvb2tzW2hvb2tdIHx8IFtdKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgYXNzdW1lIHRoZSB0eXBlcyBhcmUgY29ycmVjdFxuICAgIGhvb2tzLnB1c2goY2FsbGJhY2spO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgY2FsbGJhY2sgZXhlY3V0aW9uIGhhbmRsZXIgdGhhdCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIGRlcmVnaXN0ZXJzIGEgY2FsbGJhY2suIFRoaXMgaXMgY3J1Y2lhbCBmb3IgbWFuYWdpbmcgaW5zdGFuY2VzIHdoZXJlIGNhbGxiYWNrc1xuICAgIC8vIG5lZWQgdG8gYmUgdW5yZWdpc3RlcmVkIHRvIHByZXZlbnQgc2VsZi1yZWZlcmVuY2luZyBpbiBjYWxsYmFjayBjbG9zdXJlcyxcbiAgICAvLyBlbnN1cmluZyBwcm9wZXIgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGFzc3VtZSB0aGUgdHlwZXMgYXJlIGNvcnJlY3RcbiAgICAgIGNvbnN0IGNiSW5kZXggPSBob29rcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgIGlmIChjYkluZGV4ID4gLTEpIHtcbiAgICAgICAgaG9va3Muc3BsaWNlKGNiSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiogRmlyZSBhIGhvb2sgd2hlbmV2ZXIgYSBzcGFuIHN0YXJ0cy4gKi9cblxuICAvKipcbiAgICogRW1pdCBhIGhvb2sgdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHZpYSBgb24oKWAuXG4gICAqL1xuICAgZW1pdChob29rLCAuLi5yZXN0KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5faG9va3NbaG9va107XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4ucmVzdCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGFuIGVudmVsb3BlIHRvIFNlbnRyeS5cbiAgICovXG4gICBzZW5kRW52ZWxvcGUoZW52ZWxvcGUpIHtcbiAgICB0aGlzLmVtaXQoJ2JlZm9yZUVudmVsb3BlJywgZW52ZWxvcGUpO1xuXG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCgpICYmIHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVudmVsb3BlKS50aGVuKG51bGwsIHJlYXNvbiA9PiB7XG4gICAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmVycm9yKCdFcnJvciB3aGlsZSBzZW5kaW5nIGVudmVsb3BlOicsIHJlYXNvbik7XG4gICAgICAgIHJldHVybiByZWFzb247XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5lcnJvcignVHJhbnNwb3J0IGRpc2FibGVkJyk7XG5cbiAgICByZXR1cm4gcmVzb2x2ZWRTeW5jUHJvbWlzZSh7fSk7XG4gIH1cblxuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXMgKi9cblxuICAvKiogU2V0dXAgaW50ZWdyYXRpb25zIGZvciB0aGlzIGNsaWVudC4gKi9cbiAgIF9zZXR1cEludGVncmF0aW9ucygpIHtcbiAgICBjb25zdCB7IGludGVncmF0aW9ucyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0aGlzLl9pbnRlZ3JhdGlvbnMgPSBzZXR1cEludGVncmF0aW9ucyh0aGlzLCBpbnRlZ3JhdGlvbnMpO1xuICAgIGFmdGVyU2V0dXBJbnRlZ3JhdGlvbnModGhpcywgaW50ZWdyYXRpb25zKTtcbiAgfVxuXG4gIC8qKiBVcGRhdGVzIGV4aXN0aW5nIHNlc3Npb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIGV2ZW50ICovXG4gICBfdXBkYXRlU2Vzc2lvbkZyb21FdmVudChzZXNzaW9uLCBldmVudCkge1xuICAgIGxldCBjcmFzaGVkID0gZXZlbnQubGV2ZWwgPT09ICdmYXRhbCc7XG4gICAgbGV0IGVycm9yZWQgPSBmYWxzZTtcbiAgICBjb25zdCBleGNlcHRpb25zID0gZXZlbnQuZXhjZXB0aW9uPy52YWx1ZXM7XG5cbiAgICBpZiAoZXhjZXB0aW9ucykge1xuICAgICAgZXJyb3JlZCA9IHRydWU7XG5cbiAgICAgIGZvciAoY29uc3QgZXggb2YgZXhjZXB0aW9ucykge1xuICAgICAgICBjb25zdCBtZWNoYW5pc20gPSBleC5tZWNoYW5pc207XG4gICAgICAgIGlmIChtZWNoYW5pc20/LmhhbmRsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY3Jhc2hlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBIHNlc3Npb24gaXMgdXBkYXRlZCBhbmQgdGhhdCBzZXNzaW9uIHVwZGF0ZSBpcyBzZW50IGluIG9ubHkgb25lIG9mIHRoZSB0d28gZm9sbG93aW5nIHNjZW5hcmlvczpcbiAgICAvLyAxLiBTZXNzaW9uIHdpdGggbm9uIHRlcm1pbmFsIHN0YXR1cyBhbmQgMCBlcnJvcnMgKyBhbiBlcnJvciBvY2N1cnJlZCAtPiBXaWxsIHNldCBlcnJvciBjb3VudCB0byAxIGFuZCBzZW5kIHVwZGF0ZVxuICAgIC8vIDIuIFNlc3Npb24gd2l0aCBub24gdGVybWluYWwgc3RhdHVzIGFuZCAxIGVycm9yICsgYSBjcmFzaCBvY2N1cnJlZCAtPiBXaWxsIHNldCBzdGF0dXMgY3Jhc2hlZCBhbmQgc2VuZCB1cGRhdGVcbiAgICBjb25zdCBzZXNzaW9uTm9uVGVybWluYWwgPSBzZXNzaW9uLnN0YXR1cyA9PT0gJ29rJztcbiAgICBjb25zdCBzaG91bGRVcGRhdGVBbmRTZW5kID0gKHNlc3Npb25Ob25UZXJtaW5hbCAmJiBzZXNzaW9uLmVycm9ycyA9PT0gMCkgfHwgKHNlc3Npb25Ob25UZXJtaW5hbCAmJiBjcmFzaGVkKTtcblxuICAgIGlmIChzaG91bGRVcGRhdGVBbmRTZW5kKSB7XG4gICAgICB1cGRhdGVTZXNzaW9uKHNlc3Npb24sIHtcbiAgICAgICAgLi4uKGNyYXNoZWQgJiYgeyBzdGF0dXM6ICdjcmFzaGVkJyB9KSxcbiAgICAgICAgZXJyb3JzOiBzZXNzaW9uLmVycm9ycyB8fCBOdW1iZXIoZXJyb3JlZCB8fCBjcmFzaGVkKSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYXB0dXJlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBjbGllbnQgaXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gUmV0dXJucyBhIHByb21pc2UgYmVjYXVzZSBpdCB3aWxsIHdhaXQgYHRpbWVvdXRgIG1zIGJlZm9yZSBzYXlpbmdcbiAgICogXCJub1wiIChyZXNvbHZpbmcgdG8gYGZhbHNlYCkgaW4gb3JkZXIgdG8gZ2l2ZSB0aGUgY2xpZW50IGEgY2hhbmNlIHRvIHBvdGVudGlhbGx5IGZpbmlzaCBmaXJzdC5cbiAgICpcbiAgICogQHBhcmFtIHRpbWVvdXQgVGhlIHRpbWUsIGluIG1zLCBhZnRlciB3aGljaCB0byByZXNvbHZlIHRvIGBmYWxzZWAgaWYgdGhlIGNsaWVudCBpcyBzdGlsbCBidXN5LiBQYXNzaW5nIGAwYCAob3Igbm90XG4gICAqIHBhc3NpbmcgYW55dGhpbmcpIHdpbGwgbWFrZSB0aGUgcHJvbWlzZSB3YWl0IGFzIGxvbmcgYXMgaXQgdGFrZXMgZm9yIHByb2Nlc3NpbmcgdG8gZmluaXNoIGJlZm9yZSByZXNvbHZpbmcgdG9cbiAgICogYHRydWVgLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2hpY2ggd2lsbCByZXNvbHZlIHRvIGB0cnVlYCBpZiBwcm9jZXNzaW5nIGlzIGFscmVhZHkgZG9uZSBvciBmaW5pc2hlcyBiZWZvcmUgdGhlIHRpbWVvdXQsIGFuZFxuICAgKiBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgIF9pc0NsaWVudERvbmVQcm9jZXNzaW5nKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IHRpY2tlZCA9IDA7XG4gICAgICBjb25zdCB0aWNrID0gMTtcblxuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9udW1Qcm9jZXNzaW5nID09IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tlZCArPSB0aWNrO1xuICAgICAgICAgIGlmICh0aW1lb3V0ICYmIHRpY2tlZCA+PSB0aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGljayk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgU0RLIGlzIGVuYWJsZWQgYW5kIGEgdHJhbnNwb3J0IGlzIHByZXNlbnQuICovXG4gICBfaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoKS5lbmFibGVkICE9PSBmYWxzZSAmJiB0aGlzLl90cmFuc3BvcnQgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNvbW1vbiBpbmZvcm1hdGlvbiB0byBldmVudHMuXG4gICAqXG4gICAqIFRoZSBpbmZvcm1hdGlvbiBpbmNsdWRlcyByZWxlYXNlIGFuZCBlbnZpcm9ubWVudCBmcm9tIGBvcHRpb25zYCxcbiAgICogYnJlYWRjcnVtYnMgYW5kIGNvbnRleHQgKGV4dHJhLCB0YWdzIGFuZCB1c2VyKSBmcm9tIHRoZSBzY29wZS5cbiAgICpcbiAgICogSW5mb3JtYXRpb24gdGhhdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGV2ZW50IGlzIG5ldmVyIG92ZXJ3cml0dGVuLiBGb3JcbiAgICogbmVzdGVkIG9iamVjdHMsIHN1Y2ggYXMgdGhlIGNvbnRleHQsIGtleXMgYXJlIG1lcmdlZC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudC5cbiAgICogQHBhcmFtIGhpbnQgTWF5IGNvbnRhaW4gYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uLlxuICAgKiBAcGFyYW0gY3VycmVudFNjb3BlIEEgc2NvcGUgY29udGFpbmluZyBldmVudCBtZXRhZGF0YS5cbiAgICogQHJldHVybnMgQSBuZXcgZXZlbnQgd2l0aCBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgIF9wcmVwYXJlRXZlbnQoXG4gICAgZXZlbnQsXG4gICAgaGludCxcbiAgICBjdXJyZW50U2NvcGUsXG4gICAgaXNvbGF0aW9uU2NvcGUsXG4gICkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICBjb25zdCBpbnRlZ3JhdGlvbnMgPSBPYmplY3Qua2V5cyh0aGlzLl9pbnRlZ3JhdGlvbnMpO1xuICAgIGlmICghaGludC5pbnRlZ3JhdGlvbnMgJiYgaW50ZWdyYXRpb25zPy5sZW5ndGgpIHtcbiAgICAgIGhpbnQuaW50ZWdyYXRpb25zID0gaW50ZWdyYXRpb25zO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgncHJlcHJvY2Vzc0V2ZW50JywgZXZlbnQsIGhpbnQpO1xuXG4gICAgaWYgKCFldmVudC50eXBlKSB7XG4gICAgICBpc29sYXRpb25TY29wZS5zZXRMYXN0RXZlbnRJZChldmVudC5ldmVudF9pZCB8fCBoaW50LmV2ZW50X2lkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlcGFyZUV2ZW50KG9wdGlvbnMsIGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIHRoaXMsIGlzb2xhdGlvblNjb3BlKS50aGVuKGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBldnQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdCgncG9zdHByb2Nlc3NFdmVudCcsIGV2dCwgaGludCk7XG5cbiAgICAgIGV2dC5jb250ZXh0cyA9IHtcbiAgICAgICAgdHJhY2U6IGdldFRyYWNlQ29udGV4dEZyb21TY29wZShjdXJyZW50U2NvcGUpLFxuICAgICAgICAuLi5ldnQuY29udGV4dHMsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZSh0aGlzLCBjdXJyZW50U2NvcGUpO1xuXG4gICAgICBldnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhID0ge1xuICAgICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LFxuICAgICAgICAuLi5ldnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgdGhlIGV2ZW50IGFuZCBsb2dzIGFuIGVycm9yIGluIGNhc2Ugb2YgcmVqZWN0aW9uXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gaGludFxuICAgKiBAcGFyYW0gc2NvcGVcbiAgICovXG4gICBfY2FwdHVyZUV2ZW50KFxuICAgIGV2ZW50LFxuICAgIGhpbnQgPSB7fSxcbiAgICBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICBpc29sYXRpb25TY29wZSA9IGdldElzb2xhdGlvblNjb3BlKCksXG4gICkge1xuICAgIGlmIChERUJVR19CVUlMRCAmJiBpc0Vycm9yRXZlbnQoZXZlbnQpKSB7XG4gICAgICBkZWJ1Zy5sb2coYENhcHR1cmVkIGVycm9yIGV2ZW50IFxcYCR7Z2V0UG9zc2libGVFdmVudE1lc3NhZ2VzKGV2ZW50KVswXSB8fCAnPHVua25vd24+J31cXGBgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc0V2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlKS50aGVuKFxuICAgICAgZmluYWxFdmVudCA9PiB7XG4gICAgICAgIHJldHVybiBmaW5hbEV2ZW50LmV2ZW50X2lkO1xuICAgICAgfSxcbiAgICAgIHJlYXNvbiA9PiB7XG4gICAgICAgIGlmIChERUJVR19CVUlMRCkge1xuICAgICAgICAgIGlmIChfaXNEb05vdFNlbmRFdmVudEVycm9yKHJlYXNvbikpIHtcbiAgICAgICAgICAgIGRlYnVnLmxvZyhyZWFzb24ubWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfaXNJbnRlcm5hbEVycm9yKHJlYXNvbikpIHtcbiAgICAgICAgICAgIGRlYnVnLndhcm4ocmVhc29uLm1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWJ1Zy53YXJuKHJlYXNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGFuIGV2ZW50IChlaXRoZXIgZXJyb3Igb3IgbWVzc2FnZSkgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAgICpcbiAgICogVGhpcyBhbHNvIGFkZHMgYnJlYWRjcnVtYnMgYW5kIGNvbnRleHQgaW5mb3JtYXRpb24gdG8gdGhlIGV2ZW50LiBIb3dldmVyLFxuICAgKiBwbGF0Zm9ybSBzcGVjaWZpYyBtZXRhIGRhdGEgKHN1Y2ggYXMgdGhlIFVzZXIncyBJUCBhZGRyZXNzKSBtdXN0IGJlIGFkZGVkXG4gICAqIGJ5IHRoZSBTREsgaW1wbGVtZW50b3IuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZCB0byBTZW50cnkuXG4gICAqIEBwYXJhbSBoaW50IE1heSBjb250YWluIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbi5cbiAgICogQHBhcmFtIGN1cnJlbnRTY29wZSBBIHNjb3BlIGNvbnRhaW5pbmcgZXZlbnQgbWV0YWRhdGEuXG4gICAqIEByZXR1cm5zIEEgU3luY1Byb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBldmVudCBvciByZWplY3RzIGluIGNhc2UgZXZlbnQgd2FzL3dpbGwgbm90IGJlIHNlbmQuXG4gICAqL1xuICAgX3Byb2Nlc3NFdmVudChcbiAgICBldmVudCxcbiAgICBoaW50LFxuICAgIGN1cnJlbnRTY29wZSxcbiAgICBpc29sYXRpb25TY29wZSxcbiAgKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IHsgc2FtcGxlUmF0ZSB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGlzVHJhbnNhY3Rpb24gPSBpc1RyYW5zYWN0aW9uRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGlzRXJyb3IgPSBpc0Vycm9yRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGUgfHwgJ2Vycm9yJztcbiAgICBjb25zdCBiZWZvcmVTZW5kTGFiZWwgPSBgYmVmb3JlIHNlbmQgZm9yIHR5cGUgXFxgJHtldmVudFR5cGV9XFxgYDtcblxuICAgIC8vIDEuMCA9PT0gMTAwJSBldmVudHMgYXJlIHNlbnRcbiAgICAvLyAwLjAgPT09IDAlIGV2ZW50cyBhcmUgc2VudFxuICAgIC8vIFNhbXBsaW5nIGZvciB0cmFuc2FjdGlvbiBoYXBwZW5zIHNvbWV3aGVyZSBlbHNlXG4gICAgY29uc3QgcGFyc2VkU2FtcGxlUmF0ZSA9IHR5cGVvZiBzYW1wbGVSYXRlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IHBhcnNlU2FtcGxlUmF0ZShzYW1wbGVSYXRlKTtcbiAgICBpZiAoaXNFcnJvciAmJiB0eXBlb2YgcGFyc2VkU2FtcGxlUmF0ZSA9PT0gJ251bWJlcicgJiYgTWF0aC5yYW5kb20oKSA+IHBhcnNlZFNhbXBsZVJhdGUpIHtcbiAgICAgIHRoaXMucmVjb3JkRHJvcHBlZEV2ZW50KCdzYW1wbGVfcmF0ZScsICdlcnJvcicpO1xuICAgICAgcmV0dXJuIHJlamVjdGVkU3luY1Byb21pc2UoXG4gICAgICAgIF9tYWtlRG9Ob3RTZW5kRXZlbnRFcnJvcihcbiAgICAgICAgICBgRGlzY2FyZGluZyBldmVudCBiZWNhdXNlIGl0J3Mgbm90IGluY2x1ZGVkIGluIHRoZSByYW5kb20gc2FtcGxlIChzYW1wbGluZyByYXRlID0gJHtzYW1wbGVSYXRlfSlgLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhQ2F0ZWdvcnkgPSAoZXZlbnRUeXBlID09PSAncmVwbGF5X2V2ZW50JyA/ICdyZXBsYXknIDogZXZlbnRUeXBlKSA7XG5cbiAgICByZXR1cm4gdGhpcy5fcHJlcGFyZUV2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlKVxuICAgICAgLnRoZW4ocHJlcGFyZWQgPT4ge1xuICAgICAgICBpZiAocHJlcGFyZWQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnZXZlbnRfcHJvY2Vzc29yJywgZGF0YUNhdGVnb3J5KTtcbiAgICAgICAgICB0aHJvdyBfbWFrZURvTm90U2VuZEV2ZW50RXJyb3IoJ0FuIGV2ZW50IHByb2Nlc3NvciByZXR1cm5lZCBgbnVsbGAsIHdpbGwgbm90IHNlbmQgZXZlbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0ludGVybmFsRXhjZXB0aW9uID0gaGludC5kYXRhICYmIChoaW50LmRhdGEgKS5fX3NlbnRyeV9fID09PSB0cnVlO1xuICAgICAgICBpZiAoaXNJbnRlcm5hbEV4Y2VwdGlvbikge1xuICAgICAgICAgIHJldHVybiBwcmVwYXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3NCZWZvcmVTZW5kKHRoaXMsIG9wdGlvbnMsIHByZXBhcmVkLCBoaW50KTtcbiAgICAgICAgcmV0dXJuIF92YWxpZGF0ZUJlZm9yZVNlbmRSZXN1bHQocmVzdWx0LCBiZWZvcmVTZW5kTGFiZWwpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKHByb2Nlc3NlZEV2ZW50ID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3NlZEV2ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmREcm9wcGVkRXZlbnQoJ2JlZm9yZV9zZW5kJywgZGF0YUNhdGVnb3J5KTtcbiAgICAgICAgICBpZiAoaXNUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBldmVudC5zcGFucyB8fCBbXTtcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBpdHNlbGYgY291bnRzIGFzIG9uZSBzcGFuLCBwbHVzIGFsbCB0aGUgY2hpbGQgc3BhbnMgdGhhdCBhcmUgYWRkZWRcbiAgICAgICAgICAgIGNvbnN0IHNwYW5Db3VudCA9IDEgKyBzcGFucy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnc3BhbicsIHNwYW5Db3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IF9tYWtlRG9Ob3RTZW5kRXZlbnRFcnJvcihgJHtiZWZvcmVTZW5kTGFiZWx9IHJldHVybmVkIFxcYG51bGxcXGAsIHdpbGwgbm90IHNlbmQgZXZlbnQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXNzaW9uID0gY3VycmVudFNjb3BlLmdldFNlc3Npb24oKSB8fCBpc29sYXRpb25TY29wZS5nZXRTZXNzaW9uKCk7XG4gICAgICAgIGlmIChpc0Vycm9yICYmIHNlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTZXNzaW9uRnJvbUV2ZW50KHNlc3Npb24sIHByb2Nlc3NlZEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgc3BhbkNvdW50QmVmb3JlID0gcHJvY2Vzc2VkRXZlbnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhPy5zcGFuQ291bnRCZWZvcmVQcm9jZXNzaW5nIHx8IDA7XG4gICAgICAgICAgY29uc3Qgc3BhbkNvdW50QWZ0ZXIgPSBwcm9jZXNzZWRFdmVudC5zcGFucyA/IHByb2Nlc3NlZEV2ZW50LnNwYW5zLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgICBjb25zdCBkcm9wcGVkU3BhbkNvdW50ID0gc3BhbkNvdW50QmVmb3JlIC0gc3BhbkNvdW50QWZ0ZXI7XG4gICAgICAgICAgaWYgKGRyb3BwZWRTcGFuQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29yZERyb3BwZWRFdmVudCgnYmVmb3JlX3NlbmQnLCAnc3BhbicsIGRyb3BwZWRTcGFuQ291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vbmUgb2YgdGhlIFNlbnRyeSBidWlsdCBldmVudCBwcm9jZXNzb3Igd2lsbCB1cGRhdGUgdHJhbnNhY3Rpb24gbmFtZSxcbiAgICAgICAgLy8gc28gaWYgdGhlIHRyYW5zYWN0aW9uIG5hbWUgaGFzIGJlZW4gY2hhbmdlZCBieSBhbiBldmVudCBwcm9jZXNzb3IsIHdlIGtub3dcbiAgICAgICAgLy8gaXQgaGFzIHRvIGNvbWUgZnJvbSBjdXN0b20gZXZlbnQgcHJvY2Vzc29yIGFkZGVkIGJ5IGEgdXNlclxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkluZm8gPSBwcm9jZXNzZWRFdmVudC50cmFuc2FjdGlvbl9pbmZvO1xuICAgICAgICBpZiAoaXNUcmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbkluZm8gJiYgcHJvY2Vzc2VkRXZlbnQudHJhbnNhY3Rpb24gIT09IGV2ZW50LnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gJ2N1c3RvbSc7XG4gICAgICAgICAgcHJvY2Vzc2VkRXZlbnQudHJhbnNhY3Rpb25faW5mbyA9IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uSW5mbyxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZW5kRXZlbnQocHJvY2Vzc2VkRXZlbnQsIGhpbnQpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRXZlbnQ7XG4gICAgICB9KVxuICAgICAgLnRoZW4obnVsbCwgcmVhc29uID0+IHtcbiAgICAgICAgaWYgKF9pc0RvTm90U2VuZEV2ZW50RXJyb3IocmVhc29uKSB8fCBfaXNJbnRlcm5hbEVycm9yKHJlYXNvbikpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhcHR1cmVFeGNlcHRpb24ocmVhc29uLCB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgX19zZW50cnlfXzogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9yaWdpbmFsRXhjZXB0aW9uOiByZWFzb24sXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBfbWFrZUludGVybmFsRXJyb3IoXG4gICAgICAgICAgYEV2ZW50IHByb2Nlc3NpbmcgcGlwZWxpbmUgdGhyZXcgYW4gZXJyb3IsIG9yaWdpbmFsIGV2ZW50IHdpbGwgbm90IGJlIHNlbnQuIERldGFpbHMgaGF2ZSBiZWVuIHNlbnQgYXMgYSBuZXcgZXZlbnQuXFxuUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT2NjdXBpZXMgdGhlIGNsaWVudCB3aXRoIHByb2Nlc3NpbmcgYW5kIGV2ZW50XG4gICAqL1xuICAgX3Byb2Nlc3MocHJvbWlzZSkge1xuICAgIHRoaXMuX251bVByb2Nlc3NpbmcrKztcbiAgICB2b2lkIHByb21pc2UudGhlbihcbiAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5fbnVtUHJvY2Vzc2luZy0tO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fbnVtUHJvY2Vzc2luZy0tO1xuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBvdXRjb21lcyBvbiB0aGlzIGNsaWVudCBhbmQgcmV0dXJucyB0aGVtLlxuICAgKi9cbiAgIF9jbGVhck91dGNvbWVzKCkge1xuICAgIGNvbnN0IG91dGNvbWVzID0gdGhpcy5fb3V0Y29tZXM7XG4gICAgdGhpcy5fb3V0Y29tZXMgPSB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob3V0Y29tZXMpLm1hcCgoW2tleSwgcXVhbnRpdHldKSA9PiB7XG4gICAgICBjb25zdCBbcmVhc29uLCBjYXRlZ29yeV0gPSBrZXkuc3BsaXQoJzonKSA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWFzb24sXG4gICAgICAgIGNhdGVnb3J5LFxuICAgICAgICBxdWFudGl0eSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgY2xpZW50IHJlcG9ydHMgYXMgYW4gZW52ZWxvcGUuXG4gICAqL1xuICAgX2ZsdXNoT3V0Y29tZXMoKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKCdGbHVzaGluZyBvdXRjb21lcy4uLicpO1xuXG4gICAgY29uc3Qgb3V0Y29tZXMgPSB0aGlzLl9jbGVhck91dGNvbWVzKCk7XG5cbiAgICBpZiAob3V0Y29tZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5sb2coJ05vIG91dGNvbWVzIHRvIHNlbmQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHJlYWxseSB0aGUgb25seSBwbGFjZSB3aGVyZSB3ZSB3YW50IHRvIGNoZWNrIGZvciBhIERTTiBhbmQgb25seSBzZW5kIG91dGNvbWVzIHRoZW5cbiAgICBpZiAoIXRoaXMuX2Rzbikge1xuICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcubG9nKCdObyBkc24gcHJvdmlkZWQsIHdpbGwgbm90IHNlbmQgb3V0Y29tZXMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5sb2coJ1NlbmRpbmcgb3V0Y29tZXM6Jywgb3V0Y29tZXMpO1xuXG4gICAgY29uc3QgZW52ZWxvcGUgPSBjcmVhdGVDbGllbnRSZXBvcnRFbnZlbG9wZShvdXRjb21lcywgdGhpcy5fb3B0aW9ucy50dW5uZWwgJiYgZHNuVG9TdHJpbmcodGhpcy5fZHNuKSk7XG5cbiAgICAvLyBzZW5kRW52ZWxvcGUgc2hvdWxkIG5vdCB0aHJvd1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICB0aGlzLnNlbmRFbnZlbG9wZShlbnZlbG9wZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiB7QGxpbmsgRXZlbnR9IGZyb20gYWxsIGlucHV0cyB0byBgY2FwdHVyZUV4Y2VwdGlvbmAgYW5kIG5vbi1wcmltaXRpdmUgaW5wdXRzIHRvIGBjYXB0dXJlTWVzc2FnZWAuXG4gICAqL1xuXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBDbGllbnRgIGluc3RlYWQuIFRoaXMgYWxpYXMgbWF5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi5cbiAqL1xuLy8gVE9ETyh2MTApOiBSZW1vdmVcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYENsaWVudGAgaW5zdGVhZC4gVGhpcyBhbGlhcyBtYXkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLlxuICovXG4vLyBUT0RPKHYxMCk6IFJlbW92ZVxuY29uc3QgQmFzZUNsaWVudCA9IENsaWVudDtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IHJldHVybiB2YWx1ZSBvZiBjb25maWd1cmVkIGBiZWZvcmVTZW5kYCBvciBgYmVmb3JlU2VuZFRyYW5zYWN0aW9uYCBpcyBvZiBleHBlY3RlZCB0eXBlLCBhbmQgcmV0dXJucyB0aGUgdmFsdWUgaWYgc28uXG4gKi9cbmZ1bmN0aW9uIF92YWxpZGF0ZUJlZm9yZVNlbmRSZXN1bHQoXG4gIGJlZm9yZVNlbmRSZXN1bHQsXG4gIGJlZm9yZVNlbmRMYWJlbCxcbikge1xuICBjb25zdCBpbnZhbGlkVmFsdWVFcnJvciA9IGAke2JlZm9yZVNlbmRMYWJlbH0gbXVzdCByZXR1cm4gXFxgbnVsbFxcYCBvciBhIHZhbGlkIGV2ZW50LmA7XG4gIGlmIChpc1RoZW5hYmxlKGJlZm9yZVNlbmRSZXN1bHQpKSB7XG4gICAgcmV0dXJuIGJlZm9yZVNlbmRSZXN1bHQudGhlbihcbiAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KGV2ZW50KSAmJiBldmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IF9tYWtlSW50ZXJuYWxFcnJvcihpbnZhbGlkVmFsdWVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSxcbiAgICAgIGUgPT4ge1xuICAgICAgICB0aHJvdyBfbWFrZUludGVybmFsRXJyb3IoYCR7YmVmb3JlU2VuZExhYmVsfSByZWplY3RlZCB3aXRoICR7ZX1gKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfSBlbHNlIGlmICghaXNQbGFpbk9iamVjdChiZWZvcmVTZW5kUmVzdWx0KSAmJiBiZWZvcmVTZW5kUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgdGhyb3cgX21ha2VJbnRlcm5hbEVycm9yKGludmFsaWRWYWx1ZUVycm9yKTtcbiAgfVxuICByZXR1cm4gYmVmb3JlU2VuZFJlc3VsdDtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSBtYXRjaGluZyBgYmVmb3JlU2VuZFhYWGAgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NCZWZvcmVTZW5kKFxuICBjbGllbnQsXG4gIG9wdGlvbnMsXG4gIGV2ZW50LFxuICBoaW50LFxuKSB7XG4gIGNvbnN0IHsgYmVmb3JlU2VuZCwgYmVmb3JlU2VuZFRyYW5zYWN0aW9uLCBiZWZvcmVTZW5kU3BhbiB9ID0gb3B0aW9ucztcbiAgbGV0IHByb2Nlc3NlZEV2ZW50ID0gZXZlbnQ7XG5cbiAgaWYgKGlzRXJyb3JFdmVudChwcm9jZXNzZWRFdmVudCkgJiYgYmVmb3JlU2VuZCkge1xuICAgIHJldHVybiBiZWZvcmVTZW5kKHByb2Nlc3NlZEV2ZW50LCBoaW50KTtcbiAgfVxuXG4gIGlmIChpc1RyYW5zYWN0aW9uRXZlbnQocHJvY2Vzc2VkRXZlbnQpKSB7XG4gICAgaWYgKGJlZm9yZVNlbmRTcGFuKSB7XG4gICAgICAvLyBwcm9jZXNzIHJvb3Qgc3BhblxuICAgICAgY29uc3QgcHJvY2Vzc2VkUm9vdFNwYW5Kc29uID0gYmVmb3JlU2VuZFNwYW4oY29udmVydFRyYW5zYWN0aW9uRXZlbnRUb1NwYW5Kc29uKHByb2Nlc3NlZEV2ZW50KSk7XG4gICAgICBpZiAoIXByb2Nlc3NlZFJvb3RTcGFuSnNvbikge1xuICAgICAgICBzaG93U3BhbkRyb3BXYXJuaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgZXZlbnQgd2l0aCBwcm9jZXNzZWQgcm9vdCBzcGFuIHZhbHVlc1xuICAgICAgICBwcm9jZXNzZWRFdmVudCA9IG1lcmdlKGV2ZW50LCBjb252ZXJ0U3Bhbkpzb25Ub1RyYW5zYWN0aW9uRXZlbnQocHJvY2Vzc2VkUm9vdFNwYW5Kc29uKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgY2hpbGQgc3BhbnNcbiAgICAgIGlmIChwcm9jZXNzZWRFdmVudC5zcGFucykge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRTcGFucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNwYW4gb2YgcHJvY2Vzc2VkRXZlbnQuc3BhbnMpIHtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzZWRTcGFuID0gYmVmb3JlU2VuZFNwYW4oc3Bhbik7XG4gICAgICAgICAgaWYgKCFwcm9jZXNzZWRTcGFuKSB7XG4gICAgICAgICAgICBzaG93U3BhbkRyb3BXYXJuaW5nKCk7XG4gICAgICAgICAgICBwcm9jZXNzZWRTcGFucy5wdXNoKHNwYW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTcGFucy5wdXNoKHByb2Nlc3NlZFNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzZWRFdmVudC5zcGFucyA9IHByb2Nlc3NlZFNwYW5zO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiZWZvcmVTZW5kVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmIChwcm9jZXNzZWRFdmVudC5zcGFucykge1xuICAgICAgICAvLyBXZSBzdG9yZSB0aGUgIyBvZiBzcGFucyBiZWZvcmUgcHJvY2Vzc2luZyBpbiBTREsgbWV0YWRhdGEsXG4gICAgICAgIC8vIHNvIHdlIGNhbiBjb21wYXJlIGl0IGFmdGVyd2FyZHMgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IHNwYW5zIHdlcmUgZHJvcHBlZFxuICAgICAgICBjb25zdCBzcGFuQ291bnRCZWZvcmUgPSBwcm9jZXNzZWRFdmVudC5zcGFucy5sZW5ndGg7XG4gICAgICAgIHByb2Nlc3NlZEV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHtcbiAgICAgICAgICAuLi5ldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgICAgICAgc3BhbkNvdW50QmVmb3JlUHJvY2Vzc2luZzogc3BhbkNvdW50QmVmb3JlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJlZm9yZVNlbmRUcmFuc2FjdGlvbihwcm9jZXNzZWRFdmVudCAsIGhpbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9jZXNzZWRFdmVudDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvckV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzVHJhbnNhY3Rpb25FdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ3RyYW5zYWN0aW9uJztcbn1cblxuLyoqIEV4dHJhY3QgdHJhY2UgaW5mb3JtYXRpb24gZnJvbSBzY29wZSAqL1xuZnVuY3Rpb24gX2dldFRyYWNlSW5mb0Zyb21TY29wZShcbiAgY2xpZW50LFxuICBzY29wZSxcbikge1xuICBpZiAoIXNjb3BlKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gIH1cblxuICByZXR1cm4gd2l0aFNjb3BlKHNjb3BlLCAoKSA9PiB7XG4gICAgY29uc3Qgc3BhbiA9IGdldEFjdGl2ZVNwYW4oKTtcbiAgICBjb25zdCB0cmFjZUNvbnRleHQgPSBzcGFuID8gc3BhblRvVHJhY2VDb250ZXh0KHNwYW4pIDogZ2V0VHJhY2VDb250ZXh0RnJvbVNjb3BlKHNjb3BlKTtcbiAgICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gc3BhblxuICAgICAgPyBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbilcbiAgICAgIDogZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TY29wZShjbGllbnQsIHNjb3BlKTtcbiAgICByZXR1cm4gW2R5bmFtaWNTYW1wbGluZ0NvbnRleHQsIHRyYWNlQ29udGV4dF07XG4gIH0pO1xufVxuXG5leHBvcnQgeyBCYXNlQ2xpZW50LCBDbGllbnQsIF9nZXRUcmFjZUluZm9Gcm9tU2NvcGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/client.js\n"));
- `./frontend/.next/static/chunks/main-app.js:986` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requestDataIntegration: () => (/* binding */ requestDataIntegration)\n/* harmony export */ });\n/* harmony import */ var _integration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../integration.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/integration.js\");\n/* harmony import */ var _utils_cookie_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cookie.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/cookie.js\");\n/* harmony import */ var _vendor_getIpAddress_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../vendor/getIpAddress.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/vendor/getIpAddress.js\");\n\n\n\n\n// TODO(v10): Change defaults based on `sendDefaultPii`\nconst DEFAULT_INCLUDE = {\n  cookies: true,\n  data: true,\n  headers: true,\n  query_string: true,\n  url: true,\n};\n\nconst INTEGRATION_NAME = 'RequestData';\n\nconst _requestDataIntegration = ((options = {}) => {\n  const include = {\n    ...DEFAULT_INCLUDE,\n    ...options.include,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    processEvent(event, _hint, client) {\n      const { sdkProcessingMetadata = {} } = event;\n      const { normalizedRequest, ipAddress } = sdkProcessingMetadata;\n\n      const includeWithDefaultPiiApplied = {\n        ...include,\n        ip: include.ip ?? client.getOptions().sendDefaultPii,\n      };\n\n      if (normalizedRequest) {\n        addNormalizedRequestDataToEvent(event, normalizedRequest, { ipAddress }, includeWithDefaultPiiApplied);\n      }\n\n      return event;\n    },\n  };\n}) ;\n\n/**\n * Add data about a request to an event. Primarily for use in Node-based SDKs, but included in `@sentry/core`\n * so it can be used in cross-platform SDKs like `@sentry/nextjs`.\n */\nconst requestDataIntegration = (0,_integration_js__WEBPACK_IMPORTED_MODULE_0__.defineIntegration)(_requestDataIntegration);\n\n/**\n * Add already normalized request data to an event.\n * This mutates the passed in event.\n */\nfunction addNormalizedRequestDataToEvent(\n  event,\n  req,\n  // Data that should not go into `event.request` but is somehow related to requests\n  additionalData,\n  include,\n) {\n  event.request = {\n    ...event.request,\n    ...extractNormalizedRequestData(req, include),\n  };\n\n  if (include.ip) {\n    const ip = (req.headers && (0,_vendor_getIpAddress_js__WEBPACK_IMPORTED_MODULE_2__.getClientIPAddress)(req.headers)) || additionalData.ipAddress;\n    if (ip) {\n      event.user = {\n        ...event.user,\n        ip_address: ip,\n      };\n    }\n  }\n}\n\nfunction extractNormalizedRequestData(\n  normalizedRequest,\n  include,\n) {\n  const requestData = {};\n  const headers = { ...normalizedRequest.headers };\n\n  if (include.headers) {\n    requestData.headers = headers;\n\n    // Remove the Cookie header in case cookie data should not be included in the event\n    if (!include.cookies) {\n      delete (headers ).cookie;\n    }\n\n    // Remove IP headers in case IP data should not be included in the event\n    if (!include.ip) {\n      _vendor_getIpAddress_js__WEBPACK_IMPORTED_MODULE_2__.ipHeaderNames.forEach(ipHeaderName => {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete (headers )[ipHeaderName];\n      });\n    }\n  }\n\n  requestData.method = normalizedRequest.method;\n\n  if (include.url) {\n    requestData.url = normalizedRequest.url;\n  }\n\n  if (include.cookies) {\n    const cookies = normalizedRequest.cookies || (headers?.cookie ? (0,_utils_cookie_js__WEBPACK_IMPORTED_MODULE_1__.parseCookie)(headers.cookie) : undefined);\n    requestData.cookies = cookies || {};\n  }\n\n  if (include.query_string) {\n    requestData.query_string = normalizedRequest.query_string;\n  }\n\n  if (include.data) {\n    requestData.data = normalizedRequest.data;\n  }\n\n  return requestData;\n}\n\n\n//# sourceMappingURL=requestdata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2ludGVncmF0aW9ucy9yZXF1ZXN0ZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNEO0FBQ0w7QUFDNkI7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsK0JBQStCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrRUFBaUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiwyRUFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGtFQUFhO0FBQ25CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsNkRBQVc7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWtDO0FBQ2xDIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrY29yZUA5LjQ2LjAvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vaW50ZWdyYXRpb25zL3JlcXVlc3RkYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZUludGVncmF0aW9uIH0gZnJvbSAnLi4vaW50ZWdyYXRpb24uanMnO1xuaW1wb3J0IHsgcGFyc2VDb29raWUgfSBmcm9tICcuLi91dGlscy9jb29raWUuanMnO1xuaW1wb3J0IHsgZ2V0Q2xpZW50SVBBZGRyZXNzLCBpcEhlYWRlck5hbWVzIH0gZnJvbSAnLi4vdmVuZG9yL2dldElwQWRkcmVzcy5qcyc7XG5cbi8vIFRPRE8odjEwKTogQ2hhbmdlIGRlZmF1bHRzIGJhc2VkIG9uIGBzZW5kRGVmYXVsdFBpaWBcbmNvbnN0IERFRkFVTFRfSU5DTFVERSA9IHtcbiAgY29va2llczogdHJ1ZSxcbiAgZGF0YTogdHJ1ZSxcbiAgaGVhZGVyczogdHJ1ZSxcbiAgcXVlcnlfc3RyaW5nOiB0cnVlLFxuICB1cmw6IHRydWUsXG59O1xuXG5jb25zdCBJTlRFR1JBVElPTl9OQU1FID0gJ1JlcXVlc3REYXRhJztcblxuY29uc3QgX3JlcXVlc3REYXRhSW50ZWdyYXRpb24gPSAoKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBpbmNsdWRlID0ge1xuICAgIC4uLkRFRkFVTFRfSU5DTFVERSxcbiAgICAuLi5vcHRpb25zLmluY2x1ZGUsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBJTlRFR1JBVElPTl9OQU1FLFxuICAgIHByb2Nlc3NFdmVudChldmVudCwgX2hpbnQsIGNsaWVudCkge1xuICAgICAgY29uc3QgeyBzZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7fSB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCB7IG5vcm1hbGl6ZWRSZXF1ZXN0LCBpcEFkZHJlc3MgfSA9IHNka1Byb2Nlc3NpbmdNZXRhZGF0YTtcblxuICAgICAgY29uc3QgaW5jbHVkZVdpdGhEZWZhdWx0UGlpQXBwbGllZCA9IHtcbiAgICAgICAgLi4uaW5jbHVkZSxcbiAgICAgICAgaXA6IGluY2x1ZGUuaXAgPz8gY2xpZW50LmdldE9wdGlvbnMoKS5zZW5kRGVmYXVsdFBpaSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChub3JtYWxpemVkUmVxdWVzdCkge1xuICAgICAgICBhZGROb3JtYWxpemVkUmVxdWVzdERhdGFUb0V2ZW50KGV2ZW50LCBub3JtYWxpemVkUmVxdWVzdCwgeyBpcEFkZHJlc3MgfSwgaW5jbHVkZVdpdGhEZWZhdWx0UGlpQXBwbGllZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICB9O1xufSkgO1xuXG4vKipcbiAqIEFkZCBkYXRhIGFib3V0IGEgcmVxdWVzdCB0byBhbiBldmVudC4gUHJpbWFyaWx5IGZvciB1c2UgaW4gTm9kZS1iYXNlZCBTREtzLCBidXQgaW5jbHVkZWQgaW4gYEBzZW50cnkvY29yZWBcbiAqIHNvIGl0IGNhbiBiZSB1c2VkIGluIGNyb3NzLXBsYXRmb3JtIFNES3MgbGlrZSBgQHNlbnRyeS9uZXh0anNgLlxuICovXG5jb25zdCByZXF1ZXN0RGF0YUludGVncmF0aW9uID0gZGVmaW5lSW50ZWdyYXRpb24oX3JlcXVlc3REYXRhSW50ZWdyYXRpb24pO1xuXG4vKipcbiAqIEFkZCBhbHJlYWR5IG5vcm1hbGl6ZWQgcmVxdWVzdCBkYXRhIHRvIGFuIGV2ZW50LlxuICogVGhpcyBtdXRhdGVzIHRoZSBwYXNzZWQgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGFkZE5vcm1hbGl6ZWRSZXF1ZXN0RGF0YVRvRXZlbnQoXG4gIGV2ZW50LFxuICByZXEsXG4gIC8vIERhdGEgdGhhdCBzaG91bGQgbm90IGdvIGludG8gYGV2ZW50LnJlcXVlc3RgIGJ1dCBpcyBzb21laG93IHJlbGF0ZWQgdG8gcmVxdWVzdHNcbiAgYWRkaXRpb25hbERhdGEsXG4gIGluY2x1ZGUsXG4pIHtcbiAgZXZlbnQucmVxdWVzdCA9IHtcbiAgICAuLi5ldmVudC5yZXF1ZXN0LFxuICAgIC4uLmV4dHJhY3ROb3JtYWxpemVkUmVxdWVzdERhdGEocmVxLCBpbmNsdWRlKSxcbiAgfTtcblxuICBpZiAoaW5jbHVkZS5pcCkge1xuICAgIGNvbnN0IGlwID0gKHJlcS5oZWFkZXJzICYmIGdldENsaWVudElQQWRkcmVzcyhyZXEuaGVhZGVycykpIHx8IGFkZGl0aW9uYWxEYXRhLmlwQWRkcmVzcztcbiAgICBpZiAoaXApIHtcbiAgICAgIGV2ZW50LnVzZXIgPSB7XG4gICAgICAgIC4uLmV2ZW50LnVzZXIsXG4gICAgICAgIGlwX2FkZHJlc3M6IGlwLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdE5vcm1hbGl6ZWRSZXF1ZXN0RGF0YShcbiAgbm9ybWFsaXplZFJlcXVlc3QsXG4gIGluY2x1ZGUsXG4pIHtcbiAgY29uc3QgcmVxdWVzdERhdGEgPSB7fTtcbiAgY29uc3QgaGVhZGVycyA9IHsgLi4ubm9ybWFsaXplZFJlcXVlc3QuaGVhZGVycyB9O1xuXG4gIGlmIChpbmNsdWRlLmhlYWRlcnMpIHtcbiAgICByZXF1ZXN0RGF0YS5oZWFkZXJzID0gaGVhZGVycztcblxuICAgIC8vIFJlbW92ZSB0aGUgQ29va2llIGhlYWRlciBpbiBjYXNlIGNvb2tpZSBkYXRhIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIGV2ZW50XG4gICAgaWYgKCFpbmNsdWRlLmNvb2tpZXMpIHtcbiAgICAgIGRlbGV0ZSAoaGVhZGVycyApLmNvb2tpZTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgSVAgaGVhZGVycyBpbiBjYXNlIElQIGRhdGEgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgZXZlbnRcbiAgICBpZiAoIWluY2x1ZGUuaXApIHtcbiAgICAgIGlwSGVhZGVyTmFtZXMuZm9yRWFjaChpcEhlYWRlck5hbWUgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgIGRlbGV0ZSAoaGVhZGVycyApW2lwSGVhZGVyTmFtZV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0RGF0YS5tZXRob2QgPSBub3JtYWxpemVkUmVxdWVzdC5tZXRob2Q7XG5cbiAgaWYgKGluY2x1ZGUudXJsKSB7XG4gICAgcmVxdWVzdERhdGEudXJsID0gbm9ybWFsaXplZFJlcXVlc3QudXJsO1xuICB9XG5cbiAgaWYgKGluY2x1ZGUuY29va2llcykge1xuICAgIGNvbnN0IGNvb2tpZXMgPSBub3JtYWxpemVkUmVxdWVzdC5jb29raWVzIHx8IChoZWFkZXJzPy5jb29raWUgPyBwYXJzZUNvb2tpZShoZWFkZXJzLmNvb2tpZSkgOiB1bmRlZmluZWQpO1xuICAgIHJlcXVlc3REYXRhLmNvb2tpZXMgPSBjb29raWVzIHx8IHt9O1xuICB9XG5cbiAgaWYgKGluY2x1ZGUucXVlcnlfc3RyaW5nKSB7XG4gICAgcmVxdWVzdERhdGEucXVlcnlfc3RyaW5nID0gbm9ybWFsaXplZFJlcXVlc3QucXVlcnlfc3RyaW5nO1xuICB9XG5cbiAgaWYgKGluY2x1ZGUuZGF0YSkge1xuICAgIHJlcXVlc3REYXRhLmRhdGEgPSBub3JtYWxpemVkUmVxdWVzdC5kYXRhO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVlc3REYXRhO1xufVxuXG5leHBvcnQgeyByZXF1ZXN0RGF0YUludGVncmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0ZGF0YS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/integrations/requestdata.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1019` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thirdPartyErrorFilterIntegration: () => (/* binding */ thirdPartyErrorFilterIntegration)\n/* harmony export */ });\n/* harmony import */ var _integration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../integration.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/integration.js\");\n/* harmony import */ var _metadata_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../metadata.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/metadata.js\");\n/* harmony import */ var _utils_envelope_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/envelope.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/envelope.js\");\n/* harmony import */ var _utils_stacktrace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/stacktrace.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/stacktrace.js\");\n\n\n\n\n\n/**\n * This integration allows you to filter out, or tag error events that do not come from user code marked with a bundle key via the Sentry bundler plugins.\n */\nconst thirdPartyErrorFilterIntegration = (0,_integration_js__WEBPACK_IMPORTED_MODULE_0__.defineIntegration)((options) => {\n  return {\n    name: 'ThirdPartyErrorsFilter',\n    setup(client) {\n      // We need to strip metadata from stack frames before sending them to Sentry since these are client side only.\n      // TODO(lforst): Move this cleanup logic into a more central place in the SDK.\n      client.on('beforeEnvelope', envelope => {\n        (0,_utils_envelope_js__WEBPACK_IMPORTED_MODULE_2__.forEachEnvelopeItem)(envelope, (item, type) => {\n          if (type === 'event') {\n            const event = Array.isArray(item) ? (item )[1] : undefined;\n\n            if (event) {\n              (0,_metadata_js__WEBPACK_IMPORTED_MODULE_1__.stripMetadataFromStackFrames)(event);\n              item[1] = event;\n            }\n          }\n        });\n      });\n\n      client.on('applyFrameMetadata', event => {\n        // Only apply stack frame metadata to error events\n        if (event.type) {\n          return;\n        }\n\n        const stackParser = client.getOptions().stackParser;\n        (0,_metadata_js__WEBPACK_IMPORTED_MODULE_1__.addMetadataToStackFrames)(stackParser, event);\n      });\n    },\n\n    processEvent(event) {\n      const frameKeys = getBundleKeysForAllFramesWithFilenames(event);\n\n      if (frameKeys) {\n        const arrayMethod =\n          options.behaviour === 'drop-error-if-contains-third-party-frames' ||\n          options.behaviour === 'apply-tag-if-contains-third-party-frames'\n            ? 'some'\n            : 'every';\n\n        const behaviourApplies = frameKeys[arrayMethod](keys => !keys.some(key => options.filterKeys.includes(key)));\n\n        if (behaviourApplies) {\n          const shouldDrop =\n            options.behaviour === 'drop-error-if-contains-third-party-frames' ||\n            options.behaviour === 'drop-error-if-exclusively-contains-third-party-frames';\n          if (shouldDrop) {\n            return null;\n          } else {\n            event.tags = {\n              ...event.tags,\n              third_party_code: true,\n            };\n          }\n        }\n      }\n\n      return event;\n    },\n  };\n});\n\nfunction getBundleKeysForAllFramesWithFilenames(event) {\n  const frames = (0,_utils_stacktrace_js__WEBPACK_IMPORTED_MODULE_3__.getFramesFromEvent)(event);\n\n  if (!frames) {\n    return undefined;\n  }\n\n  return (\n    frames\n      // Exclude frames without a filename since these are likely native code or built-ins\n      .filter(frame => !!frame.filename)\n      .map(frame => {\n        if (frame.module_metadata) {\n          return Object.keys(frame.module_metadata)\n            .filter(key => key.startsWith(BUNDLER_PLUGIN_APP_KEY_PREFIX))\n            .map(key => key.slice(BUNDLER_PLUGIN_APP_KEY_PREFIX.length));\n        }\n        return [];\n      })\n  );\n}\n\nconst BUNDLER_PLUGIN_APP_KEY_PREFIX = '_sentryBundlerPluginAppKey:';\n\n\n//# sourceMappingURL=third-party-errors-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL2ludGVncmF0aW9ucy90aGlyZC1wYXJ0eS1lcnJvcnMtZmlsdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQ2tDO0FBQzdCO0FBQ0M7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1RUFBbUI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBLGNBQWMsMEVBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHNFQUF3QjtBQUNoQyxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUJBQWlCLHdFQUFrQjs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFNEM7QUFDNUMiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStjb3JlQDkuNDYuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9pbnRlZ3JhdGlvbnMvdGhpcmQtcGFydHktZXJyb3JzLWZpbHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVJbnRlZ3JhdGlvbiB9IGZyb20gJy4uL2ludGVncmF0aW9uLmpzJztcbmltcG9ydCB7IGFkZE1ldGFkYXRhVG9TdGFja0ZyYW1lcywgc3RyaXBNZXRhZGF0YUZyb21TdGFja0ZyYW1lcyB9IGZyb20gJy4uL21ldGFkYXRhLmpzJztcbmltcG9ydCB7IGZvckVhY2hFbnZlbG9wZUl0ZW0gfSBmcm9tICcuLi91dGlscy9lbnZlbG9wZS5qcyc7XG5pbXBvcnQgeyBnZXRGcmFtZXNGcm9tRXZlbnQgfSBmcm9tICcuLi91dGlscy9zdGFja3RyYWNlLmpzJztcblxuLyoqXG4gKiBUaGlzIGludGVncmF0aW9uIGFsbG93cyB5b3UgdG8gZmlsdGVyIG91dCwgb3IgdGFnIGVycm9yIGV2ZW50cyB0aGF0IGRvIG5vdCBjb21lIGZyb20gdXNlciBjb2RlIG1hcmtlZCB3aXRoIGEgYnVuZGxlIGtleSB2aWEgdGhlIFNlbnRyeSBidW5kbGVyIHBsdWdpbnMuXG4gKi9cbmNvbnN0IHRoaXJkUGFydHlFcnJvckZpbHRlckludGVncmF0aW9uID0gZGVmaW5lSW50ZWdyYXRpb24oKG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnVGhpcmRQYXJ0eUVycm9yc0ZpbHRlcicsXG4gICAgc2V0dXAoY2xpZW50KSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHN0cmlwIG1ldGFkYXRhIGZyb20gc3RhY2sgZnJhbWVzIGJlZm9yZSBzZW5kaW5nIHRoZW0gdG8gU2VudHJ5IHNpbmNlIHRoZXNlIGFyZSBjbGllbnQgc2lkZSBvbmx5LlxuICAgICAgLy8gVE9ETyhsZm9yc3QpOiBNb3ZlIHRoaXMgY2xlYW51cCBsb2dpYyBpbnRvIGEgbW9yZSBjZW50cmFsIHBsYWNlIGluIHRoZSBTREsuXG4gICAgICBjbGllbnQub24oJ2JlZm9yZUVudmVsb3BlJywgZW52ZWxvcGUgPT4ge1xuICAgICAgICBmb3JFYWNoRW52ZWxvcGVJdGVtKGVudmVsb3BlLCAoaXRlbSwgdHlwZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyAoaXRlbSApWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgc3RyaXBNZXRhZGF0YUZyb21TdGFja0ZyYW1lcyhldmVudCk7XG4gICAgICAgICAgICAgIGl0ZW1bMV0gPSBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNsaWVudC5vbignYXBwbHlGcmFtZU1ldGFkYXRhJywgZXZlbnQgPT4ge1xuICAgICAgICAvLyBPbmx5IGFwcGx5IHN0YWNrIGZyYW1lIG1ldGFkYXRhIHRvIGVycm9yIGV2ZW50c1xuICAgICAgICBpZiAoZXZlbnQudHlwZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YWNrUGFyc2VyID0gY2xpZW50LmdldE9wdGlvbnMoKS5zdGFja1BhcnNlcjtcbiAgICAgICAgYWRkTWV0YWRhdGFUb1N0YWNrRnJhbWVzKHN0YWNrUGFyc2VyLCBldmVudCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcHJvY2Vzc0V2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCBmcmFtZUtleXMgPSBnZXRCdW5kbGVLZXlzRm9yQWxsRnJhbWVzV2l0aEZpbGVuYW1lcyhldmVudCk7XG5cbiAgICAgIGlmIChmcmFtZUtleXMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlNZXRob2QgPVxuICAgICAgICAgIG9wdGlvbnMuYmVoYXZpb3VyID09PSAnZHJvcC1lcnJvci1pZi1jb250YWlucy10aGlyZC1wYXJ0eS1mcmFtZXMnIHx8XG4gICAgICAgICAgb3B0aW9ucy5iZWhhdmlvdXIgPT09ICdhcHBseS10YWctaWYtY29udGFpbnMtdGhpcmQtcGFydHktZnJhbWVzJ1xuICAgICAgICAgICAgPyAnc29tZSdcbiAgICAgICAgICAgIDogJ2V2ZXJ5JztcblxuICAgICAgICBjb25zdCBiZWhhdmlvdXJBcHBsaWVzID0gZnJhbWVLZXlzW2FycmF5TWV0aG9kXShrZXlzID0+ICFrZXlzLnNvbWUoa2V5ID0+IG9wdGlvbnMuZmlsdGVyS2V5cy5pbmNsdWRlcyhrZXkpKSk7XG5cbiAgICAgICAgaWYgKGJlaGF2aW91ckFwcGxpZXMpIHtcbiAgICAgICAgICBjb25zdCBzaG91bGREcm9wID1cbiAgICAgICAgICAgIG9wdGlvbnMuYmVoYXZpb3VyID09PSAnZHJvcC1lcnJvci1pZi1jb250YWlucy10aGlyZC1wYXJ0eS1mcmFtZXMnIHx8XG4gICAgICAgICAgICBvcHRpb25zLmJlaGF2aW91ciA9PT0gJ2Ryb3AtZXJyb3ItaWYtZXhjbHVzaXZlbHktY29udGFpbnMtdGhpcmQtcGFydHktZnJhbWVzJztcbiAgICAgICAgICBpZiAoc2hvdWxkRHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50LnRhZ3MgPSB7XG4gICAgICAgICAgICAgIC4uLmV2ZW50LnRhZ3MsXG4gICAgICAgICAgICAgIHRoaXJkX3BhcnR5X2NvZGU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfSxcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRCdW5kbGVLZXlzRm9yQWxsRnJhbWVzV2l0aEZpbGVuYW1lcyhldmVudCkge1xuICBjb25zdCBmcmFtZXMgPSBnZXRGcmFtZXNGcm9tRXZlbnQoZXZlbnQpO1xuXG4gIGlmICghZnJhbWVzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgZnJhbWVzXG4gICAgICAvLyBFeGNsdWRlIGZyYW1lcyB3aXRob3V0IGEgZmlsZW5hbWUgc2luY2UgdGhlc2UgYXJlIGxpa2VseSBuYXRpdmUgY29kZSBvciBidWlsdC1pbnNcbiAgICAgIC5maWx0ZXIoZnJhbWUgPT4gISFmcmFtZS5maWxlbmFtZSlcbiAgICAgIC5tYXAoZnJhbWUgPT4ge1xuICAgICAgICBpZiAoZnJhbWUubW9kdWxlX21ldGFkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGZyYW1lLm1vZHVsZV9tZXRhZGF0YSlcbiAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKEJVTkRMRVJfUExVR0lOX0FQUF9LRVlfUFJFRklYKSlcbiAgICAgICAgICAgIC5tYXAoa2V5ID0+IGtleS5zbGljZShCVU5ETEVSX1BMVUdJTl9BUFBfS0VZX1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9KVxuICApO1xufVxuXG5jb25zdCBCVU5ETEVSX1BMVUdJTl9BUFBfS0VZX1BSRUZJWCA9ICdfc2VudHJ5QnVuZGxlclBsdWdpbkFwcEtleTonO1xuXG5leHBvcnQgeyB0aGlyZFBhcnR5RXJyb3JGaWx0ZXJJbnRlZ3JhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhpcmQtcGFydHktZXJyb3JzLWZpbHRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/integrations/third-party-errors-filter.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1140` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServerRuntimeClient: () => (/* binding */ ServerRuntimeClient)\n/* harmony export */ });\n/* harmony import */ var _checkin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./checkin.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/checkin.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/client.js\");\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./currentScopes.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./debug-build.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/debug-build.js\");\n/* harmony import */ var _logs_exports_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logs/exports.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/logs/exports.js\");\n/* harmony import */ var _tracing_errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tracing/errors.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/tracing/errors.js\");\n/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/is.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/is.js\");\n/* harmony import */ var _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/debug-logger.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/debug-logger.js\");\n/* harmony import */ var _utils_misc_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/misc.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/misc.js\");\n/* harmony import */ var _utils_eventbuilder_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/eventbuilder.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/eventbuilder.js\");\n/* harmony import */ var _utils_syncpromise_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/syncpromise.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/syncpromise.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n// TODO: Make this configurable\nconst DEFAULT_LOG_FLUSH_INTERVAL = 5000;\n\n/**\n * The Sentry Server Runtime Client SDK.\n */\nclass ServerRuntimeClient\n\n extends _client_js__WEBPACK_IMPORTED_MODULE_1__.Client {\n\n  /**\n   * Creates a new Edge SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n   constructor(options) {\n    // Server clients always support tracing\n    (0,_tracing_errors_js__WEBPACK_IMPORTED_MODULE_5__.registerSpanErrorInstrumentation)();\n\n    super(options);\n\n    this._logWeight = 0;\n\n    // eslint-disable-next-line deprecation/deprecation\n    const shouldEnableLogs = this._options.enableLogs ?? this._options._experiments?.enableLogs;\n    if (shouldEnableLogs) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const client = this;\n\n      client.on('flushLogs', () => {\n        client._logWeight = 0;\n        clearTimeout(client._logFlushIdleTimeout);\n      });\n\n      client.on('afterCaptureLog', log => {\n        client._logWeight += estimateLogSizeInBytes(log);\n\n        // We flush the logs buffer if it exceeds 0.8 MB\n        // The log weight is a rough estimate, so we flush way before\n        // the payload gets too big.\n        if (client._logWeight >= 800000) {\n          (0,_logs_exports_js__WEBPACK_IMPORTED_MODULE_4__._INTERNAL_flushLogsBuffer)(client);\n        } else {\n          // start an idle timeout to flush the logs buffer if no logs are captured for a while\n          client._logFlushIdleTimeout = setTimeout(() => {\n            (0,_logs_exports_js__WEBPACK_IMPORTED_MODULE_4__._INTERNAL_flushLogsBuffer)(client);\n          }, DEFAULT_LOG_FLUSH_INTERVAL);\n        }\n      });\n\n      client.on('flush', () => {\n        (0,_logs_exports_js__WEBPACK_IMPORTED_MODULE_4__._INTERNAL_flushLogsBuffer)(client);\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromException(exception, hint) {\n    const event = (0,_utils_eventbuilder_js__WEBPACK_IMPORTED_MODULE_9__.eventFromUnknownInput)(this, this._options.stackParser, exception, hint);\n    event.level = 'error';\n\n    return (0,_utils_syncpromise_js__WEBPACK_IMPORTED_MODULE_10__.resolvedSyncPromise)(event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromMessage(\n    message,\n    level = 'info',\n    hint,\n  ) {\n    return (0,_utils_syncpromise_js__WEBPACK_IMPORTED_MODULE_10__.resolvedSyncPromise)(\n      (0,_utils_eventbuilder_js__WEBPACK_IMPORTED_MODULE_9__.eventFromMessage)(this._options.stackParser, message, level, hint, this._options.attachStacktrace),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureException(exception, hint, scope) {\n    setCurrentRequestSessionErroredOrCrashed(hint);\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint, scope) {\n    // If the event is of type Exception, then a request session should be captured\n    const isException = !event.type && event.exception?.values && event.exception.values.length > 0;\n    if (isException) {\n      setCurrentRequestSessionErroredOrCrashed(hint);\n    }\n\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   */\n   captureCheckIn(checkIn, monitorConfig, scope) {\n    const id = 'checkInId' in checkIn && checkIn.checkInId ? checkIn.checkInId : (0,_utils_misc_js__WEBPACK_IMPORTED_MODULE_8__.uuid4)();\n    if (!this._isEnabled()) {\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_7__.debug.warn('SDK not enabled, will not capture check-in.');\n      return id;\n    }\n\n    const options = this.getOptions();\n    const { release, environment, tunnel } = options;\n\n    const serializedCheckIn = {\n      check_in_id: id,\n      monitor_slug: checkIn.monitorSlug,\n      status: checkIn.status,\n      release,\n      environment,\n    };\n\n    if ('duration' in checkIn) {\n      serializedCheckIn.duration = checkIn.duration;\n    }\n\n    if (monitorConfig) {\n      serializedCheckIn.monitor_config = {\n        schedule: monitorConfig.schedule,\n        checkin_margin: monitorConfig.checkinMargin,\n        max_runtime: monitorConfig.maxRuntime,\n        timezone: monitorConfig.timezone,\n        failure_issue_threshold: monitorConfig.failureIssueThreshold,\n        recovery_threshold: monitorConfig.recoveryThreshold,\n      };\n    }\n\n    const [dynamicSamplingContext, traceContext] = (0,_client_js__WEBPACK_IMPORTED_MODULE_1__._getTraceInfoFromScope)(this, scope);\n    if (traceContext) {\n      serializedCheckIn.contexts = {\n        trace: traceContext,\n      };\n    }\n\n    const envelope = (0,_checkin_js__WEBPACK_IMPORTED_MODULE_0__.createCheckInEnvelope)(\n      serializedCheckIn,\n      dynamicSamplingContext,\n      this.getSdkMetadata(),\n      tunnel,\n      this.getDsn(),\n    );\n\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _utils_debug_logger_js__WEBPACK_IMPORTED_MODULE_7__.debug.log('Sending checkin:', checkIn.monitorSlug, checkIn.status);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n\n    return id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   _prepareEvent(\n    event,\n    hint,\n    currentScope,\n    isolationScope,\n  ) {\n    if (this._options.platform) {\n      event.platform = event.platform || this._options.platform;\n    }\n\n    if (this._options.runtime) {\n      event.contexts = {\n        ...event.contexts,\n        runtime: event.contexts?.runtime || this._options.runtime,\n      };\n    }\n\n    if (this._options.serverName) {\n      event.server_name = event.server_name || this._options.serverName;\n    }\n\n    return super._prepareEvent(event, hint, currentScope, isolationScope);\n  }\n}\n\nfunction setCurrentRequestSessionErroredOrCrashed(eventHint) {\n  const requestSession = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_2__.getIsolationScope)().getScopeData().sdkProcessingMetadata.requestSession;\n  if (requestSession) {\n    // We mutate instead of doing `setSdkProcessingMetadata` because the http integration stores away a particular\n    // isolationScope. If that isolation scope is forked, setting the processing metadata here will not mutate the\n    // original isolation scope that the http integration stored away.\n    const isHandledException = eventHint?.mechanism?.handled ?? true;\n    // A request session can go from \"errored\" -> \"crashed\" but not \"crashed\" -> \"errored\".\n    // Crashed (unhandled exception) is worse than errored (handled exception).\n    if (isHandledException && requestSession.status !== 'crashed') {\n      requestSession.status = 'errored';\n    } else if (!isHandledException) {\n      requestSession.status = 'crashed';\n    }\n  }\n}\n\n/**\n * Estimate the size of a log in bytes.\n *\n * @param log - The log to estimate the size of.\n * @returns The estimated size of the log in bytes.\n */\nfunction estimateLogSizeInBytes(log) {\n  let weight = 0;\n\n  // Estimate byte size of 2 bytes per character. This is a rough estimate JS strings are stored as UTF-16.\n  if (log.message) {\n    weight += log.message.length * 2;\n  }\n\n  if (log.attributes) {\n    Object.values(log.attributes).forEach(value => {\n      if (Array.isArray(value)) {\n        weight += value.length * estimatePrimitiveSizeInBytes(value[0]);\n      } else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_6__.isPrimitive)(value)) {\n        weight += estimatePrimitiveSizeInBytes(value);\n      } else {\n        // For objects values, we estimate the size of the object as 100 bytes\n        weight += 100;\n      }\n    });\n  }\n\n  return weight;\n}\n\nfunction estimatePrimitiveSizeInBytes(value) {\n  if (typeof value === 'string') {\n    return value.length * 2;\n  } else if (typeof value === 'number') {\n    return 8;\n  } else if (typeof value === 'boolean') {\n    return 4;\n  }\n\n  return 0;\n}\n\n\n//# sourceMappingURL=server-runtime-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3NlcnZlci1ydW50aW1lLWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDUTtBQUNOO0FBQ1I7QUFDZTtBQUNTO0FBQzNCO0FBQ0k7QUFDUjtBQUMwQztBQUNyQjs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhDQUFNOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0ZBQWdDOztBQUVwQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkVBQXlCO0FBQ25DLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWSwyRUFBeUI7QUFDckMsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLFFBQVEsMkVBQXlCO0FBQ2pDLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZFQUFxQjtBQUN2Qzs7QUFFQSxXQUFXLDJFQUFtQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyRUFBbUI7QUFDOUIsTUFBTSx3RUFBZ0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHFEQUFLO0FBQ3RGO0FBQ0EsTUFBTSx3REFBVyxJQUFJLHlEQUFLO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtCQUErQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxrRUFBc0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsa0VBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLHdEQUFXLElBQUkseURBQUs7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixvRUFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVMseURBQVc7QUFDNUI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFK0I7QUFDL0IiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStjb3JlQDkuNDYuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS9zZXJ2ZXItcnVudGltZS1jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2hlY2tJbkVudmVsb3BlIH0gZnJvbSAnLi9jaGVja2luLmpzJztcbmltcG9ydCB7IENsaWVudCwgX2dldFRyYWNlSW5mb0Zyb21TY29wZSB9IGZyb20gJy4vY2xpZW50LmpzJztcbmltcG9ydCB7IGdldElzb2xhdGlvblNjb3BlIH0gZnJvbSAnLi9jdXJyZW50U2NvcGVzLmpzJztcbmltcG9ydCB7IERFQlVHX0JVSUxEIH0gZnJvbSAnLi9kZWJ1Zy1idWlsZC5qcyc7XG5pbXBvcnQgeyBfSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyIH0gZnJvbSAnLi9sb2dzL2V4cG9ydHMuanMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJTcGFuRXJyb3JJbnN0cnVtZW50YXRpb24gfSBmcm9tICcuL3RyYWNpbmcvZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzUHJpbWl0aXZlIH0gZnJvbSAnLi91dGlscy9pcy5qcyc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vdXRpbHMvZGVidWctbG9nZ2VyLmpzJztcbmltcG9ydCB7IHV1aWQ0IH0gZnJvbSAnLi91dGlscy9taXNjLmpzJztcbmltcG9ydCB7IGV2ZW50RnJvbVVua25vd25JbnB1dCwgZXZlbnRGcm9tTWVzc2FnZSB9IGZyb20gJy4vdXRpbHMvZXZlbnRidWlsZGVyLmpzJztcbmltcG9ydCB7IHJlc29sdmVkU3luY1Byb21pc2UgfSBmcm9tICcuL3V0aWxzL3N5bmNwcm9taXNlLmpzJztcblxuLy8gVE9ETzogTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuY29uc3QgREVGQVVMVF9MT0dfRkxVU0hfSU5URVJWQUwgPSA1MDAwO1xuXG4vKipcbiAqIFRoZSBTZW50cnkgU2VydmVyIFJ1bnRpbWUgQ2xpZW50IFNESy5cbiAqL1xuY2xhc3MgU2VydmVyUnVudGltZUNsaWVudFxuXG4gZXh0ZW5kcyBDbGllbnQge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEVkZ2UgU0RLIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgU0RLLlxuICAgKi9cbiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvLyBTZXJ2ZXIgY2xpZW50cyBhbHdheXMgc3VwcG9ydCB0cmFjaW5nXG4gICAgcmVnaXN0ZXJTcGFuRXJyb3JJbnN0cnVtZW50YXRpb24oKTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fbG9nV2VpZ2h0ID0gMDtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIGNvbnN0IHNob3VsZEVuYWJsZUxvZ3MgPSB0aGlzLl9vcHRpb25zLmVuYWJsZUxvZ3MgPz8gdGhpcy5fb3B0aW9ucy5fZXhwZXJpbWVudHM/LmVuYWJsZUxvZ3M7XG4gICAgaWYgKHNob3VsZEVuYWJsZUxvZ3MpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgY29uc3QgY2xpZW50ID0gdGhpcztcblxuICAgICAgY2xpZW50Lm9uKCdmbHVzaExvZ3MnLCAoKSA9PiB7XG4gICAgICAgIGNsaWVudC5fbG9nV2VpZ2h0ID0gMDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNsaWVudC5fbG9nRmx1c2hJZGxlVGltZW91dCk7XG4gICAgICB9KTtcblxuICAgICAgY2xpZW50Lm9uKCdhZnRlckNhcHR1cmVMb2cnLCBsb2cgPT4ge1xuICAgICAgICBjbGllbnQuX2xvZ1dlaWdodCArPSBlc3RpbWF0ZUxvZ1NpemVJbkJ5dGVzKGxvZyk7XG5cbiAgICAgICAgLy8gV2UgZmx1c2ggdGhlIGxvZ3MgYnVmZmVyIGlmIGl0IGV4Y2VlZHMgMC44IE1CXG4gICAgICAgIC8vIFRoZSBsb2cgd2VpZ2h0IGlzIGEgcm91Z2ggZXN0aW1hdGUsIHNvIHdlIGZsdXNoIHdheSBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHBheWxvYWQgZ2V0cyB0b28gYmlnLlxuICAgICAgICBpZiAoY2xpZW50Ll9sb2dXZWlnaHQgPj0gODAwMDAwKSB7XG4gICAgICAgICAgX0lOVEVSTkFMX2ZsdXNoTG9nc0J1ZmZlcihjbGllbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN0YXJ0IGFuIGlkbGUgdGltZW91dCB0byBmbHVzaCB0aGUgbG9ncyBidWZmZXIgaWYgbm8gbG9ncyBhcmUgY2FwdHVyZWQgZm9yIGEgd2hpbGVcbiAgICAgICAgICBjbGllbnQuX2xvZ0ZsdXNoSWRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIF9JTlRFUk5BTF9mbHVzaExvZ3NCdWZmZXIoY2xpZW50KTtcbiAgICAgICAgICB9LCBERUZBVUxUX0xPR19GTFVTSF9JTlRFUlZBTCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjbGllbnQub24oJ2ZsdXNoJywgKCkgPT4ge1xuICAgICAgICBfSU5URVJOQUxfZmx1c2hMb2dzQnVmZmVyKGNsaWVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBldmVudEZyb21FeGNlcHRpb24oZXhjZXB0aW9uLCBoaW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudEZyb21Vbmtub3duSW5wdXQodGhpcywgdGhpcy5fb3B0aW9ucy5zdGFja1BhcnNlciwgZXhjZXB0aW9uLCBoaW50KTtcbiAgICBldmVudC5sZXZlbCA9ICdlcnJvcic7XG5cbiAgICByZXR1cm4gcmVzb2x2ZWRTeW5jUHJvbWlzZShldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBldmVudEZyb21NZXNzYWdlKFxuICAgIG1lc3NhZ2UsXG4gICAgbGV2ZWwgPSAnaW5mbycsXG4gICAgaGludCxcbiAgKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkU3luY1Byb21pc2UoXG4gICAgICBldmVudEZyb21NZXNzYWdlKHRoaXMuX29wdGlvbnMuc3RhY2tQYXJzZXIsIG1lc3NhZ2UsIGxldmVsLCBoaW50LCB0aGlzLl9vcHRpb25zLmF0dGFjaFN0YWNrdHJhY2UpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBjYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCwgc2NvcGUpIHtcbiAgICBzZXRDdXJyZW50UmVxdWVzdFNlc3Npb25FcnJvcmVkT3JDcmFzaGVkKGhpbnQpO1xuICAgIHJldHVybiBzdXBlci5jYXB0dXJlRXhjZXB0aW9uKGV4Y2VwdGlvbiwgaGludCwgc2NvcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgY2FwdHVyZUV2ZW50KGV2ZW50LCBoaW50LCBzY29wZSkge1xuICAgIC8vIElmIHRoZSBldmVudCBpcyBvZiB0eXBlIEV4Y2VwdGlvbiwgdGhlbiBhIHJlcXVlc3Qgc2Vzc2lvbiBzaG91bGQgYmUgY2FwdHVyZWRcbiAgICBjb25zdCBpc0V4Y2VwdGlvbiA9ICFldmVudC50eXBlICYmIGV2ZW50LmV4Y2VwdGlvbj8udmFsdWVzICYmIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXMubGVuZ3RoID4gMDtcbiAgICBpZiAoaXNFeGNlcHRpb24pIHtcbiAgICAgIHNldEN1cnJlbnRSZXF1ZXN0U2Vzc2lvbkVycm9yZWRPckNyYXNoZWQoaGludCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmNhcHR1cmVFdmVudChldmVudCwgaGludCwgc2NvcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNyb24gbW9uaXRvciBjaGVjayBpbiBhbmQgc2VuZCBpdCB0byBTZW50cnkuXG4gICAqXG4gICAqIEBwYXJhbSBjaGVja0luIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBhIGNoZWNrIGluLlxuICAgKiBAcGFyYW0gdXBzZXJ0TW9uaXRvckNvbmZpZyBBbiBvcHRpb25hbCBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBtb25pdG9yIGNvbmZpZy4gVXNlIHRoaXMgaWYgeW91IHdhbnRcbiAgICogdG8gY3JlYXRlIGEgbW9uaXRvciBhdXRvbWF0aWNhbGx5IHdoZW4gc2VuZGluZyBhIGNoZWNrIGluLlxuICAgKi9cbiAgIGNhcHR1cmVDaGVja0luKGNoZWNrSW4sIG1vbml0b3JDb25maWcsIHNjb3BlKSB7XG4gICAgY29uc3QgaWQgPSAnY2hlY2tJbklkJyBpbiBjaGVja0luICYmIGNoZWNrSW4uY2hlY2tJbklkID8gY2hlY2tJbi5jaGVja0luSWQgOiB1dWlkNCgpO1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkKCkpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLndhcm4oJ1NESyBub3QgZW5hYmxlZCwgd2lsbCBub3QgY2FwdHVyZSBjaGVjay1pbi4nKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgY29uc3QgeyByZWxlYXNlLCBlbnZpcm9ubWVudCwgdHVubmVsIH0gPSBvcHRpb25zO1xuXG4gICAgY29uc3Qgc2VyaWFsaXplZENoZWNrSW4gPSB7XG4gICAgICBjaGVja19pbl9pZDogaWQsXG4gICAgICBtb25pdG9yX3NsdWc6IGNoZWNrSW4ubW9uaXRvclNsdWcsXG4gICAgICBzdGF0dXM6IGNoZWNrSW4uc3RhdHVzLFxuICAgICAgcmVsZWFzZSxcbiAgICAgIGVudmlyb25tZW50LFxuICAgIH07XG5cbiAgICBpZiAoJ2R1cmF0aW9uJyBpbiBjaGVja0luKSB7XG4gICAgICBzZXJpYWxpemVkQ2hlY2tJbi5kdXJhdGlvbiA9IGNoZWNrSW4uZHVyYXRpb247XG4gICAgfVxuXG4gICAgaWYgKG1vbml0b3JDb25maWcpIHtcbiAgICAgIHNlcmlhbGl6ZWRDaGVja0luLm1vbml0b3JfY29uZmlnID0ge1xuICAgICAgICBzY2hlZHVsZTogbW9uaXRvckNvbmZpZy5zY2hlZHVsZSxcbiAgICAgICAgY2hlY2tpbl9tYXJnaW46IG1vbml0b3JDb25maWcuY2hlY2tpbk1hcmdpbixcbiAgICAgICAgbWF4X3J1bnRpbWU6IG1vbml0b3JDb25maWcubWF4UnVudGltZSxcbiAgICAgICAgdGltZXpvbmU6IG1vbml0b3JDb25maWcudGltZXpvbmUsXG4gICAgICAgIGZhaWx1cmVfaXNzdWVfdGhyZXNob2xkOiBtb25pdG9yQ29uZmlnLmZhaWx1cmVJc3N1ZVRocmVzaG9sZCxcbiAgICAgICAgcmVjb3ZlcnlfdGhyZXNob2xkOiBtb25pdG9yQ29uZmlnLnJlY292ZXJ5VGhyZXNob2xkLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBbZHluYW1pY1NhbXBsaW5nQ29udGV4dCwgdHJhY2VDb250ZXh0XSA9IF9nZXRUcmFjZUluZm9Gcm9tU2NvcGUodGhpcywgc2NvcGUpO1xuICAgIGlmICh0cmFjZUNvbnRleHQpIHtcbiAgICAgIHNlcmlhbGl6ZWRDaGVja0luLmNvbnRleHRzID0ge1xuICAgICAgICB0cmFjZTogdHJhY2VDb250ZXh0LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbnZlbG9wZSA9IGNyZWF0ZUNoZWNrSW5FbnZlbG9wZShcbiAgICAgIHNlcmlhbGl6ZWRDaGVja0luLFxuICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dCxcbiAgICAgIHRoaXMuZ2V0U2RrTWV0YWRhdGEoKSxcbiAgICAgIHR1bm5lbCxcbiAgICAgIHRoaXMuZ2V0RHNuKCksXG4gICAgKTtcblxuICAgIERFQlVHX0JVSUxEICYmIGRlYnVnLmxvZygnU2VuZGluZyBjaGVja2luOicsIGNoZWNrSW4ubW9uaXRvclNsdWcsIGNoZWNrSW4uc3RhdHVzKTtcblxuICAgIC8vIHNlbmRFbnZlbG9wZSBzaG91bGQgbm90IHRocm93XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgIHRoaXMuc2VuZEVudmVsb3BlKGVudmVsb3BlKTtcblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIF9wcmVwYXJlRXZlbnQoXG4gICAgZXZlbnQsXG4gICAgaGludCxcbiAgICBjdXJyZW50U2NvcGUsXG4gICAgaXNvbGF0aW9uU2NvcGUsXG4gICkge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLnBsYXRmb3JtKSB7XG4gICAgICBldmVudC5wbGF0Zm9ybSA9IGV2ZW50LnBsYXRmb3JtIHx8IHRoaXMuX29wdGlvbnMucGxhdGZvcm07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMucnVudGltZSkge1xuICAgICAgZXZlbnQuY29udGV4dHMgPSB7XG4gICAgICAgIC4uLmV2ZW50LmNvbnRleHRzLFxuICAgICAgICBydW50aW1lOiBldmVudC5jb250ZXh0cz8ucnVudGltZSB8fCB0aGlzLl9vcHRpb25zLnJ1bnRpbWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5hbWUpIHtcbiAgICAgIGV2ZW50LnNlcnZlcl9uYW1lID0gZXZlbnQuc2VydmVyX25hbWUgfHwgdGhpcy5fb3B0aW9ucy5zZXJ2ZXJOYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5fcHJlcGFyZUV2ZW50KGV2ZW50LCBoaW50LCBjdXJyZW50U2NvcGUsIGlzb2xhdGlvblNjb3BlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVxdWVzdFNlc3Npb25FcnJvcmVkT3JDcmFzaGVkKGV2ZW50SGludCkge1xuICBjb25zdCByZXF1ZXN0U2Vzc2lvbiA9IGdldElzb2xhdGlvblNjb3BlKCkuZ2V0U2NvcGVEYXRhKCkuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLnJlcXVlc3RTZXNzaW9uO1xuICBpZiAocmVxdWVzdFNlc3Npb24pIHtcbiAgICAvLyBXZSBtdXRhdGUgaW5zdGVhZCBvZiBkb2luZyBgc2V0U2RrUHJvY2Vzc2luZ01ldGFkYXRhYCBiZWNhdXNlIHRoZSBodHRwIGludGVncmF0aW9uIHN0b3JlcyBhd2F5IGEgcGFydGljdWxhclxuICAgIC8vIGlzb2xhdGlvblNjb3BlLiBJZiB0aGF0IGlzb2xhdGlvbiBzY29wZSBpcyBmb3JrZWQsIHNldHRpbmcgdGhlIHByb2Nlc3NpbmcgbWV0YWRhdGEgaGVyZSB3aWxsIG5vdCBtdXRhdGUgdGhlXG4gICAgLy8gb3JpZ2luYWwgaXNvbGF0aW9uIHNjb3BlIHRoYXQgdGhlIGh0dHAgaW50ZWdyYXRpb24gc3RvcmVkIGF3YXkuXG4gICAgY29uc3QgaXNIYW5kbGVkRXhjZXB0aW9uID0gZXZlbnRIaW50Py5tZWNoYW5pc20/LmhhbmRsZWQgPz8gdHJ1ZTtcbiAgICAvLyBBIHJlcXVlc3Qgc2Vzc2lvbiBjYW4gZ28gZnJvbSBcImVycm9yZWRcIiAtPiBcImNyYXNoZWRcIiBidXQgbm90IFwiY3Jhc2hlZFwiIC0+IFwiZXJyb3JlZFwiLlxuICAgIC8vIENyYXNoZWQgKHVuaGFuZGxlZCBleGNlcHRpb24pIGlzIHdvcnNlIHRoYW4gZXJyb3JlZCAoaGFuZGxlZCBleGNlcHRpb24pLlxuICAgIGlmIChpc0hhbmRsZWRFeGNlcHRpb24gJiYgcmVxdWVzdFNlc3Npb24uc3RhdHVzICE9PSAnY3Jhc2hlZCcpIHtcbiAgICAgIHJlcXVlc3RTZXNzaW9uLnN0YXR1cyA9ICdlcnJvcmVkJztcbiAgICB9IGVsc2UgaWYgKCFpc0hhbmRsZWRFeGNlcHRpb24pIHtcbiAgICAgIHJlcXVlc3RTZXNzaW9uLnN0YXR1cyA9ICdjcmFzaGVkJztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgc2l6ZSBvZiBhIGxvZyBpbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gbG9nIC0gVGhlIGxvZyB0byBlc3RpbWF0ZSB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBlc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgbG9nIGluIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZUxvZ1NpemVJbkJ5dGVzKGxvZykge1xuICBsZXQgd2VpZ2h0ID0gMDtcblxuICAvLyBFc3RpbWF0ZSBieXRlIHNpemUgb2YgMiBieXRlcyBwZXIgY2hhcmFjdGVyLiBUaGlzIGlzIGEgcm91Z2ggZXN0aW1hdGUgSlMgc3RyaW5ncyBhcmUgc3RvcmVkIGFzIFVURi0xNi5cbiAgaWYgKGxvZy5tZXNzYWdlKSB7XG4gICAgd2VpZ2h0ICs9IGxvZy5tZXNzYWdlLmxlbmd0aCAqIDI7XG4gIH1cblxuICBpZiAobG9nLmF0dHJpYnV0ZXMpIHtcbiAgICBPYmplY3QudmFsdWVzKGxvZy5hdHRyaWJ1dGVzKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB3ZWlnaHQgKz0gdmFsdWUubGVuZ3RoICogZXN0aW1hdGVQcmltaXRpdmVTaXplSW5CeXRlcyh2YWx1ZVswXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICB3ZWlnaHQgKz0gZXN0aW1hdGVQcmltaXRpdmVTaXplSW5CeXRlcyh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2JqZWN0cyB2YWx1ZXMsIHdlIGVzdGltYXRlIHRoZSBzaXplIG9mIHRoZSBvYmplY3QgYXMgMTAwIGJ5dGVzXG4gICAgICAgIHdlaWdodCArPSAxMDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gd2VpZ2h0O1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZVByaW1pdGl2ZVNpemVJbkJ5dGVzKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCAqIDI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiA4O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IHsgU2VydmVyUnVudGltZUNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLXJ1bnRpbWUtY2xpZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/server-runtime-client.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1316` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trpcMiddleware: () => (/* binding */ trpcMiddleware)\n/* harmony export */ });\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./currentScopes.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _exports_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./exports.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/exports.js\");\n/* harmony import */ var _semanticAttributes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./semanticAttributes.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/semanticAttributes.js\");\n/* harmony import */ var _utils_object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/object.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/object.js\");\n/* harmony import */ var _utils_normalize_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/normalize.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/normalize.js\");\n/* harmony import */ var _tracing_trace_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tracing/trace.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/tracing/trace.js\");\n\n\n\n\n\n\n\nconst trpcCaptureContext = { mechanism: { handled: false, data: { function: 'trpcMiddleware' } } };\n\nfunction captureIfError(nextResult) {\n  // TODO: Set span status based on what TRPCError was encountered\n  if (\n    typeof nextResult === 'object' &&\n    nextResult !== null &&\n    'ok' in nextResult &&\n    !nextResult.ok &&\n    'error' in nextResult\n  ) {\n    (0,_exports_js__WEBPACK_IMPORTED_MODULE_1__.captureException)(nextResult.error, trpcCaptureContext);\n  }\n}\n\n/**\n * Sentry tRPC middleware that captures errors and creates spans for tRPC procedures.\n */\nfunction trpcMiddleware(options = {}) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return async function (opts) {\n    const { path, type, next, rawInput, getRawInput } = opts;\n\n    const client = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)();\n    const clientOptions = client?.getOptions();\n\n    const trpcContext = {\n      procedure_path: path,\n      procedure_type: type,\n    };\n\n    (0,_utils_object_js__WEBPACK_IMPORTED_MODULE_3__.addNonEnumerableProperty)(\n      trpcContext,\n      '__sentry_override_normalization_depth__',\n      1 + // 1 for context.input + the normal normalization depth\n        (clientOptions?.normalizeDepth ?? 5), // 5 is a sane depth\n    );\n\n    if (options.attachRpcInput !== undefined ? options.attachRpcInput : clientOptions?.sendDefaultPii) {\n      if (rawInput !== undefined) {\n        trpcContext.input = (0,_utils_normalize_js__WEBPACK_IMPORTED_MODULE_4__.normalize)(rawInput);\n      }\n\n      if (getRawInput !== undefined && typeof getRawInput === 'function') {\n        try {\n          const rawRes = await getRawInput();\n\n          trpcContext.input = (0,_utils_normalize_js__WEBPACK_IMPORTED_MODULE_4__.normalize)(rawRes);\n        } catch {\n          // noop\n        }\n      }\n    }\n\n    return (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.withIsolationScope)(scope => {\n      scope.setContext('trpc', trpcContext);\n      return (0,_tracing_trace_js__WEBPACK_IMPORTED_MODULE_5__.startSpanManual)(\n        {\n          name: `trpc/${path}`,\n          op: 'rpc.server',\n          attributes: {\n            [_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_2__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n            [_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_2__.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.rpc.trpc',\n          },\n          forceTransaction: !!options.forceTransaction,\n        },\n        async span => {\n          try {\n            const nextResult = await next();\n            captureIfError(nextResult);\n            span.end();\n            return nextResult;\n          } catch (e) {\n            (0,_exports_js__WEBPACK_IMPORTED_MODULE_1__.captureException)(e, trpcCaptureContext);\n            span.end();\n            throw e;\n          }\n        },\n      ) ;\n    });\n  };\n}\n\n\n//# sourceMappingURL=trpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3RycGMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtRTtBQUNuQjtBQUM2RDtBQUNoRDtBQUNaO0FBQ0k7O0FBRXJELDZCQUE2QixhQUFhLHdCQUF3Qjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBZ0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7O0FBRXRELG1CQUFtQiw0REFBUztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDBFQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQVM7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qiw4REFBUztBQUN2QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxxRUFBa0I7QUFDN0I7QUFDQSxhQUFhLGtFQUFlO0FBQzVCO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBLGFBQWEsb0ZBQWdDO0FBQzdDLGFBQWEsb0ZBQWdDO0FBQzdDLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWSw2REFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrY29yZUA5LjQ2LjAvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdHJwYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRDbGllbnQsIHdpdGhJc29sYXRpb25TY29wZSB9IGZyb20gJy4vY3VycmVudFNjb3Blcy5qcyc7XG5pbXBvcnQgeyBjYXB0dXJlRXhjZXB0aW9uIH0gZnJvbSAnLi9leHBvcnRzLmpzJztcbmltcG9ydCB7IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOLCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSB9IGZyb20gJy4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSB9IGZyb20gJy4vdXRpbHMvb2JqZWN0LmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZSB9IGZyb20gJy4vdXRpbHMvbm9ybWFsaXplLmpzJztcbmltcG9ydCB7IHN0YXJ0U3Bhbk1hbnVhbCB9IGZyb20gJy4vdHJhY2luZy90cmFjZS5qcyc7XG5cbmNvbnN0IHRycGNDYXB0dXJlQ29udGV4dCA9IHsgbWVjaGFuaXNtOiB7IGhhbmRsZWQ6IGZhbHNlLCBkYXRhOiB7IGZ1bmN0aW9uOiAndHJwY01pZGRsZXdhcmUnIH0gfSB9O1xuXG5mdW5jdGlvbiBjYXB0dXJlSWZFcnJvcihuZXh0UmVzdWx0KSB7XG4gIC8vIFRPRE86IFNldCBzcGFuIHN0YXR1cyBiYXNlZCBvbiB3aGF0IFRSUENFcnJvciB3YXMgZW5jb3VudGVyZWRcbiAgaWYgKFxuICAgIHR5cGVvZiBuZXh0UmVzdWx0ID09PSAnb2JqZWN0JyAmJlxuICAgIG5leHRSZXN1bHQgIT09IG51bGwgJiZcbiAgICAnb2snIGluIG5leHRSZXN1bHQgJiZcbiAgICAhbmV4dFJlc3VsdC5vayAmJlxuICAgICdlcnJvcicgaW4gbmV4dFJlc3VsdFxuICApIHtcbiAgICBjYXB0dXJlRXhjZXB0aW9uKG5leHRSZXN1bHQuZXJyb3IsIHRycGNDYXB0dXJlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW50cnkgdFJQQyBtaWRkbGV3YXJlIHRoYXQgY2FwdHVyZXMgZXJyb3JzIGFuZCBjcmVhdGVzIHNwYW5zIGZvciB0UlBDIHByb2NlZHVyZXMuXG4gKi9cbmZ1bmN0aW9uIHRycGNNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgY29uc3QgeyBwYXRoLCB0eXBlLCBuZXh0LCByYXdJbnB1dCwgZ2V0UmF3SW5wdXQgfSA9IG9wdHM7XG5cbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcbiAgICBjb25zdCBjbGllbnRPcHRpb25zID0gY2xpZW50Py5nZXRPcHRpb25zKCk7XG5cbiAgICBjb25zdCB0cnBjQ29udGV4dCA9IHtcbiAgICAgIHByb2NlZHVyZV9wYXRoOiBwYXRoLFxuICAgICAgcHJvY2VkdXJlX3R5cGU6IHR5cGUsXG4gICAgfTtcblxuICAgIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShcbiAgICAgIHRycGNDb250ZXh0LFxuICAgICAgJ19fc2VudHJ5X292ZXJyaWRlX25vcm1hbGl6YXRpb25fZGVwdGhfXycsXG4gICAgICAxICsgLy8gMSBmb3IgY29udGV4dC5pbnB1dCArIHRoZSBub3JtYWwgbm9ybWFsaXphdGlvbiBkZXB0aFxuICAgICAgICAoY2xpZW50T3B0aW9ucz8ubm9ybWFsaXplRGVwdGggPz8gNSksIC8vIDUgaXMgYSBzYW5lIGRlcHRoXG4gICAgKTtcblxuICAgIGlmIChvcHRpb25zLmF0dGFjaFJwY0lucHV0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmF0dGFjaFJwY0lucHV0IDogY2xpZW50T3B0aW9ucz8uc2VuZERlZmF1bHRQaWkpIHtcbiAgICAgIGlmIChyYXdJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRycGNDb250ZXh0LmlucHV0ID0gbm9ybWFsaXplKHJhd0lucHV0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldFJhd0lucHV0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGdldFJhd0lucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmF3UmVzID0gYXdhaXQgZ2V0UmF3SW5wdXQoKTtcblxuICAgICAgICAgIHRycGNDb250ZXh0LmlucHV0ID0gbm9ybWFsaXplKHJhd1Jlcyk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3aXRoSXNvbGF0aW9uU2NvcGUoc2NvcGUgPT4ge1xuICAgICAgc2NvcGUuc2V0Q29udGV4dCgndHJwYycsIHRycGNDb250ZXh0KTtcbiAgICAgIHJldHVybiBzdGFydFNwYW5NYW51YWwoXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBgdHJwYy8ke3BhdGh9YCxcbiAgICAgICAgICBvcDogJ3JwYy5zZXJ2ZXInLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICdyb3V0ZScsXG4gICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by5ycGMudHJwYycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JjZVRyYW5zYWN0aW9uOiAhIW9wdGlvbnMuZm9yY2VUcmFuc2FjdGlvbixcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc3BhbiA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRSZXN1bHQgPSBhd2FpdCBuZXh0KCk7XG4gICAgICAgICAgICBjYXB0dXJlSWZFcnJvcihuZXh0UmVzdWx0KTtcbiAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFJlc3VsdDtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYXB0dXJlRXhjZXB0aW9uKGUsIHRycGNDYXB0dXJlQ29udGV4dCk7XG4gICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApIDtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgdHJwY01pZGRsZXdhcmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRycGMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/trpc.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1558` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasSpansEnabled: () => (/* binding */ hasSpansEnabled),\n/* harmony export */   hasTracingEnabled: () => (/* binding */ hasTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../currentScopes.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/currentScopes.js\");\n\n\n// Treeshakable guard to remove all code related to tracing\n\n/**\n * Determines if span recording is currently enabled.\n *\n * Spans are recorded when at least one of `tracesSampleRate` and `tracesSampler`\n * is defined in the SDK config. This function does not make any assumption about\n * sampling decisions, it only checks if the SDK is configured to record spans.\n *\n * Important: This function only determines if span recording is enabled. Trace\n * continuation and propagation is separately controlled and not covered by this function.\n * If this function returns `false`, traces can still be propagated (which is what\n * we refer to by \"Tracing without Performance\")\n * @see https://develop.sentry.dev/sdk/telemetry/traces/tracing-without-performance/\n *\n * @param maybeOptions An SDK options object to be passed to this function.\n * If this option is not provided, the function will use the current client's options.\n */\nfunction hasSpansEnabled(\n  maybeOptions,\n) {\n  if (typeof __SENTRY_TRACING__ === 'boolean' && !__SENTRY_TRACING__) {\n    return false;\n  }\n\n  const options = maybeOptions || (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getClient)()?.getOptions();\n  return (\n    !!options &&\n    // Note: This check is `!= null`, meaning \"nullish\". `0` is not \"nullish\", `undefined` and `null` are. (This comment was brought to you by 15 minutes of questioning life)\n    (options.tracesSampleRate != null || !!options.tracesSampler)\n  );\n}\n\n/**\n * @see JSDoc of `hasSpansEnabled`\n * @deprecated Use `hasSpansEnabled` instead, which is a more accurately named version of this function.\n * This function will be removed in the next major version of the SDK.\n */\n// TODO(v10): Remove this export\nconst hasTracingEnabled = hasSpansEnabled;\n\n\n//# sourceMappingURL=hasSpansEnabled.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL2hhc1NwYW5zRW5hYmxlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0Q7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyw0REFBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThDO0FBQzlDIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrY29yZUA5LjQ2LjAvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvaGFzU3BhbnNFbmFibGVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldENsaWVudCB9IGZyb20gJy4uL2N1cnJlbnRTY29wZXMuanMnO1xuXG4vLyBUcmVlc2hha2FibGUgZ3VhcmQgdG8gcmVtb3ZlIGFsbCBjb2RlIHJlbGF0ZWQgdG8gdHJhY2luZ1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgc3BhbiByZWNvcmRpbmcgaXMgY3VycmVudGx5IGVuYWJsZWQuXG4gKlxuICogU3BhbnMgYXJlIHJlY29yZGVkIHdoZW4gYXQgbGVhc3Qgb25lIG9mIGB0cmFjZXNTYW1wbGVSYXRlYCBhbmQgYHRyYWNlc1NhbXBsZXJgXG4gKiBpcyBkZWZpbmVkIGluIHRoZSBTREsgY29uZmlnLiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1ha2UgYW55IGFzc3VtcHRpb24gYWJvdXRcbiAqIHNhbXBsaW5nIGRlY2lzaW9ucywgaXQgb25seSBjaGVja3MgaWYgdGhlIFNESyBpcyBjb25maWd1cmVkIHRvIHJlY29yZCBzcGFucy5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoaXMgZnVuY3Rpb24gb25seSBkZXRlcm1pbmVzIGlmIHNwYW4gcmVjb3JkaW5nIGlzIGVuYWJsZWQuIFRyYWNlXG4gKiBjb250aW51YXRpb24gYW5kIHByb3BhZ2F0aW9uIGlzIHNlcGFyYXRlbHkgY29udHJvbGxlZCBhbmQgbm90IGNvdmVyZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAqIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLCB0cmFjZXMgY2FuIHN0aWxsIGJlIHByb3BhZ2F0ZWQgKHdoaWNoIGlzIHdoYXRcbiAqIHdlIHJlZmVyIHRvIGJ5IFwiVHJhY2luZyB3aXRob3V0IFBlcmZvcm1hbmNlXCIpXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcC5zZW50cnkuZGV2L3Nkay90ZWxlbWV0cnkvdHJhY2VzL3RyYWNpbmctd2l0aG91dC1wZXJmb3JtYW5jZS9cbiAqXG4gKiBAcGFyYW0gbWF5YmVPcHRpb25zIEFuIFNESyBvcHRpb25zIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbi5cbiAqIElmIHRoaXMgb3B0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlIGZ1bmN0aW9uIHdpbGwgdXNlIHRoZSBjdXJyZW50IGNsaWVudCdzIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGhhc1NwYW5zRW5hYmxlZChcbiAgbWF5YmVPcHRpb25zLFxuKSB7XG4gIGlmICh0eXBlb2YgX19TRU5UUllfVFJBQ0lOR19fID09PSAnYm9vbGVhbicgJiYgIV9fU0VOVFJZX1RSQUNJTkdfXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBtYXliZU9wdGlvbnMgfHwgZ2V0Q2xpZW50KCk/LmdldE9wdGlvbnMoKTtcbiAgcmV0dXJuIChcbiAgICAhIW9wdGlvbnMgJiZcbiAgICAvLyBOb3RlOiBUaGlzIGNoZWNrIGlzIGAhPSBudWxsYCwgbWVhbmluZyBcIm51bGxpc2hcIi4gYDBgIGlzIG5vdCBcIm51bGxpc2hcIiwgYHVuZGVmaW5lZGAgYW5kIGBudWxsYCBhcmUuIChUaGlzIGNvbW1lbnQgd2FzIGJyb3VnaHQgdG8geW91IGJ5IDE1IG1pbnV0ZXMgb2YgcXVlc3Rpb25pbmcgbGlmZSlcbiAgICAob3B0aW9ucy50cmFjZXNTYW1wbGVSYXRlICE9IG51bGwgfHwgISFvcHRpb25zLnRyYWNlc1NhbXBsZXIpXG4gICk7XG59XG5cbi8qKlxuICogQHNlZSBKU0RvYyBvZiBgaGFzU3BhbnNFbmFibGVkYFxuICogQGRlcHJlY2F0ZWQgVXNlIGBoYXNTcGFuc0VuYWJsZWRgIGluc3RlYWQsIHdoaWNoIGlzIGEgbW9yZSBhY2N1cmF0ZWx5IG5hbWVkIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgdGhlIFNESy5cbiAqL1xuLy8gVE9ETyh2MTApOiBSZW1vdmUgdGhpcyBleHBvcnRcbmNvbnN0IGhhc1RyYWNpbmdFbmFibGVkID0gaGFzU3BhbnNFbmFibGVkO1xuXG5leHBvcnQgeyBoYXNTcGFuc0VuYWJsZWQsIGhhc1RyYWNpbmdFbmFibGVkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNTcGFuc0VuYWJsZWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/hasSpansEnabled.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1712` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   instrumentOpenAiClient: () => (/* binding */ instrumentOpenAiClient)\n/* harmony export */ });\n/* harmony import */ var _currentScopes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../currentScopes.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/currentScopes.js\");\n/* harmony import */ var _exports_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../exports.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/exports.js\");\n/* harmony import */ var _tracing_trace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tracing/trace.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/tracing/trace.js\");\n/* harmony import */ var _gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gen-ai-attributes.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/gen-ai-attributes.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/openai/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/openai/utils.js\");\n\n\n\n\n\n\n\n/**\n * Extract request attributes from method arguments\n */\nfunction extractRequestAttributes(args, methodPath) {\n  const attributes = {\n    [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_SYSTEM_ATTRIBUTE]: 'openai',\n    [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_OPERATION_NAME_ATTRIBUTE]: (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getOperationName)(methodPath),\n  };\n\n  if (args.length > 0 && typeof args[0] === 'object' && args[0] !== null) {\n    const params = args[0] ;\n\n    attributes[_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_MODEL_ATTRIBUTE] = params.model ?? 'unknown';\n    if ('temperature' in params) attributes[_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = params.temperature;\n    if ('top_p' in params) attributes[_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = params.top_p;\n    if ('frequency_penalty' in params)\n      attributes[_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = params.frequency_penalty;\n    if ('presence_penalty' in params) attributes[_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE] = params.presence_penalty;\n  } else {\n    attributes[_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_MODEL_ATTRIBUTE] = 'unknown';\n  }\n\n  return attributes;\n}\n\n/**\n * Helper function to set token usage attributes\n */\nfunction setTokenUsageAttributes(\n  span,\n  promptTokens,\n  completionTokens,\n  totalTokens,\n) {\n  if (promptTokens !== undefined) {\n    span.setAttributes({\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE]: promptTokens,\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: promptTokens,\n    });\n  }\n  if (completionTokens !== undefined) {\n    span.setAttributes({\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE]: completionTokens,\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: completionTokens,\n    });\n  }\n  if (totalTokens !== undefined) {\n    span.setAttributes({\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: totalTokens,\n    });\n  }\n}\n\n/**\n * Helper function to set common response attributes (ID, model, timestamp)\n */\nfunction setCommonResponseAttributes(span, id, model, timestamp) {\n  if (id) {\n    span.setAttributes({\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.OPENAI_RESPONSE_ID_ATTRIBUTE]: id,\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_RESPONSE_ID_ATTRIBUTE]: id,\n    });\n  }\n  if (model) {\n    span.setAttributes({\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.OPENAI_RESPONSE_MODEL_ATTRIBUTE]: model,\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: model,\n    });\n  }\n  if (timestamp) {\n    span.setAttributes({\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(timestamp * 1000).toISOString(),\n    });\n  }\n}\n\n/**\n * Add attributes for Chat Completion responses\n */\nfunction addChatCompletionAttributes(span, response) {\n  setCommonResponseAttributes(span, response.id, response.model, response.created);\n  if (response.usage) {\n    setTokenUsageAttributes(\n      span,\n      response.usage.prompt_tokens,\n      response.usage.completion_tokens,\n      response.usage.total_tokens,\n    );\n  }\n  if (Array.isArray(response.choices)) {\n    const finishReasons = response.choices\n      .map(choice => choice.finish_reason)\n      .filter((reason) => reason !== null);\n    if (finishReasons.length > 0) {\n      span.setAttributes({\n        [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(finishReasons),\n      });\n    }\n  }\n}\n\n/**\n * Add attributes for Responses API responses\n */\nfunction addResponsesApiAttributes(span, response) {\n  setCommonResponseAttributes(span, response.id, response.model, response.created_at);\n  if (response.status) {\n    span.setAttributes({\n      [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify([response.status]),\n    });\n  }\n  if (response.usage) {\n    setTokenUsageAttributes(\n      span,\n      response.usage.input_tokens,\n      response.usage.output_tokens,\n      response.usage.total_tokens,\n    );\n  }\n}\n\n/**\n * Add response attributes to spans\n * This currently supports both Chat Completion and Responses API responses\n */\nfunction addResponseAttributes(span, result, recordOutputs) {\n  if (!result || typeof result !== 'object') return;\n\n  const response = result ;\n\n  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isChatCompletionResponse)(response)) {\n    addChatCompletionAttributes(span, response);\n    if (recordOutputs && response.choices?.length) {\n      const responseTexts = response.choices.map(choice => choice.message?.content || '');\n      span.setAttributes({ [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(responseTexts) });\n    }\n  } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isResponsesApiResponse)(response)) {\n    addResponsesApiAttributes(span, response);\n    if (recordOutputs && response.output_text) {\n      span.setAttributes({ [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: response.output_text });\n    }\n  }\n}\n\n// Extract and record AI request inputs, if present. This is intentionally separate from response attributes.\nfunction addRequestAttributes(span, params) {\n  if ('messages' in params) {\n    span.setAttributes({ [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.messages) });\n  }\n  if ('input' in params) {\n    span.setAttributes({ [_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(params.input) });\n  }\n}\n\nfunction getOptionsFromIntegration() {\n  const scope = (0,_currentScopes_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)();\n  const client = scope.getClient();\n  const integration = client?.getIntegrationByName(_constants_js__WEBPACK_IMPORTED_MODULE_4__.OPENAI_INTEGRATION_NAME) ;\n  const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;\n\n  return {\n    recordInputs: integration?.options?.recordInputs ?? shouldRecordInputsAndOutputs,\n    recordOutputs: integration?.options?.recordOutputs ?? shouldRecordInputsAndOutputs,\n  };\n}\n\n/**\n * Instrument a method with Sentry spans\n * Following Sentry AI Agents Manual Instrumentation conventions\n * @see https://docs.sentry.io/platforms/javascript/guides/node/tracing/instrumentation/ai-agents-module/#manual-instrumentation\n */\nfunction instrumentMethod(\n  originalMethod,\n  methodPath,\n  context,\n  options,\n) {\n  return async function instrumentedMethod(...args) {\n    const finalOptions = options || getOptionsFromIntegration();\n    const requestAttributes = extractRequestAttributes(args, methodPath);\n    const model = (requestAttributes[_gen_ai_attributes_js__WEBPACK_IMPORTED_MODULE_3__.GEN_AI_REQUEST_MODEL_ATTRIBUTE] ) || 'unknown';\n    const operationName = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getOperationName)(methodPath);\n\n    return (0,_tracing_trace_js__WEBPACK_IMPORTED_MODULE_2__.startSpan)(\n      {\n        name: `${operationName} ${model}`,\n        op: (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getSpanOperation)(methodPath),\n        attributes: requestAttributes ,\n      },\n      async (span) => {\n        try {\n          if (finalOptions.recordInputs && args[0] && typeof args[0] === 'object') {\n            addRequestAttributes(span, args[0] );\n          }\n\n          const result = await originalMethod.apply(context, args);\n          // TODO: Add streaming support\n          addResponseAttributes(span, result, finalOptions.recordOutputs);\n          return result;\n        } catch (error) {\n          (0,_exports_js__WEBPACK_IMPORTED_MODULE_1__.captureException)(error);\n          throw error;\n        }\n      },\n    );\n  };\n}\n\n/**\n * Create a deep proxy for OpenAI client instrumentation\n */\nfunction createDeepProxy(target, currentPath = '', options) {\n  return new Proxy(target, {\n    get(obj, prop) {\n      const value = (obj )[prop];\n      const methodPath = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.buildMethodPath)(currentPath, String(prop));\n\n      if (typeof value === 'function' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.shouldInstrument)(methodPath)) {\n        return instrumentMethod(value , methodPath, obj, options);\n      }\n\n      if (typeof value === 'function') {\n        // Bind non-instrumented functions to preserve the original `this` context,\n        // which is required for accessing private class fields (e.g. #baseURL) in OpenAI SDK v5.\n        return value.bind(obj);\n      }\n\n      if (value && typeof value === 'object') {\n        return createDeepProxy(value , methodPath, options);\n      }\n\n      return value;\n    },\n  });\n}\n\n/**\n * Instrument an OpenAI client with Sentry tracing\n * Can be used across Node.js, Cloudflare Workers, and Vercel Edge\n */\nfunction instrumentOpenAiClient(client, options) {\n  return createDeepProxy(client, '', options);\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL29wZW5haS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlEO0FBQ0w7QUFDRDtBQUM2ckI7QUFDdnJCO0FBQzRGOztBQUVySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywwRUFBdUI7QUFDNUIsS0FBSyxrRkFBK0IsR0FBRywyREFBZ0I7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLGlGQUE4QjtBQUM3Qyw0Q0FBNEMsdUZBQW9DO0FBQ2hGLHNDQUFzQyxpRkFBOEI7QUFDcEU7QUFDQSxpQkFBaUIsNkZBQTBDO0FBQzNELGlEQUFpRCw0RkFBeUM7QUFDMUYsSUFBSTtBQUNKLGVBQWUsaUZBQThCO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUZBQW9DO0FBQzNDLE9BQU8sc0ZBQW1DO0FBQzFDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPLDJGQUF3QztBQUMvQyxPQUFPLHVGQUFvQztBQUMzQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzRkFBbUM7QUFDMUMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrRUFBNEI7QUFDbkMsT0FBTywrRUFBNEI7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0ZBQStCO0FBQ3RDLE9BQU8sa0ZBQStCO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNGQUFtQztBQUMxQyxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkZBQXdDO0FBQ2pELE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDJGQUF3QztBQUMvQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sbUVBQXdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixDQUFDLGlGQUE4QixrQ0FBa0M7QUFDNUY7QUFDQSxJQUFJLFNBQVMsaUVBQXNCO0FBQ25DO0FBQ0E7QUFDQSwyQkFBMkIsQ0FBQyxpRkFBOEIseUJBQXlCO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsQ0FBQyxvRkFBaUMsb0NBQW9DO0FBQy9GO0FBQ0E7QUFDQSx5QkFBeUIsQ0FBQyxvRkFBaUMsaUNBQWlDO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isa0VBQWU7QUFDL0I7QUFDQSxtREFBbUQsa0VBQXVCO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpRkFBOEI7QUFDbkUsMEJBQTBCLDJEQUFnQjs7QUFFMUMsV0FBVyw0REFBUztBQUNwQjtBQUNBLGlCQUFpQixlQUFlLEVBQUUsTUFBTTtBQUN4QyxZQUFZLDJEQUFnQjtBQUM1QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVUsNkRBQWdCO0FBQzFCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFlOztBQUV4Qyx5Q0FBeUMsMkRBQWdCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQztBQUNsQyIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL29wZW5haS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRDdXJyZW50U2NvcGUgfSBmcm9tICcuLi8uLi9jdXJyZW50U2NvcGVzLmpzJztcbmltcG9ydCB7IGNhcHR1cmVFeGNlcHRpb24gfSBmcm9tICcuLi8uLi9leHBvcnRzLmpzJztcbmltcG9ydCB7IHN0YXJ0U3BhbiB9IGZyb20gJy4uLy4uL3RyYWNpbmcvdHJhY2UuanMnO1xuaW1wb3J0IHsgR0VOX0FJX09QRVJBVElPTl9OQU1FX0FUVFJJQlVURSwgR0VOX0FJX1JFUVVFU1RfTU9ERUxfQVRUUklCVVRFLCBHRU5fQUlfUkVRVUVTVF9URU1QRVJBVFVSRV9BVFRSSUJVVEUsIEdFTl9BSV9SRVFVRVNUX1RPUF9QX0FUVFJJQlVURSwgR0VOX0FJX1JFUVVFU1RfRlJFUVVFTkNZX1BFTkFMVFlfQVRUUklCVVRFLCBHRU5fQUlfUkVRVUVTVF9QUkVTRU5DRV9QRU5BTFRZX0FUVFJJQlVURSwgR0VOX0FJX1JFUVVFU1RfTUVTU0FHRVNfQVRUUklCVVRFLCBHRU5fQUlfUkVTUE9OU0VfVEVYVF9BVFRSSUJVVEUsIEdFTl9BSV9TWVNURU1fQVRUUklCVVRFLCBHRU5fQUlfUkVTUE9OU0VfRklOSVNIX1JFQVNPTlNfQVRUUklCVVRFLCBHRU5fQUlfUkVTUE9OU0VfSURfQVRUUklCVVRFLCBPUEVOQUlfUkVTUE9OU0VfSURfQVRUUklCVVRFLCBHRU5fQUlfUkVTUE9OU0VfTU9ERUxfQVRUUklCVVRFLCBPUEVOQUlfUkVTUE9OU0VfTU9ERUxfQVRUUklCVVRFLCBPUEVOQUlfUkVTUE9OU0VfVElNRVNUQU1QX0FUVFJJQlVURSwgR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOU19BVFRSSUJVVEUsIE9QRU5BSV9VU0FHRV9QUk9NUFRfVE9LRU5TX0FUVFJJQlVURSwgR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlNfQVRUUklCVVRFLCBPUEVOQUlfVVNBR0VfQ09NUExFVElPTl9UT0tFTlNfQVRUUklCVVRFLCBHRU5fQUlfVVNBR0VfVE9UQUxfVE9LRU5TX0FUVFJJQlVURSB9IGZyb20gJy4uL2dlbi1haS1hdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IE9QRU5BSV9JTlRFR1JBVElPTl9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgc2hvdWxkSW5zdHJ1bWVudCwgZ2V0T3BlcmF0aW9uTmFtZSwgZ2V0U3Bhbk9wZXJhdGlvbiwgaXNDaGF0Q29tcGxldGlvblJlc3BvbnNlLCBpc1Jlc3BvbnNlc0FwaVJlc3BvbnNlLCBidWlsZE1ldGhvZFBhdGggfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBFeHRyYWN0IHJlcXVlc3QgYXR0cmlidXRlcyBmcm9tIG1ldGhvZCBhcmd1bWVudHNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFJlcXVlc3RBdHRyaWJ1dGVzKGFyZ3MsIG1ldGhvZFBhdGgpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICBbR0VOX0FJX1NZU1RFTV9BVFRSSUJVVEVdOiAnb3BlbmFpJyxcbiAgICBbR0VOX0FJX09QRVJBVElPTl9OQU1FX0FUVFJJQlVURV06IGdldE9wZXJhdGlvbk5hbWUobWV0aG9kUGF0aCksXG4gIH07XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgYXJnc1swXSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3NbMF0gO1xuXG4gICAgYXR0cmlidXRlc1tHRU5fQUlfUkVRVUVTVF9NT0RFTF9BVFRSSUJVVEVdID0gcGFyYW1zLm1vZGVsID8/ICd1bmtub3duJztcbiAgICBpZiAoJ3RlbXBlcmF0dXJlJyBpbiBwYXJhbXMpIGF0dHJpYnV0ZXNbR0VOX0FJX1JFUVVFU1RfVEVNUEVSQVRVUkVfQVRUUklCVVRFXSA9IHBhcmFtcy50ZW1wZXJhdHVyZTtcbiAgICBpZiAoJ3RvcF9wJyBpbiBwYXJhbXMpIGF0dHJpYnV0ZXNbR0VOX0FJX1JFUVVFU1RfVE9QX1BfQVRUUklCVVRFXSA9IHBhcmFtcy50b3BfcDtcbiAgICBpZiAoJ2ZyZXF1ZW5jeV9wZW5hbHR5JyBpbiBwYXJhbXMpXG4gICAgICBhdHRyaWJ1dGVzW0dFTl9BSV9SRVFVRVNUX0ZSRVFVRU5DWV9QRU5BTFRZX0FUVFJJQlVURV0gPSBwYXJhbXMuZnJlcXVlbmN5X3BlbmFsdHk7XG4gICAgaWYgKCdwcmVzZW5jZV9wZW5hbHR5JyBpbiBwYXJhbXMpIGF0dHJpYnV0ZXNbR0VOX0FJX1JFUVVFU1RfUFJFU0VOQ0VfUEVOQUxUWV9BVFRSSUJVVEVdID0gcGFyYW1zLnByZXNlbmNlX3BlbmFsdHk7XG4gIH0gZWxzZSB7XG4gICAgYXR0cmlidXRlc1tHRU5fQUlfUkVRVUVTVF9NT0RFTF9BVFRSSUJVVEVdID0gJ3Vua25vd24nO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHNldCB0b2tlbiB1c2FnZSBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIHNldFRva2VuVXNhZ2VBdHRyaWJ1dGVzKFxuICBzcGFuLFxuICBwcm9tcHRUb2tlbnMsXG4gIGNvbXBsZXRpb25Ub2tlbnMsXG4gIHRvdGFsVG9rZW5zLFxuKSB7XG4gIGlmIChwcm9tcHRUb2tlbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICBbT1BFTkFJX1VTQUdFX1BST01QVF9UT0tFTlNfQVRUUklCVVRFXTogcHJvbXB0VG9rZW5zLFxuICAgICAgW0dFTl9BSV9VU0FHRV9JTlBVVF9UT0tFTlNfQVRUUklCVVRFXTogcHJvbXB0VG9rZW5zLFxuICAgIH0pO1xuICB9XG4gIGlmIChjb21wbGV0aW9uVG9rZW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgW09QRU5BSV9VU0FHRV9DT01QTEVUSU9OX1RPS0VOU19BVFRSSUJVVEVdOiBjb21wbGV0aW9uVG9rZW5zLFxuICAgICAgW0dFTl9BSV9VU0FHRV9PVVRQVVRfVE9LRU5TX0FUVFJJQlVURV06IGNvbXBsZXRpb25Ub2tlbnMsXG4gICAgfSk7XG4gIH1cbiAgaWYgKHRvdGFsVG9rZW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgW0dFTl9BSV9VU0FHRV9UT1RBTF9UT0tFTlNfQVRUUklCVVRFXTogdG90YWxUb2tlbnMsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IGNvbW1vbiByZXNwb25zZSBhdHRyaWJ1dGVzIChJRCwgbW9kZWwsIHRpbWVzdGFtcClcbiAqL1xuZnVuY3Rpb24gc2V0Q29tbW9uUmVzcG9uc2VBdHRyaWJ1dGVzKHNwYW4sIGlkLCBtb2RlbCwgdGltZXN0YW1wKSB7XG4gIGlmIChpZCkge1xuICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICBbT1BFTkFJX1JFU1BPTlNFX0lEX0FUVFJJQlVURV06IGlkLFxuICAgICAgW0dFTl9BSV9SRVNQT05TRV9JRF9BVFRSSUJVVEVdOiBpZCxcbiAgICB9KTtcbiAgfVxuICBpZiAobW9kZWwpIHtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgW09QRU5BSV9SRVNQT05TRV9NT0RFTF9BVFRSSUJVVEVdOiBtb2RlbCxcbiAgICAgIFtHRU5fQUlfUkVTUE9OU0VfTU9ERUxfQVRUUklCVVRFXTogbW9kZWwsXG4gICAgfSk7XG4gIH1cbiAgaWYgKHRpbWVzdGFtcCkge1xuICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICBbT1BFTkFJX1JFU1BPTlNFX1RJTUVTVEFNUF9BVFRSSUJVVEVdOiBuZXcgRGF0ZSh0aW1lc3RhbXAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGF0dHJpYnV0ZXMgZm9yIENoYXQgQ29tcGxldGlvbiByZXNwb25zZXNcbiAqL1xuZnVuY3Rpb24gYWRkQ2hhdENvbXBsZXRpb25BdHRyaWJ1dGVzKHNwYW4sIHJlc3BvbnNlKSB7XG4gIHNldENvbW1vblJlc3BvbnNlQXR0cmlidXRlcyhzcGFuLCByZXNwb25zZS5pZCwgcmVzcG9uc2UubW9kZWwsIHJlc3BvbnNlLmNyZWF0ZWQpO1xuICBpZiAocmVzcG9uc2UudXNhZ2UpIHtcbiAgICBzZXRUb2tlblVzYWdlQXR0cmlidXRlcyhcbiAgICAgIHNwYW4sXG4gICAgICByZXNwb25zZS51c2FnZS5wcm9tcHRfdG9rZW5zLFxuICAgICAgcmVzcG9uc2UudXNhZ2UuY29tcGxldGlvbl90b2tlbnMsXG4gICAgICByZXNwb25zZS51c2FnZS50b3RhbF90b2tlbnMsXG4gICAgKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZS5jaG9pY2VzKSkge1xuICAgIGNvbnN0IGZpbmlzaFJlYXNvbnMgPSByZXNwb25zZS5jaG9pY2VzXG4gICAgICAubWFwKGNob2ljZSA9PiBjaG9pY2UuZmluaXNoX3JlYXNvbilcbiAgICAgIC5maWx0ZXIoKHJlYXNvbikgPT4gcmVhc29uICE9PSBudWxsKTtcbiAgICBpZiAoZmluaXNoUmVhc29ucy5sZW5ndGggPiAwKSB7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBbR0VOX0FJX1JFU1BPTlNFX0ZJTklTSF9SRUFTT05TX0FUVFJJQlVURV06IEpTT04uc3RyaW5naWZ5KGZpbmlzaFJlYXNvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIGF0dHJpYnV0ZXMgZm9yIFJlc3BvbnNlcyBBUEkgcmVzcG9uc2VzXG4gKi9cbmZ1bmN0aW9uIGFkZFJlc3BvbnNlc0FwaUF0dHJpYnV0ZXMoc3BhbiwgcmVzcG9uc2UpIHtcbiAgc2V0Q29tbW9uUmVzcG9uc2VBdHRyaWJ1dGVzKHNwYW4sIHJlc3BvbnNlLmlkLCByZXNwb25zZS5tb2RlbCwgcmVzcG9uc2UuY3JlYXRlZF9hdCk7XG4gIGlmIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgW0dFTl9BSV9SRVNQT05TRV9GSU5JU0hfUkVBU09OU19BVFRSSUJVVEVdOiBKU09OLnN0cmluZ2lmeShbcmVzcG9uc2Uuc3RhdHVzXSksXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLnVzYWdlKSB7XG4gICAgc2V0VG9rZW5Vc2FnZUF0dHJpYnV0ZXMoXG4gICAgICBzcGFuLFxuICAgICAgcmVzcG9uc2UudXNhZ2UuaW5wdXRfdG9rZW5zLFxuICAgICAgcmVzcG9uc2UudXNhZ2Uub3V0cHV0X3Rva2VucyxcbiAgICAgIHJlc3BvbnNlLnVzYWdlLnRvdGFsX3Rva2VucyxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQWRkIHJlc3BvbnNlIGF0dHJpYnV0ZXMgdG8gc3BhbnNcbiAqIFRoaXMgY3VycmVudGx5IHN1cHBvcnRzIGJvdGggQ2hhdCBDb21wbGV0aW9uIGFuZCBSZXNwb25zZXMgQVBJIHJlc3BvbnNlc1xuICovXG5mdW5jdGlvbiBhZGRSZXNwb25zZUF0dHJpYnV0ZXMoc3BhbiwgcmVzdWx0LCByZWNvcmRPdXRwdXRzKSB7XG4gIGlmICghcmVzdWx0IHx8IHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSByZXR1cm47XG5cbiAgY29uc3QgcmVzcG9uc2UgPSByZXN1bHQgO1xuXG4gIGlmIChpc0NoYXRDb21wbGV0aW9uUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgYWRkQ2hhdENvbXBsZXRpb25BdHRyaWJ1dGVzKHNwYW4sIHJlc3BvbnNlKTtcbiAgICBpZiAocmVjb3JkT3V0cHV0cyAmJiByZXNwb25zZS5jaG9pY2VzPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dHMgPSByZXNwb25zZS5jaG9pY2VzLm1hcChjaG9pY2UgPT4gY2hvaWNlLm1lc3NhZ2U/LmNvbnRlbnQgfHwgJycpO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHsgW0dFTl9BSV9SRVNQT05TRV9URVhUX0FUVFJJQlVURV06IEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlVGV4dHMpIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1Jlc3BvbnNlc0FwaVJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgIGFkZFJlc3BvbnNlc0FwaUF0dHJpYnV0ZXMoc3BhbiwgcmVzcG9uc2UpO1xuICAgIGlmIChyZWNvcmRPdXRwdXRzICYmIHJlc3BvbnNlLm91dHB1dF90ZXh0KSB7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoeyBbR0VOX0FJX1JFU1BPTlNFX1RFWFRfQVRUUklCVVRFXTogcmVzcG9uc2Uub3V0cHV0X3RleHQgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4dHJhY3QgYW5kIHJlY29yZCBBSSByZXF1ZXN0IGlucHV0cywgaWYgcHJlc2VudC4gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHNlcGFyYXRlIGZyb20gcmVzcG9uc2UgYXR0cmlidXRlcy5cbmZ1bmN0aW9uIGFkZFJlcXVlc3RBdHRyaWJ1dGVzKHNwYW4sIHBhcmFtcykge1xuICBpZiAoJ21lc3NhZ2VzJyBpbiBwYXJhbXMpIHtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZXMoeyBbR0VOX0FJX1JFUVVFU1RfTUVTU0FHRVNfQVRUUklCVVRFXTogSlNPTi5zdHJpbmdpZnkocGFyYW1zLm1lc3NhZ2VzKSB9KTtcbiAgfVxuICBpZiAoJ2lucHV0JyBpbiBwYXJhbXMpIHtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZXMoeyBbR0VOX0FJX1JFUVVFU1RfTUVTU0FHRVNfQVRUUklCVVRFXTogSlNPTi5zdHJpbmdpZnkocGFyYW1zLmlucHV0KSB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPcHRpb25zRnJvbUludGVncmF0aW9uKCkge1xuICBjb25zdCBzY29wZSA9IGdldEN1cnJlbnRTY29wZSgpO1xuICBjb25zdCBjbGllbnQgPSBzY29wZS5nZXRDbGllbnQoKTtcbiAgY29uc3QgaW50ZWdyYXRpb24gPSBjbGllbnQ/LmdldEludGVncmF0aW9uQnlOYW1lKE9QRU5BSV9JTlRFR1JBVElPTl9OQU1FKSA7XG4gIGNvbnN0IHNob3VsZFJlY29yZElucHV0c0FuZE91dHB1dHMgPSBpbnRlZ3JhdGlvbiA/IEJvb2xlYW4oY2xpZW50Py5nZXRPcHRpb25zKCkuc2VuZERlZmF1bHRQaWkpIDogZmFsc2U7XG5cbiAgcmV0dXJuIHtcbiAgICByZWNvcmRJbnB1dHM6IGludGVncmF0aW9uPy5vcHRpb25zPy5yZWNvcmRJbnB1dHMgPz8gc2hvdWxkUmVjb3JkSW5wdXRzQW5kT3V0cHV0cyxcbiAgICByZWNvcmRPdXRwdXRzOiBpbnRlZ3JhdGlvbj8ub3B0aW9ucz8ucmVjb3JkT3V0cHV0cyA/PyBzaG91bGRSZWNvcmRJbnB1dHNBbmRPdXRwdXRzLFxuICB9O1xufVxuXG4vKipcbiAqIEluc3RydW1lbnQgYSBtZXRob2Qgd2l0aCBTZW50cnkgc3BhbnNcbiAqIEZvbGxvd2luZyBTZW50cnkgQUkgQWdlbnRzIE1hbnVhbCBJbnN0cnVtZW50YXRpb24gY29udmVudGlvbnNcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNlbnRyeS5pby9wbGF0Zm9ybXMvamF2YXNjcmlwdC9ndWlkZXMvbm9kZS90cmFjaW5nL2luc3RydW1lbnRhdGlvbi9haS1hZ2VudHMtbW9kdWxlLyNtYW51YWwtaW5zdHJ1bWVudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGluc3RydW1lbnRNZXRob2QoXG4gIG9yaWdpbmFsTWV0aG9kLFxuICBtZXRob2RQYXRoLFxuICBjb250ZXh0LFxuICBvcHRpb25zLFxuKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBpbnN0cnVtZW50ZWRNZXRob2QoLi4uYXJncykge1xuICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IG9wdGlvbnMgfHwgZ2V0T3B0aW9uc0Zyb21JbnRlZ3JhdGlvbigpO1xuICAgIGNvbnN0IHJlcXVlc3RBdHRyaWJ1dGVzID0gZXh0cmFjdFJlcXVlc3RBdHRyaWJ1dGVzKGFyZ3MsIG1ldGhvZFBhdGgpO1xuICAgIGNvbnN0IG1vZGVsID0gKHJlcXVlc3RBdHRyaWJ1dGVzW0dFTl9BSV9SRVFVRVNUX01PREVMX0FUVFJJQlVURV0gKSB8fCAndW5rbm93bic7XG4gICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IGdldE9wZXJhdGlvbk5hbWUobWV0aG9kUGF0aCk7XG5cbiAgICByZXR1cm4gc3RhcnRTcGFuKFxuICAgICAge1xuICAgICAgICBuYW1lOiBgJHtvcGVyYXRpb25OYW1lfSAke21vZGVsfWAsXG4gICAgICAgIG9wOiBnZXRTcGFuT3BlcmF0aW9uKG1ldGhvZFBhdGgpLFxuICAgICAgICBhdHRyaWJ1dGVzOiByZXF1ZXN0QXR0cmlidXRlcyAsXG4gICAgICB9LFxuICAgICAgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoZmluYWxPcHRpb25zLnJlY29yZElucHV0cyAmJiBhcmdzWzBdICYmIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYWRkUmVxdWVzdEF0dHJpYnV0ZXMoc3BhbiwgYXJnc1swXSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9yaWdpbmFsTWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIC8vIFRPRE86IEFkZCBzdHJlYW1pbmcgc3VwcG9ydFxuICAgICAgICAgIGFkZFJlc3BvbnNlQXR0cmlidXRlcyhzcGFuLCByZXN1bHQsIGZpbmFsT3B0aW9ucy5yZWNvcmRPdXRwdXRzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVFeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVlcCBwcm94eSBmb3IgT3BlbkFJIGNsaWVudCBpbnN0cnVtZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVlcFByb3h5KHRhcmdldCwgY3VycmVudFBhdGggPSAnJywgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwge1xuICAgIGdldChvYmosIHByb3ApIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gKG9iaiApW3Byb3BdO1xuICAgICAgY29uc3QgbWV0aG9kUGF0aCA9IGJ1aWxkTWV0aG9kUGF0aChjdXJyZW50UGF0aCwgU3RyaW5nKHByb3ApKTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzaG91bGRJbnN0cnVtZW50KG1ldGhvZFBhdGgpKSB7XG4gICAgICAgIHJldHVybiBpbnN0cnVtZW50TWV0aG9kKHZhbHVlICwgbWV0aG9kUGF0aCwgb2JqLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBCaW5kIG5vbi1pbnN0cnVtZW50ZWQgZnVuY3Rpb25zIHRvIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBgdGhpc2AgY29udGV4dCxcbiAgICAgICAgLy8gd2hpY2ggaXMgcmVxdWlyZWQgZm9yIGFjY2Vzc2luZyBwcml2YXRlIGNsYXNzIGZpZWxkcyAoZS5nLiAjYmFzZVVSTCkgaW4gT3BlbkFJIFNESyB2NS5cbiAgICAgICAgcmV0dXJuIHZhbHVlLmJpbmQob2JqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlZXBQcm94eSh2YWx1ZSAsIG1ldGhvZFBhdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogSW5zdHJ1bWVudCBhbiBPcGVuQUkgY2xpZW50IHdpdGggU2VudHJ5IHRyYWNpbmdcbiAqIENhbiBiZSB1c2VkIGFjcm9zcyBOb2RlLmpzLCBDbG91ZGZsYXJlIFdvcmtlcnMsIGFuZCBWZXJjZWwgRWRnZVxuICovXG5mdW5jdGlvbiBpbnN0cnVtZW50T3BlbkFpQ2xpZW50KGNsaWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlRGVlcFByb3h5KGNsaWVudCwgJycsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgeyBpbnN0cnVtZW50T3BlbkFpQ2xpZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/openai/index.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1811` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractQueryParamsFromUrl: () => (/* binding */ extractQueryParamsFromUrl),\n/* harmony export */   headersToDict: () => (/* binding */ headersToDict),\n/* harmony export */   httpRequestToRequestData: () => (/* binding */ httpRequestToRequestData),\n/* harmony export */   winterCGHeadersToDict: () => (/* binding */ winterCGHeadersToDict),\n/* harmony export */   winterCGRequestToRequestData: () => (/* binding */ winterCGRequestToRequestData)\n/* harmony export */ });\n/**\n * Transforms a `Headers` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into a simple key-value dict.\n * The header keys will be lower case: e.g. A \"Content-Type\" header will be stored as \"content-type\".\n */\nfunction winterCGHeadersToDict(winterCGHeaders) {\n  const headers = {};\n  try {\n    winterCGHeaders.forEach((value, key) => {\n      if (typeof value === 'string') {\n        // We check that value is a string even though it might be redundant to make sure prototype pollution is not possible.\n        headers[key] = value;\n      }\n    });\n  } catch {\n    // just return the empty headers\n  }\n\n  return headers;\n}\n\n/**\n * Convert common request headers to a simple dictionary.\n */\nfunction headersToDict(reqHeaders) {\n  const headers = Object.create(null);\n\n  try {\n    Object.entries(reqHeaders).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        headers[key] = value;\n      }\n    });\n  } catch {\n    // just return the empty headers\n  }\n\n  return headers;\n}\n\n/**\n * Converts a `Request` object that implements the `Web Fetch API` (https://developer.mozilla.org/en-US/docs/Web/API/Headers) into the format that the `RequestData` integration understands.\n */\nfunction winterCGRequestToRequestData(req) {\n  const headers = winterCGHeadersToDict(req.headers);\n\n  return {\n    method: req.method,\n    url: req.url,\n    query_string: extractQueryParamsFromUrl(req.url),\n    headers,\n    // TODO: Can we extract body data from the request?\n  };\n}\n\n/**\n * Convert a HTTP request object to RequestEventData to be passed as normalizedRequest.\n * Instead of allowing `PolymorphicRequest` to be passed,\n * we want to be more specific and generally require a http.IncomingMessage-like object.\n */\nfunction httpRequestToRequestData(request\n\n) {\n  const headers = request.headers || {};\n\n  // Check for x-forwarded-host first, then fall back to host header\n  const forwardedHost = typeof headers['x-forwarded-host'] === 'string' ? headers['x-forwarded-host'] : undefined;\n  const host = forwardedHost || (typeof headers.host === 'string' ? headers.host : undefined);\n\n  // Check for x-forwarded-proto first, then fall back to existing protocol detection\n  const forwardedProto = typeof headers['x-forwarded-proto'] === 'string' ? headers['x-forwarded-proto'] : undefined;\n  const protocol = forwardedProto || request.protocol || (request.socket?.encrypted ? 'https' : 'http');\n\n  const url = request.url || '';\n\n  const absoluteUrl = getAbsoluteUrl({\n    url,\n    host,\n    protocol,\n  });\n\n  // This is non-standard, but may be sometimes set\n  // It may be overwritten later by our own body handling\n  const data = (request ).body || undefined;\n\n  // This is non-standard, but may be set on e.g. Next.js or Express requests\n  const cookies = (request ).cookies;\n\n  return {\n    url: absoluteUrl,\n    method: request.method,\n    query_string: extractQueryParamsFromUrl(url),\n    headers: headersToDict(headers),\n    cookies,\n    data,\n  };\n}\n\nfunction getAbsoluteUrl({\n  url,\n  protocol,\n  host,\n}\n\n) {\n  if (url?.startsWith('http')) {\n    return url;\n  }\n\n  if (url && host) {\n    return `${protocol}://${host}${url}`;\n  }\n\n  return undefined;\n}\n\n/** Extract the query params from an URL. */\nfunction extractQueryParamsFromUrl(url) {\n  // url is path and query string\n  if (!url) {\n    return;\n  }\n\n  try {\n    // The `URL` constructor can't handle internal URLs of the form `/some/path/here`, so stick a dummy protocol and\n    // hostname as the base. Since the point here is just to grab the query string, it doesn't matter what we use.\n    const queryParams = new URL(url, 'http://s.io').search.slice(1);\n    return queryParams.length ? queryParams : undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n\n//# sourceMappingURL=request.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVMsS0FBSyxLQUFLLEVBQUUsSUFBSTtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFbUk7QUFDbkkiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStjb3JlQDkuNDYuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy9yZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVHJhbnNmb3JtcyBhIGBIZWFkZXJzYCBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBgV2ViIEZldGNoIEFQSWAgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IZWFkZXJzKSBpbnRvIGEgc2ltcGxlIGtleS12YWx1ZSBkaWN0LlxuICogVGhlIGhlYWRlciBrZXlzIHdpbGwgYmUgbG93ZXIgY2FzZTogZS5nLiBBIFwiQ29udGVudC1UeXBlXCIgaGVhZGVyIHdpbGwgYmUgc3RvcmVkIGFzIFwiY29udGVudC10eXBlXCIuXG4gKi9cbmZ1bmN0aW9uIHdpbnRlckNHSGVhZGVyc1RvRGljdCh3aW50ZXJDR0hlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICB0cnkge1xuICAgIHdpbnRlckNHSGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBXZSBjaGVjayB0aGF0IHZhbHVlIGlzIGEgc3RyaW5nIGV2ZW4gdGhvdWdoIGl0IG1pZ2h0IGJlIHJlZHVuZGFudCB0byBtYWtlIHN1cmUgcHJvdG90eXBlIHBvbGx1dGlvbiBpcyBub3QgcG9zc2libGUuXG4gICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIHtcbiAgICAvLyBqdXN0IHJldHVybiB0aGUgZW1wdHkgaGVhZGVyc1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQ29udmVydCBjb21tb24gcmVxdWVzdCBoZWFkZXJzIHRvIGEgc2ltcGxlIGRpY3Rpb25hcnkuXG4gKi9cbmZ1bmN0aW9uIGhlYWRlcnNUb0RpY3QocmVxSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB0cnkge1xuICAgIE9iamVjdC5lbnRyaWVzKHJlcUhlYWRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBlbXB0eSBoZWFkZXJzXG4gIH1cblxuICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBSZXF1ZXN0YCBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBgV2ViIEZldGNoIEFQSWAgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IZWFkZXJzKSBpbnRvIHRoZSBmb3JtYXQgdGhhdCB0aGUgYFJlcXVlc3REYXRhYCBpbnRlZ3JhdGlvbiB1bmRlcnN0YW5kcy5cbiAqL1xuZnVuY3Rpb24gd2ludGVyQ0dSZXF1ZXN0VG9SZXF1ZXN0RGF0YShyZXEpIHtcbiAgY29uc3QgaGVhZGVycyA9IHdpbnRlckNHSGVhZGVyc1RvRGljdChyZXEuaGVhZGVycyk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgdXJsOiByZXEudXJsLFxuICAgIHF1ZXJ5X3N0cmluZzogZXh0cmFjdFF1ZXJ5UGFyYW1zRnJvbVVybChyZXEudXJsKSxcbiAgICBoZWFkZXJzLFxuICAgIC8vIFRPRE86IENhbiB3ZSBleHRyYWN0IGJvZHkgZGF0YSBmcm9tIHRoZSByZXF1ZXN0P1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBIVFRQIHJlcXVlc3Qgb2JqZWN0IHRvIFJlcXVlc3RFdmVudERhdGEgdG8gYmUgcGFzc2VkIGFzIG5vcm1hbGl6ZWRSZXF1ZXN0LlxuICogSW5zdGVhZCBvZiBhbGxvd2luZyBgUG9seW1vcnBoaWNSZXF1ZXN0YCB0byBiZSBwYXNzZWQsXG4gKiB3ZSB3YW50IHRvIGJlIG1vcmUgc3BlY2lmaWMgYW5kIGdlbmVyYWxseSByZXF1aXJlIGEgaHR0cC5JbmNvbWluZ01lc3NhZ2UtbGlrZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGh0dHBSZXF1ZXN0VG9SZXF1ZXN0RGF0YShyZXF1ZXN0XG5cbikge1xuICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIENoZWNrIGZvciB4LWZvcndhcmRlZC1ob3N0IGZpcnN0LCB0aGVuIGZhbGwgYmFjayB0byBob3N0IGhlYWRlclxuICBjb25zdCBmb3J3YXJkZWRIb3N0ID0gdHlwZW9mIGhlYWRlcnNbJ3gtZm9yd2FyZGVkLWhvc3QnXSA9PT0gJ3N0cmluZycgPyBoZWFkZXJzWyd4LWZvcndhcmRlZC1ob3N0J10gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGhvc3QgPSBmb3J3YXJkZWRIb3N0IHx8ICh0eXBlb2YgaGVhZGVycy5ob3N0ID09PSAnc3RyaW5nJyA/IGhlYWRlcnMuaG9zdCA6IHVuZGVmaW5lZCk7XG5cbiAgLy8gQ2hlY2sgZm9yIHgtZm9yd2FyZGVkLXByb3RvIGZpcnN0LCB0aGVuIGZhbGwgYmFjayB0byBleGlzdGluZyBwcm90b2NvbCBkZXRlY3Rpb25cbiAgY29uc3QgZm9yd2FyZGVkUHJvdG8gPSB0eXBlb2YgaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSA9PT0gJ3N0cmluZycgPyBoZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddIDogdW5kZWZpbmVkO1xuICBjb25zdCBwcm90b2NvbCA9IGZvcndhcmRlZFByb3RvIHx8IHJlcXVlc3QucHJvdG9jb2wgfHwgKHJlcXVlc3Quc29ja2V0Py5lbmNyeXB0ZWQgPyAnaHR0cHMnIDogJ2h0dHAnKTtcblxuICBjb25zdCB1cmwgPSByZXF1ZXN0LnVybCB8fCAnJztcblxuICBjb25zdCBhYnNvbHV0ZVVybCA9IGdldEFic29sdXRlVXJsKHtcbiAgICB1cmwsXG4gICAgaG9zdCxcbiAgICBwcm90b2NvbCxcbiAgfSk7XG5cbiAgLy8gVGhpcyBpcyBub24tc3RhbmRhcmQsIGJ1dCBtYXkgYmUgc29tZXRpbWVzIHNldFxuICAvLyBJdCBtYXkgYmUgb3ZlcndyaXR0ZW4gbGF0ZXIgYnkgb3VyIG93biBib2R5IGhhbmRsaW5nXG4gIGNvbnN0IGRhdGEgPSAocmVxdWVzdCApLmJvZHkgfHwgdW5kZWZpbmVkO1xuXG4gIC8vIFRoaXMgaXMgbm9uLXN0YW5kYXJkLCBidXQgbWF5IGJlIHNldCBvbiBlLmcuIE5leHQuanMgb3IgRXhwcmVzcyByZXF1ZXN0c1xuICBjb25zdCBjb29raWVzID0gKHJlcXVlc3QgKS5jb29raWVzO1xuXG4gIHJldHVybiB7XG4gICAgdXJsOiBhYnNvbHV0ZVVybCxcbiAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgIHF1ZXJ5X3N0cmluZzogZXh0cmFjdFF1ZXJ5UGFyYW1zRnJvbVVybCh1cmwpLFxuICAgIGhlYWRlcnM6IGhlYWRlcnNUb0RpY3QoaGVhZGVycyksXG4gICAgY29va2llcyxcbiAgICBkYXRhLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVVybCh7XG4gIHVybCxcbiAgcHJvdG9jb2wsXG4gIGhvc3QsXG59XG5cbikge1xuICBpZiAodXJsPy5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgaWYgKHVybCAmJiBob3N0KSB7XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfTovLyR7aG9zdH0ke3VybH1gO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqIEV4dHJhY3QgdGhlIHF1ZXJ5IHBhcmFtcyBmcm9tIGFuIFVSTC4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeVBhcmFtc0Zyb21VcmwodXJsKSB7XG4gIC8vIHVybCBpcyBwYXRoIGFuZCBxdWVyeSBzdHJpbmdcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoZSBgVVJMYCBjb25zdHJ1Y3RvciBjYW4ndCBoYW5kbGUgaW50ZXJuYWwgVVJMcyBvZiB0aGUgZm9ybSBgL3NvbWUvcGF0aC9oZXJlYCwgc28gc3RpY2sgYSBkdW1teSBwcm90b2NvbCBhbmRcbiAgICAvLyBob3N0bmFtZSBhcyB0aGUgYmFzZS4gU2luY2UgdGhlIHBvaW50IGhlcmUgaXMganVzdCB0byBncmFiIHRoZSBxdWVyeSBzdHJpbmcsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgd2UgdXNlLlxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTCh1cmwsICdodHRwOi8vcy5pbycpLnNlYXJjaC5zbGljZSgxKTtcbiAgICByZXR1cm4gcXVlcnlQYXJhbXMubGVuZ3RoID8gcXVlcnlQYXJhbXMgOiB1bmRlZmluZWQ7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgZXh0cmFjdFF1ZXJ5UGFyYW1zRnJvbVVybCwgaGVhZGVyc1RvRGljdCwgaHR0cFJlcXVlc3RUb1JlcXVlc3REYXRhLCB3aW50ZXJDR0hlYWRlcnNUb0RpY3QsIHdpbnRlckNHUmVxdWVzdFRvUmVxdWVzdERhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/request.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1899` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SyncPromise: () => (/* binding */ SyncPromise),\n/* harmony export */   rejectedSyncPromise: () => (/* binding */ rejectedSyncPromise),\n/* harmony export */   resolvedSyncPromise: () => (/* binding */ resolvedSyncPromise)\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/is.js\");\n\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/** SyncPromise internal states */\nconst STATE_PENDING = 0;\nconst STATE_RESOLVED = 1;\nconst STATE_REJECTED = 2;\n\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\nfunction resolvedSyncPromise(value) {\n  return new SyncPromise(resolve => {\n    resolve(value);\n  });\n}\n\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\nfunction rejectedSyncPromise(reason) {\n  return new SyncPromise((_, reject) => {\n    reject(reason);\n  });\n}\n\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\nclass SyncPromise {\n\n   constructor(executor) {\n    this._state = STATE_PENDING;\n    this._handlers = [];\n\n    this._runExecutor(executor);\n  }\n\n  /** @inheritdoc */\n   then(\n    onfulfilled,\n    onrejected,\n  ) {\n    return new SyncPromise((resolve, reject) => {\n      this._handlers.push([\n        false,\n        result => {\n          if (!onfulfilled) {\n            // TODO: \\_()_/\n            // TODO: FIXME\n            resolve(result );\n          } else {\n            try {\n              resolve(onfulfilled(result));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n        reason => {\n          if (!onrejected) {\n            reject(reason);\n          } else {\n            try {\n              resolve(onrejected(reason));\n            } catch (e) {\n              reject(e);\n            }\n          }\n        },\n      ]);\n      this._executeHandlers();\n    });\n  }\n\n  /** @inheritdoc */\n   catch(\n    onrejected,\n  ) {\n    return this.then(val => val, onrejected);\n  }\n\n  /** @inheritdoc */\n   finally(onfinally) {\n    return new SyncPromise((resolve, reject) => {\n      let val;\n      let isRejected;\n\n      return this.then(\n        value => {\n          isRejected = false;\n          val = value;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n        reason => {\n          isRejected = true;\n          val = reason;\n          if (onfinally) {\n            onfinally();\n          }\n        },\n      ).then(() => {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val );\n      });\n    });\n  }\n\n  /** Excute the resolve/reject handlers. */\n   _executeHandlers() {\n    if (this._state === STATE_PENDING) {\n      return;\n    }\n\n    const cachedHandlers = this._handlers.slice();\n    this._handlers = [];\n\n    cachedHandlers.forEach(handler => {\n      if (handler[0]) {\n        return;\n      }\n\n      if (this._state === STATE_RESOLVED) {\n        handler[1](this._value );\n      }\n\n      if (this._state === STATE_REJECTED) {\n        handler[2](this._value);\n      }\n\n      handler[0] = true;\n    });\n  }\n\n  /** Run the executor for the SyncPromise. */\n   _runExecutor(executor) {\n    const setResult = (state, value) => {\n      if (this._state !== STATE_PENDING) {\n        return;\n      }\n\n      if ((0,_is_js__WEBPACK_IMPORTED_MODULE_0__.isThenable)(value)) {\n        void (value ).then(resolve, reject);\n        return;\n      }\n\n      this._state = state;\n      this._value = value;\n\n      this._executeHandlers();\n    };\n\n    const resolve = (value) => {\n      setResult(STATE_RESOLVED, value);\n    };\n\n    const reject = (reason) => {\n      setResult(STATE_REJECTED, reason);\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  }\n}\n\n\n//# sourceMappingURL=syncpromise.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3N5bmNwcm9taXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsa0RBQVU7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRWlFO0FBQ2pFIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrY29yZUA5LjQ2LjAvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvc3luY3Byb21pc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUaGVuYWJsZSB9IGZyb20gJy4vaXMuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbi8qKiBTeW5jUHJvbWlzZSBpbnRlcm5hbCBzdGF0ZXMgKi9cbmNvbnN0IFNUQVRFX1BFTkRJTkcgPSAwO1xuY29uc3QgU1RBVEVfUkVTT0xWRUQgPSAxO1xuY29uc3QgU1RBVEVfUkVKRUNURUQgPSAyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXNvbHZlZCBzeW5jIHByb21pc2UuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGhcbiAqIEByZXR1cm5zIHRoZSByZXNvbHZlZCBzeW5jIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZWRTeW5jUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVqZWN0ZWQgc3luYyBwcm9taXNlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcmVqZWN0IHRoZSBwcm9taXNlIHdpdGhcbiAqIEByZXR1cm5zIHRoZSByZWplY3RlZCBzeW5jIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gcmVqZWN0ZWRTeW5jUHJvbWlzZShyZWFzb24pIHtcbiAgcmV0dXJuIG5ldyBTeW5jUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZW5hYmxlIGNsYXNzIHRoYXQgYmVoYXZlcyBsaWtlIGEgUHJvbWlzZSBhbmQgZm9sbG93cyBpdCdzIGludGVyZmFjZVxuICogYnV0IGlzIG5vdCBhc3luYyBpbnRlcm5hbGx5XG4gKi9cbmNsYXNzIFN5bmNQcm9taXNlIHtcblxuICAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IFNUQVRFX1BFTkRJTkc7XG4gICAgdGhpcy5faGFuZGxlcnMgPSBbXTtcblxuICAgIHRoaXMuX3J1bkV4ZWN1dG9yKGV4ZWN1dG9yKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgdGhlbihcbiAgICBvbmZ1bGZpbGxlZCxcbiAgICBvbnJlamVjdGVkLFxuICApIHtcbiAgICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZXJzLnB1c2goW1xuICAgICAgICBmYWxzZSxcbiAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICBpZiAoIW9uZnVsZmlsbGVkKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiDCr1xcXyjjg4QpXy/Cr1xuICAgICAgICAgICAgLy8gVE9ETzogRklYTUVcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc29sdmUob25mdWxmaWxsZWQocmVzdWx0KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKCFvbnJlamVjdGVkKSB7XG4gICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShvbnJlamVjdGVkKHJlYXNvbikpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgXSk7XG4gICAgICB0aGlzLl9leGVjdXRlSGFuZGxlcnMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgY2F0Y2goXG4gICAgb25yZWplY3RlZCxcbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2YWwgPT4gdmFsLCBvbnJlamVjdGVkKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgZmluYWxseShvbmZpbmFsbHkpIHtcbiAgICByZXR1cm4gbmV3IFN5bmNQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCB2YWw7XG4gICAgICBsZXQgaXNSZWplY3RlZDtcblxuICAgICAgcmV0dXJuIHRoaXMudGhlbihcbiAgICAgICAgdmFsdWUgPT4ge1xuICAgICAgICAgIGlzUmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAob25maW5hbGx5KSB7XG4gICAgICAgICAgICBvbmZpbmFsbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlYXNvbiA9PiB7XG4gICAgICAgICAgaXNSZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgdmFsID0gcmVhc29uO1xuICAgICAgICAgIGlmIChvbmZpbmFsbHkpIHtcbiAgICAgICAgICAgIG9uZmluYWxseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChpc1JlamVjdGVkKSB7XG4gICAgICAgICAgcmVqZWN0KHZhbCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSh2YWwgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEV4Y3V0ZSB0aGUgcmVzb2x2ZS9yZWplY3QgaGFuZGxlcnMuICovXG4gICBfZXhlY3V0ZUhhbmRsZXJzKCkge1xuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU1RBVEVfUEVORElORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlZEhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMuc2xpY2UoKTtcbiAgICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuXG4gICAgY2FjaGVkSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgIGlmIChoYW5kbGVyWzBdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBTVEFURV9SRVNPTFZFRCkge1xuICAgICAgICBoYW5kbGVyWzFdKHRoaXMuX3ZhbHVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQpIHtcbiAgICAgICAgaGFuZGxlclsyXSh0aGlzLl92YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXJbMF0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFJ1biB0aGUgZXhlY3V0b3IgZm9yIHRoZSBTeW5jUHJvbWlzZS4gKi9cbiAgIF9ydW5FeGVjdXRvcihleGVjdXRvcikge1xuICAgIGNvbnN0IHNldFJlc3VsdCA9IChzdGF0ZSwgdmFsdWUpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gU1RBVEVfUEVORElORykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgICB2b2lkICh2YWx1ZSApLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgdGhpcy5fZXhlY3V0ZUhhbmRsZXJzKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICAgIHNldFJlc3VsdChTVEFURV9SRVNPTFZFRCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBjb25zdCByZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICBzZXRSZXN1bHQoU1RBVEVfUkVKRUNURUQsIHJlYXNvbik7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgU3luY1Byb21pc2UsIHJlamVjdGVkU3luY1Byb21pc2UsIHJlc29sdmVkU3luY1Byb21pc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5bmNwcm9taXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/syncpromise.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1910` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   browserPerformanceTimeOrigin: () => (/* binding */ browserPerformanceTimeOrigin),\n/* harmony export */   dateTimestampInSeconds: () => (/* binding */ dateTimestampInSeconds),\n/* harmony export */   timestampInSeconds: () => (/* binding */ timestampInSeconds)\n/* harmony export */ });\n/* harmony import */ var _worldwide_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worldwide.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/worldwide.js\");\n\n\nconst ONE_SECOND_IN_MS = 1000;\n\n/**\n * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}\n * for accessing a high-resolution monotonic clock.\n */\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using the Date API.\n */\nfunction dateTimestampInSeconds() {\n  return Date.now() / ONE_SECOND_IN_MS;\n}\n\n/**\n * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not\n * support the API.\n *\n * Wrapping the native API works around differences in behavior from different browsers.\n */\nfunction createUnixTimestampInSecondsFunc() {\n  const { performance } = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ ;\n  // Some browser and environments don't have a performance or timeOrigin, so we fallback to\n  // using Date.now() to compute the starting time.\n  if (!performance?.now || !performance.timeOrigin) {\n    return dateTimestampInSeconds;\n  }\n\n  const timeOrigin = performance.timeOrigin;\n\n  // performance.now() is a monotonic clock, which means it starts at 0 when the process begins. To get the current\n  // wall clock time (actual UNIX timestamp), we need to add the starting time origin and the current time elapsed.\n  //\n  // TODO: This does not account for the case where the monotonic clock that powers performance.now() drifts from the\n  // wall clock time, which causes the returned timestamp to be inaccurate. We should investigate how to detect and\n  // correct for this.\n  // See: https://github.com/getsentry/sentry-javascript/issues/2590\n  // See: https://github.com/mdn/content/issues/4713\n  // See: https://dev.to/noamr/when-a-millisecond-is-not-a-millisecond-3h6\n  return () => {\n    return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;\n  };\n}\n\nlet _cachedTimestampInSeconds;\n\n/**\n * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the\n * availability of the Performance API.\n *\n * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is\n * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The\n * skew can grow to arbitrary amounts like days, weeks or months.\n * See https://github.com/getsentry/sentry-javascript/issues/2590.\n */\nfunction timestampInSeconds() {\n  // We store this in a closure so that we don't have to create a new function every time this is called.\n  const func = _cachedTimestampInSeconds ?? (_cachedTimestampInSeconds = createUnixTimestampInSecondsFunc());\n  return func();\n}\n\n/**\n * Cached result of getBrowserTimeOrigin.\n */\nlet cachedTimeOrigin;\n\n/**\n * Gets the time origin and the mode used to determine it.\n */\nfunction getBrowserTimeOrigin() {\n  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or\n  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin\n  // data as reliable if they are within a reasonable threshold of the current time.\n\n  const { performance } = _worldwide_js__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ ;\n  if (!performance?.now) {\n    return [undefined, 'none'];\n  }\n\n  const threshold = 3600 * 1000;\n  const performanceNow = performance.now();\n  const dateNow = Date.now();\n\n  // if timeOrigin isn't available set delta to threshold so it isn't used\n  const timeOriginDelta = performance.timeOrigin\n    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)\n    : threshold;\n  const timeOriginIsReliable = timeOriginDelta < threshold;\n\n  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin\n  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.\n  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always\n  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the\n  // Date API.\n  // eslint-disable-next-line deprecation/deprecation\n  const navigationStart = performance.timing?.navigationStart;\n  const hasNavigationStart = typeof navigationStart === 'number';\n  // if navigationStart isn't available set delta to threshold so it isn't used\n  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n  const navigationStartIsReliable = navigationStartDelta < threshold;\n\n  if (timeOriginIsReliable || navigationStartIsReliable) {\n    // Use the more reliable time origin\n    if (timeOriginDelta <= navigationStartDelta) {\n      return [performance.timeOrigin, 'timeOrigin'];\n    } else {\n      return [navigationStart, 'navigationStart'];\n    }\n  }\n\n  // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.\n  return [dateNow, 'dateNow'];\n}\n\n/**\n * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the\n * performance API is available.\n */\nfunction browserPerformanceTimeOrigin() {\n  if (!cachedTimeOrigin) {\n    cachedTimeOrigin = getBrowserTimeOrigin();\n  }\n\n  return cachedTimeOrigin[0];\n}\n\n\n//# sourceMappingURL=time.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3RpbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWMsRUFBRSxxREFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjLEVBQUUscURBQVU7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRW9GO0FBQ3BGIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrY29yZUA5LjQ2LjAvbm9kZV9tb2R1bGVzL0BzZW50cnkvY29yZS9idWlsZC9lc20vdXRpbHMvdGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnLi93b3JsZHdpZGUuanMnO1xuXG5jb25zdCBPTkVfU0VDT05EX0lOX01TID0gMTAwMDtcblxuLyoqXG4gKiBBIHBhcnRpYWwgZGVmaW5pdGlvbiBvZiB0aGUgW1BlcmZvcm1hbmNlIFdlYiBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZX1cbiAqIGZvciBhY2Nlc3NpbmcgYSBoaWdoLXJlc29sdXRpb24gbW9ub3RvbmljIGNsb2NrLlxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIHVzaW5nIHRoZSBEYXRlIEFQSS5cbiAqL1xuZnVuY3Rpb24gZGF0ZVRpbWVzdGFtcEluU2Vjb25kcygpIHtcbiAgcmV0dXJuIERhdGUubm93KCkgLyBPTkVfU0VDT05EX0lOX01TO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIFBlcmZvcm1hbmNlIEFQSSBicm93c2VyIGltcGxlbWVudGF0aW9uLCBvciB1bmRlZmluZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90XG4gKiBzdXBwb3J0IHRoZSBBUEkuXG4gKlxuICogV3JhcHBpbmcgdGhlIG5hdGl2ZSBBUEkgd29ya3MgYXJvdW5kIGRpZmZlcmVuY2VzIGluIGJlaGF2aW9yIGZyb20gZGlmZmVyZW50IGJyb3dzZXJzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVVbml4VGltZXN0YW1wSW5TZWNvbmRzRnVuYygpIHtcbiAgY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gR0xPQkFMX09CSiA7XG4gIC8vIFNvbWUgYnJvd3NlciBhbmQgZW52aXJvbm1lbnRzIGRvbid0IGhhdmUgYSBwZXJmb3JtYW5jZSBvciB0aW1lT3JpZ2luLCBzbyB3ZSBmYWxsYmFjayB0b1xuICAvLyB1c2luZyBEYXRlLm5vdygpIHRvIGNvbXB1dGUgdGhlIHN0YXJ0aW5nIHRpbWUuXG4gIGlmICghcGVyZm9ybWFuY2U/Lm5vdyB8fCAhcGVyZm9ybWFuY2UudGltZU9yaWdpbikge1xuICAgIHJldHVybiBkYXRlVGltZXN0YW1wSW5TZWNvbmRzO1xuICB9XG5cbiAgY29uc3QgdGltZU9yaWdpbiA9IHBlcmZvcm1hbmNlLnRpbWVPcmlnaW47XG5cbiAgLy8gcGVyZm9ybWFuY2Uubm93KCkgaXMgYSBtb25vdG9uaWMgY2xvY2ssIHdoaWNoIG1lYW5zIGl0IHN0YXJ0cyBhdCAwIHdoZW4gdGhlIHByb2Nlc3MgYmVnaW5zLiBUbyBnZXQgdGhlIGN1cnJlbnRcbiAgLy8gd2FsbCBjbG9jayB0aW1lIChhY3R1YWwgVU5JWCB0aW1lc3RhbXApLCB3ZSBuZWVkIHRvIGFkZCB0aGUgc3RhcnRpbmcgdGltZSBvcmlnaW4gYW5kIHRoZSBjdXJyZW50IHRpbWUgZWxhcHNlZC5cbiAgLy9cbiAgLy8gVE9ETzogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB0aGUgY2FzZSB3aGVyZSB0aGUgbW9ub3RvbmljIGNsb2NrIHRoYXQgcG93ZXJzIHBlcmZvcm1hbmNlLm5vdygpIGRyaWZ0cyBmcm9tIHRoZVxuICAvLyB3YWxsIGNsb2NrIHRpbWUsIHdoaWNoIGNhdXNlcyB0aGUgcmV0dXJuZWQgdGltZXN0YW1wIHRvIGJlIGluYWNjdXJhdGUuIFdlIHNob3VsZCBpbnZlc3RpZ2F0ZSBob3cgdG8gZGV0ZWN0IGFuZFxuICAvLyBjb3JyZWN0IGZvciB0aGlzLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvc2VudHJ5LWphdmFzY3JpcHQvaXNzdWVzLzI1OTBcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWRuL2NvbnRlbnQvaXNzdWVzLzQ3MTNcbiAgLy8gU2VlOiBodHRwczovL2Rldi50by9ub2Ftci93aGVuLWEtbWlsbGlzZWNvbmQtaXMtbm90LWEtbWlsbGlzZWNvbmQtM2g2XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmV0dXJuICh0aW1lT3JpZ2luICsgcGVyZm9ybWFuY2Uubm93KCkpIC8gT05FX1NFQ09ORF9JTl9NUztcbiAgfTtcbn1cblxubGV0IF9jYWNoZWRUaW1lc3RhbXBJblNlY29uZHM7XG5cbi8qKlxuICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzIHNpbmNlIHRoZSBVTklYIGVwb2NoIHVzaW5nIGVpdGhlciB0aGUgUGVyZm9ybWFuY2Ugb3IgRGF0ZSBBUElzLCBkZXBlbmRpbmcgb24gdGhlXG4gKiBhdmFpbGFiaWxpdHkgb2YgdGhlIFBlcmZvcm1hbmNlIEFQSS5cbiAqXG4gKiBCVUc6IE5vdGUgdGhhdCBiZWNhdXNlIG9mIGhvdyBicm93c2VycyBpbXBsZW1lbnQgdGhlIFBlcmZvcm1hbmNlIEFQSSwgdGhlIGNsb2NrIG1pZ2h0IHN0b3Agd2hlbiB0aGUgY29tcHV0ZXIgaXNcbiAqIGFzbGVlcC4gVGhpcyBjcmVhdGVzIGEgc2tldyBiZXR3ZWVuIGBkYXRlVGltZXN0YW1wSW5TZWNvbmRzYCBhbmQgYHRpbWVzdGFtcEluU2Vjb25kc2AuIFRoZVxuICogc2tldyBjYW4gZ3JvdyB0byBhcmJpdHJhcnkgYW1vdW50cyBsaWtlIGRheXMsIHdlZWtzIG9yIG1vbnRocy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8yNTkwLlxuICovXG5mdW5jdGlvbiB0aW1lc3RhbXBJblNlY29uZHMoKSB7XG4gIC8vIFdlIHN0b3JlIHRoaXMgaW4gYSBjbG9zdXJlIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gZXZlcnkgdGltZSB0aGlzIGlzIGNhbGxlZC5cbiAgY29uc3QgZnVuYyA9IF9jYWNoZWRUaW1lc3RhbXBJblNlY29uZHMgPz8gKF9jYWNoZWRUaW1lc3RhbXBJblNlY29uZHMgPSBjcmVhdGVVbml4VGltZXN0YW1wSW5TZWNvbmRzRnVuYygpKTtcbiAgcmV0dXJuIGZ1bmMoKTtcbn1cblxuLyoqXG4gKiBDYWNoZWQgcmVzdWx0IG9mIGdldEJyb3dzZXJUaW1lT3JpZ2luLlxuICovXG5sZXQgY2FjaGVkVGltZU9yaWdpbjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lIG9yaWdpbiBhbmQgdGhlIG1vZGUgdXNlZCB0byBkZXRlcm1pbmUgaXQuXG4gKi9cbmZ1bmN0aW9uIGdldEJyb3dzZXJUaW1lT3JpZ2luKCkge1xuICAvLyBVbmZvcnR1bmF0ZWx5IGJyb3dzZXJzIG1heSByZXBvcnQgYW4gaW5hY2N1cmF0ZSB0aW1lIG9yaWdpbiBkYXRhLCB0aHJvdWdoIGVpdGhlciBwZXJmb3JtYW5jZS50aW1lT3JpZ2luIG9yXG4gIC8vIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQsIHdoaWNoIHJlc3VsdHMgaW4gcG9vciByZXN1bHRzIGluIHBlcmZvcm1hbmNlIGRhdGEuIFdlIG9ubHkgdHJlYXQgdGltZSBvcmlnaW5cbiAgLy8gZGF0YSBhcyByZWxpYWJsZSBpZiB0aGV5IGFyZSB3aXRoaW4gYSByZWFzb25hYmxlIHRocmVzaG9sZCBvZiB0aGUgY3VycmVudCB0aW1lLlxuXG4gIGNvbnN0IHsgcGVyZm9ybWFuY2UgfSA9IEdMT0JBTF9PQkogO1xuICBpZiAoIXBlcmZvcm1hbmNlPy5ub3cpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgJ25vbmUnXTtcbiAgfVxuXG4gIGNvbnN0IHRocmVzaG9sZCA9IDM2MDAgKiAxMDAwO1xuICBjb25zdCBwZXJmb3JtYW5jZU5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCBkYXRlTm93ID0gRGF0ZS5ub3coKTtcblxuICAvLyBpZiB0aW1lT3JpZ2luIGlzbid0IGF2YWlsYWJsZSBzZXQgZGVsdGEgdG8gdGhyZXNob2xkIHNvIGl0IGlzbid0IHVzZWRcbiAgY29uc3QgdGltZU9yaWdpbkRlbHRhID0gcGVyZm9ybWFuY2UudGltZU9yaWdpblxuICAgID8gTWF0aC5hYnMocGVyZm9ybWFuY2UudGltZU9yaWdpbiArIHBlcmZvcm1hbmNlTm93IC0gZGF0ZU5vdylcbiAgICA6IHRocmVzaG9sZDtcbiAgY29uc3QgdGltZU9yaWdpbklzUmVsaWFibGUgPSB0aW1lT3JpZ2luRGVsdGEgPCB0aHJlc2hvbGQ7XG5cbiAgLy8gV2hpbGUgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4sIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW5cbiAgLy8gaXMgbm90IGFzIHdpZGVseSBzdXBwb3J0ZWQuIE5hbWVseSwgcGVyZm9ybWFuY2UudGltZU9yaWdpbiBpcyB1bmRlZmluZWQgaW4gU2FmYXJpIGFzIG9mIHdyaXRpbmcuXG4gIC8vIEFsc28gYXMgb2Ygd3JpdGluZywgcGVyZm9ybWFuY2UudGltaW5nIGlzIG5vdCBhdmFpbGFibGUgaW4gV2ViIFdvcmtlcnMgaW4gbWFpbnN0cmVhbSBicm93c2Vycywgc28gaXQgaXMgbm90IGFsd2F5c1xuICAvLyBhIHZhbGlkIGZhbGxiYWNrLiBJbiB0aGUgYWJzZW5jZSBvZiBhbiBpbml0aWFsIHRpbWUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIsIGZhbGxiYWNrIHRvIHRoZSBjdXJyZW50IHRpbWUgZnJvbSB0aGVcbiAgLy8gRGF0ZSBBUEkuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBjb25zdCBuYXZpZ2F0aW9uU3RhcnQgPSBwZXJmb3JtYW5jZS50aW1pbmc/Lm5hdmlnYXRpb25TdGFydDtcbiAgY29uc3QgaGFzTmF2aWdhdGlvblN0YXJ0ID0gdHlwZW9mIG5hdmlnYXRpb25TdGFydCA9PT0gJ251bWJlcic7XG4gIC8vIGlmIG5hdmlnYXRpb25TdGFydCBpc24ndCBhdmFpbGFibGUgc2V0IGRlbHRhIHRvIHRocmVzaG9sZCBzbyBpdCBpc24ndCB1c2VkXG4gIGNvbnN0IG5hdmlnYXRpb25TdGFydERlbHRhID0gaGFzTmF2aWdhdGlvblN0YXJ0ID8gTWF0aC5hYnMobmF2aWdhdGlvblN0YXJ0ICsgcGVyZm9ybWFuY2VOb3cgLSBkYXRlTm93KSA6IHRocmVzaG9sZDtcbiAgY29uc3QgbmF2aWdhdGlvblN0YXJ0SXNSZWxpYWJsZSA9IG5hdmlnYXRpb25TdGFydERlbHRhIDwgdGhyZXNob2xkO1xuXG4gIGlmICh0aW1lT3JpZ2luSXNSZWxpYWJsZSB8fCBuYXZpZ2F0aW9uU3RhcnRJc1JlbGlhYmxlKSB7XG4gICAgLy8gVXNlIHRoZSBtb3JlIHJlbGlhYmxlIHRpbWUgb3JpZ2luXG4gICAgaWYgKHRpbWVPcmlnaW5EZWx0YSA8PSBuYXZpZ2F0aW9uU3RhcnREZWx0YSkge1xuICAgICAgcmV0dXJuIFtwZXJmb3JtYW5jZS50aW1lT3JpZ2luLCAndGltZU9yaWdpbiddO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW25hdmlnYXRpb25TdGFydCwgJ25hdmlnYXRpb25TdGFydCddO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVpdGhlciBib3RoIHRpbWVPcmlnaW4gYW5kIG5hdmlnYXRpb25TdGFydCBhcmUgc2tld2VkIG9yIG5laXRoZXIgaXMgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBEYXRlLlxuICByZXR1cm4gW2RhdGVOb3csICdkYXRlTm93J107XG59XG5cbi8qKlxuICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIFVOSVggZXBvY2guIFRoaXMgdmFsdWUgaXMgb25seSB1c2FibGUgaW4gYSBicm93c2VyLCBhbmQgb25seSB3aGVuIHRoZVxuICogcGVyZm9ybWFuY2UgQVBJIGlzIGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbigpIHtcbiAgaWYgKCFjYWNoZWRUaW1lT3JpZ2luKSB7XG4gICAgY2FjaGVkVGltZU9yaWdpbiA9IGdldEJyb3dzZXJUaW1lT3JpZ2luKCk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVkVGltZU9yaWdpblswXTtcbn1cblxuZXhwb3J0IHsgYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbiwgZGF0ZVRpbWVzdGFtcEluU2Vjb25kcywgdGltZXN0YW1wSW5TZWNvbmRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/time.js\n"));
- `./frontend/.next/static/chunks/main-app.js:1954` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHttpSpanDetailsFromUrlObject: () => (/* binding */ getHttpSpanDetailsFromUrlObject),\n/* harmony export */   getSanitizedUrlString: () => (/* binding */ getSanitizedUrlString),\n/* harmony export */   getSanitizedUrlStringFromUrlObject: () => (/* binding */ getSanitizedUrlStringFromUrlObject),\n/* harmony export */   isURLObjectRelative: () => (/* binding */ isURLObjectRelative),\n/* harmony export */   parseStringToURLObject: () => (/* binding */ parseStringToURLObject),\n/* harmony export */   parseUrl: () => (/* binding */ parseUrl),\n/* harmony export */   stripUrlQueryAndFragment: () => (/* binding */ stripUrlQueryAndFragment)\n/* harmony export */ });\n/* harmony import */ var _semanticAttributes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../semanticAttributes.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/semanticAttributes.js\");\n\n\n// Curious about `thismessage:/`? See: https://www.rfc-editor.org/rfc/rfc2557.html\n//  > When the methods above do not yield an absolute URI, a base URL\n//  > of \"thismessage:/\" MUST be employed. This base URL has been\n//  > defined for the sole purpose of resolving relative references\n//  > within a multipart/related structure when no other base URI is\n//  > specified.\n//\n// We need to provide a base URL to `parseStringToURLObject` because the fetch API gives us a\n// relative URL sometimes.\n//\n// This is the only case where we need to provide a base URL to `parseStringToURLObject`\n// because the relative URL is not valid on its own.\nconst DEFAULT_BASE_URL = 'thismessage:/';\n\n/**\n * Checks if the URL object is relative\n *\n * @param url - The URL object to check\n * @returns True if the URL object is relative, false otherwise\n */\nfunction isURLObjectRelative(url) {\n  return 'isRelative' in url;\n}\n\n/**\n * Parses string to a URL object\n *\n * @param url - The URL to parse\n * @returns The parsed URL object or undefined if the URL is invalid\n */\nfunction parseStringToURLObject(url, urlBase) {\n  const isRelative = url.indexOf('://') <= 0 && url.indexOf('//') !== 0;\n  const base = urlBase ?? (isRelative ? DEFAULT_BASE_URL : undefined);\n  try {\n    // Use `canParse` to short-circuit the URL constructor if it's not a valid URL\n    // This is faster than trying to construct the URL and catching the error\n    // Node 20+, Chrome 120+, Firefox 115+, Safari 17+\n    if ('canParse' in URL && !(URL ).canParse(url, base)) {\n      return undefined;\n    }\n\n    const fullUrlObject = new URL(url, base);\n    if (isRelative) {\n      // Because we used a fake base URL, we need to return a relative URL object.\n      // We cannot return anything about the origin, host, etc. because it will refer to the fake base URL.\n      return {\n        isRelative,\n        pathname: fullUrlObject.pathname,\n        search: fullUrlObject.search,\n        hash: fullUrlObject.hash,\n      };\n    }\n    return fullUrlObject;\n  } catch {\n    // empty body\n  }\n\n  return undefined;\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span name\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nfunction getSanitizedUrlStringFromUrlObject(url) {\n  if (isURLObjectRelative(url)) {\n    return url.pathname;\n  }\n\n  const newUrl = new URL(url);\n  newUrl.search = '';\n  newUrl.hash = '';\n  if (['80', '443'].includes(newUrl.port)) {\n    newUrl.port = '';\n  }\n  if (newUrl.password) {\n    newUrl.password = '%filtered%';\n  }\n  if (newUrl.username) {\n    newUrl.username = '%filtered%';\n  }\n\n  return newUrl.toString();\n}\n\nfunction getHttpSpanNameFromUrlObject(\n  urlObject,\n  kind,\n  request,\n  routeName,\n) {\n  const method = request?.method?.toUpperCase() ?? 'GET';\n  const route = routeName\n    ? routeName\n    : urlObject\n      ? kind === 'client'\n        ? getSanitizedUrlStringFromUrlObject(urlObject)\n        : urlObject.pathname\n      : '/';\n\n  return `${method} ${route}`;\n}\n\n/**\n * Takes a parsed URL object and returns a set of attributes for the span\n * that represents the HTTP request for that url. This is used for both server\n * and client http spans.\n *\n * Follows https://opentelemetry.io/docs/specs/semconv/http/.\n *\n * @param urlObject - see {@link parseStringToURLObject}\n * @param kind - The type of HTTP operation (server or client)\n * @param spanOrigin - The origin of the span\n * @param request - The request object, see {@link PartialRequest}\n * @param routeName - The name of the route, must be low cardinality\n * @returns The span name and attributes for the HTTP operation\n */\nfunction getHttpSpanDetailsFromUrlObject(\n  urlObject,\n  kind,\n  spanOrigin,\n  request,\n  routeName,\n) {\n  const attributes = {\n    [_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n    [_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n  };\n\n  if (routeName) {\n    // This is based on https://opentelemetry.io/docs/specs/semconv/http/http-spans/#name\n    attributes[kind === 'server' ? 'http.route' : 'url.template'] = routeName;\n    attributes[_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';\n  }\n\n  if (request?.method) {\n    attributes[_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD] = request.method.toUpperCase();\n  }\n\n  if (urlObject) {\n    if (urlObject.search) {\n      attributes['url.query'] = urlObject.search;\n    }\n    if (urlObject.hash) {\n      attributes['url.fragment'] = urlObject.hash;\n    }\n    if (urlObject.pathname) {\n      attributes['url.path'] = urlObject.pathname;\n      if (urlObject.pathname === '/') {\n        attributes[_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';\n      }\n    }\n\n    if (!isURLObjectRelative(urlObject)) {\n      attributes[_semanticAttributes_js__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_URL_FULL] = urlObject.href;\n      if (urlObject.port) {\n        attributes['url.port'] = urlObject.port;\n      }\n      if (urlObject.protocol) {\n        attributes['url.scheme'] = urlObject.protocol;\n      }\n      if (urlObject.hostname) {\n        attributes[kind === 'server' ? 'server.address' : 'url.domain'] = urlObject.hostname;\n      }\n    }\n  }\n\n  return [getHttpSpanNameFromUrlObject(urlObject, kind, request, routeName), attributes];\n}\n\n/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url) {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    search: query,\n    hash: fragment,\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n  return (urlPath.split(/[?#]/, 1) )[0];\n}\n\n/**\n * Takes a URL object and returns a sanitized string which is safe to use as span name\n * see: https://develop.sentry.dev/sdk/data-handling/#structuring-data\n */\nfunction getSanitizedUrlString(url) {\n  const { protocol, host, path } = url;\n\n  const filteredHost =\n    host\n      // Always filter out authority\n      ?.replace(/^.*@/, '[filtered]:[filtered]@')\n      // Don't show standard :80 (http) and :443 (https) ports to reduce the noise\n      // TODO: Use new URL global if it exists\n      .replace(/(:80)$/, '')\n      .replace(/(:443)$/, '') || '';\n\n  return `${protocol ? `${protocol}://` : ''}${filteredHost}${path}`;\n}\n\n\n//# sourceMappingURL=url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K2NvcmVAOS40Ni4wL25vZGVfbW9kdWxlcy9Ac2VudHJ5L2NvcmUvYnVpbGQvZXNtL3V0aWxzL3VybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFtTDs7QUFFbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksUUFBUSxFQUFFLE1BQU07QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvRkFBZ0M7QUFDckMsS0FBSyxvRkFBZ0M7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRkFBZ0M7QUFDL0M7O0FBRUE7QUFDQSxlQUFlLDBGQUFzQztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvRkFBZ0M7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiwrRUFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksY0FBYyxTQUFTLFVBQVUsRUFBRSxhQUFhLEVBQUUsS0FBSztBQUNuRTs7QUFFdUw7QUFDdkwiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStjb3JlQDkuNDYuMC9ub2RlX21vZHVsZXMvQHNlbnRyeS9jb3JlL2J1aWxkL2VzbS91dGlscy91cmwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0UsIFNFTUFOVElDX0FUVFJJQlVURV9IVFRQX1JFUVVFU1RfTUVUSE9ELCBTRU1BTlRJQ19BVFRSSUJVVEVfVVJMX0ZVTEwsIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOIH0gZnJvbSAnLi4vc2VtYW50aWNBdHRyaWJ1dGVzLmpzJztcblxuLy8gQ3VyaW91cyBhYm91dCBgdGhpc21lc3NhZ2U6L2A/IFNlZTogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzI1NTcuaHRtbFxuLy8gID4gV2hlbiB0aGUgbWV0aG9kcyBhYm92ZSBkbyBub3QgeWllbGQgYW4gYWJzb2x1dGUgVVJJLCBhIGJhc2UgVVJMXG4vLyAgPiBvZiBcInRoaXNtZXNzYWdlOi9cIiBNVVNUIGJlIGVtcGxveWVkLiBUaGlzIGJhc2UgVVJMIGhhcyBiZWVuXG4vLyAgPiBkZWZpbmVkIGZvciB0aGUgc29sZSBwdXJwb3NlIG9mIHJlc29sdmluZyByZWxhdGl2ZSByZWZlcmVuY2VzXG4vLyAgPiB3aXRoaW4gYSBtdWx0aXBhcnQvcmVsYXRlZCBzdHJ1Y3R1cmUgd2hlbiBubyBvdGhlciBiYXNlIFVSSSBpc1xuLy8gID4gc3BlY2lmaWVkLlxuLy9cbi8vIFdlIG5lZWQgdG8gcHJvdmlkZSBhIGJhc2UgVVJMIHRvIGBwYXJzZVN0cmluZ1RvVVJMT2JqZWN0YCBiZWNhdXNlIHRoZSBmZXRjaCBBUEkgZ2l2ZXMgdXMgYVxuLy8gcmVsYXRpdmUgVVJMIHNvbWV0aW1lcy5cbi8vXG4vLyBUaGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBwcm92aWRlIGEgYmFzZSBVUkwgdG8gYHBhcnNlU3RyaW5nVG9VUkxPYmplY3RgXG4vLyBiZWNhdXNlIHRoZSByZWxhdGl2ZSBVUkwgaXMgbm90IHZhbGlkIG9uIGl0cyBvd24uXG5jb25zdCBERUZBVUxUX0JBU0VfVVJMID0gJ3RoaXNtZXNzYWdlOi8nO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgVVJMIG9iamVjdCBpcyByZWxhdGl2ZVxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIG9iamVjdCB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgVVJMIG9iamVjdCBpcyByZWxhdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMT2JqZWN0UmVsYXRpdmUodXJsKSB7XG4gIHJldHVybiAnaXNSZWxhdGl2ZScgaW4gdXJsO1xufVxuXG4vKipcbiAqIFBhcnNlcyBzdHJpbmcgdG8gYSBVUkwgb2JqZWN0XG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gcGFyc2VcbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgVVJMIG9iamVjdCBvciB1bmRlZmluZWQgaWYgdGhlIFVSTCBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nVG9VUkxPYmplY3QodXJsLCB1cmxCYXNlKSB7XG4gIGNvbnN0IGlzUmVsYXRpdmUgPSB1cmwuaW5kZXhPZignOi8vJykgPD0gMCAmJiB1cmwuaW5kZXhPZignLy8nKSAhPT0gMDtcbiAgY29uc3QgYmFzZSA9IHVybEJhc2UgPz8gKGlzUmVsYXRpdmUgPyBERUZBVUxUX0JBU0VfVVJMIDogdW5kZWZpbmVkKTtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYGNhblBhcnNlYCB0byBzaG9ydC1jaXJjdWl0IHRoZSBVUkwgY29uc3RydWN0b3IgaWYgaXQncyBub3QgYSB2YWxpZCBVUkxcbiAgICAvLyBUaGlzIGlzIGZhc3RlciB0aGFuIHRyeWluZyB0byBjb25zdHJ1Y3QgdGhlIFVSTCBhbmQgY2F0Y2hpbmcgdGhlIGVycm9yXG4gICAgLy8gTm9kZSAyMCssIENocm9tZSAxMjArLCBGaXJlZm94IDExNSssIFNhZmFyaSAxNytcbiAgICBpZiAoJ2NhblBhcnNlJyBpbiBVUkwgJiYgIShVUkwgKS5jYW5QYXJzZSh1cmwsIGJhc2UpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxVcmxPYmplY3QgPSBuZXcgVVJMKHVybCwgYmFzZSk7XG4gICAgaWYgKGlzUmVsYXRpdmUpIHtcbiAgICAgIC8vIEJlY2F1c2Ugd2UgdXNlZCBhIGZha2UgYmFzZSBVUkwsIHdlIG5lZWQgdG8gcmV0dXJuIGEgcmVsYXRpdmUgVVJMIG9iamVjdC5cbiAgICAgIC8vIFdlIGNhbm5vdCByZXR1cm4gYW55dGhpbmcgYWJvdXQgdGhlIG9yaWdpbiwgaG9zdCwgZXRjLiBiZWNhdXNlIGl0IHdpbGwgcmVmZXIgdG8gdGhlIGZha2UgYmFzZSBVUkwuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1JlbGF0aXZlLFxuICAgICAgICBwYXRobmFtZTogZnVsbFVybE9iamVjdC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiBmdWxsVXJsT2JqZWN0LnNlYXJjaCxcbiAgICAgICAgaGFzaDogZnVsbFVybE9iamVjdC5oYXNoLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bGxVcmxPYmplY3Q7XG4gIH0gY2F0Y2gge1xuICAgIC8vIGVtcHR5IGJvZHlcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGFrZXMgYSBVUkwgb2JqZWN0IGFuZCByZXR1cm5zIGEgc2FuaXRpemVkIHN0cmluZyB3aGljaCBpcyBzYWZlIHRvIHVzZSBhcyBzcGFuIG5hbWVcbiAqIHNlZTogaHR0cHM6Ly9kZXZlbG9wLnNlbnRyeS5kZXYvc2RrL2RhdGEtaGFuZGxpbmcvI3N0cnVjdHVyaW5nLWRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0U2FuaXRpemVkVXJsU3RyaW5nRnJvbVVybE9iamVjdCh1cmwpIHtcbiAgaWYgKGlzVVJMT2JqZWN0UmVsYXRpdmUodXJsKSkge1xuICAgIHJldHVybiB1cmwucGF0aG5hbWU7XG4gIH1cblxuICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKHVybCk7XG4gIG5ld1VybC5zZWFyY2ggPSAnJztcbiAgbmV3VXJsLmhhc2ggPSAnJztcbiAgaWYgKFsnODAnLCAnNDQzJ10uaW5jbHVkZXMobmV3VXJsLnBvcnQpKSB7XG4gICAgbmV3VXJsLnBvcnQgPSAnJztcbiAgfVxuICBpZiAobmV3VXJsLnBhc3N3b3JkKSB7XG4gICAgbmV3VXJsLnBhc3N3b3JkID0gJyVmaWx0ZXJlZCUnO1xuICB9XG4gIGlmIChuZXdVcmwudXNlcm5hbWUpIHtcbiAgICBuZXdVcmwudXNlcm5hbWUgPSAnJWZpbHRlcmVkJSc7XG4gIH1cblxuICByZXR1cm4gbmV3VXJsLnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGdldEh0dHBTcGFuTmFtZUZyb21VcmxPYmplY3QoXG4gIHVybE9iamVjdCxcbiAga2luZCxcbiAgcmVxdWVzdCxcbiAgcm91dGVOYW1lLFxuKSB7XG4gIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3Q/Lm1ldGhvZD8udG9VcHBlckNhc2UoKSA/PyAnR0VUJztcbiAgY29uc3Qgcm91dGUgPSByb3V0ZU5hbWVcbiAgICA/IHJvdXRlTmFtZVxuICAgIDogdXJsT2JqZWN0XG4gICAgICA/IGtpbmQgPT09ICdjbGllbnQnXG4gICAgICAgID8gZ2V0U2FuaXRpemVkVXJsU3RyaW5nRnJvbVVybE9iamVjdCh1cmxPYmplY3QpXG4gICAgICAgIDogdXJsT2JqZWN0LnBhdGhuYW1lXG4gICAgICA6ICcvJztcblxuICByZXR1cm4gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG59XG5cbi8qKlxuICogVGFrZXMgYSBwYXJzZWQgVVJMIG9iamVjdCBhbmQgcmV0dXJucyBhIHNldCBvZiBhdHRyaWJ1dGVzIGZvciB0aGUgc3BhblxuICogdGhhdCByZXByZXNlbnRzIHRoZSBIVFRQIHJlcXVlc3QgZm9yIHRoYXQgdXJsLiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggc2VydmVyXG4gKiBhbmQgY2xpZW50IGh0dHAgc3BhbnMuXG4gKlxuICogRm9sbG93cyBodHRwczovL29wZW50ZWxlbWV0cnkuaW8vZG9jcy9zcGVjcy9zZW1jb252L2h0dHAvLlxuICpcbiAqIEBwYXJhbSB1cmxPYmplY3QgLSBzZWUge0BsaW5rIHBhcnNlU3RyaW5nVG9VUkxPYmplY3R9XG4gKiBAcGFyYW0ga2luZCAtIFRoZSB0eXBlIG9mIEhUVFAgb3BlcmF0aW9uIChzZXJ2ZXIgb3IgY2xpZW50KVxuICogQHBhcmFtIHNwYW5PcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzcGFuXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IG9iamVjdCwgc2VlIHtAbGluayBQYXJ0aWFsUmVxdWVzdH1cbiAqIEBwYXJhbSByb3V0ZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcm91dGUsIG11c3QgYmUgbG93IGNhcmRpbmFsaXR5XG4gKiBAcmV0dXJucyBUaGUgc3BhbiBuYW1lIGFuZCBhdHRyaWJ1dGVzIGZvciB0aGUgSFRUUCBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0SHR0cFNwYW5EZXRhaWxzRnJvbVVybE9iamVjdChcbiAgdXJsT2JqZWN0LFxuICBraW5kLFxuICBzcGFuT3JpZ2luLFxuICByZXF1ZXN0LFxuICByb3V0ZU5hbWUsXG4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiBzcGFuT3JpZ2luLFxuICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICd1cmwnLFxuICB9O1xuXG4gIGlmIChyb3V0ZU5hbWUpIHtcbiAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIGh0dHBzOi8vb3BlbnRlbGVtZXRyeS5pby9kb2NzL3NwZWNzL3NlbWNvbnYvaHR0cC9odHRwLXNwYW5zLyNuYW1lXG4gICAgYXR0cmlidXRlc1traW5kID09PSAnc2VydmVyJyA/ICdodHRwLnJvdXRlJyA6ICd1cmwudGVtcGxhdGUnXSA9IHJvdXRlTmFtZTtcbiAgICBhdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA9ICdyb3V0ZSc7XG4gIH1cblxuICBpZiAocmVxdWVzdD8ubWV0aG9kKSB7XG4gICAgYXR0cmlidXRlc1tTRU1BTlRJQ19BVFRSSUJVVEVfSFRUUF9SRVFVRVNUX01FVEhPRF0gPSByZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICB9XG5cbiAgaWYgKHVybE9iamVjdCkge1xuICAgIGlmICh1cmxPYmplY3Quc2VhcmNoKSB7XG4gICAgICBhdHRyaWJ1dGVzWyd1cmwucXVlcnknXSA9IHVybE9iamVjdC5zZWFyY2g7XG4gICAgfVxuICAgIGlmICh1cmxPYmplY3QuaGFzaCkge1xuICAgICAgYXR0cmlidXRlc1sndXJsLmZyYWdtZW50J10gPSB1cmxPYmplY3QuaGFzaDtcbiAgICB9XG4gICAgaWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuICAgICAgYXR0cmlidXRlc1sndXJsLnBhdGgnXSA9IHVybE9iamVjdC5wYXRobmFtZTtcbiAgICAgIGlmICh1cmxPYmplY3QucGF0aG5hbWUgPT09ICcvJykge1xuICAgICAgICBhdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA9ICdyb3V0ZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc1VSTE9iamVjdFJlbGF0aXZlKHVybE9iamVjdCkpIHtcbiAgICAgIGF0dHJpYnV0ZXNbU0VNQU5USUNfQVRUUklCVVRFX1VSTF9GVUxMXSA9IHVybE9iamVjdC5ocmVmO1xuICAgICAgaWYgKHVybE9iamVjdC5wb3J0KSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbJ3VybC5wb3J0J10gPSB1cmxPYmplY3QucG9ydDtcbiAgICAgIH1cbiAgICAgIGlmICh1cmxPYmplY3QucHJvdG9jb2wpIHtcbiAgICAgICAgYXR0cmlidXRlc1sndXJsLnNjaGVtZSddID0gdXJsT2JqZWN0LnByb3RvY29sO1xuICAgICAgfVxuICAgICAgaWYgKHVybE9iamVjdC5ob3N0bmFtZSkge1xuICAgICAgICBhdHRyaWJ1dGVzW2tpbmQgPT09ICdzZXJ2ZXInID8gJ3NlcnZlci5hZGRyZXNzJyA6ICd1cmwuZG9tYWluJ10gPSB1cmxPYmplY3QuaG9zdG5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtnZXRIdHRwU3Bhbk5hbWVGcm9tVXJsT2JqZWN0KHVybE9iamVjdCwga2luZCwgcmVxdWVzdCwgcm91dGVOYW1lKSwgYXR0cmlidXRlc107XG59XG5cbi8qKlxuICogUGFyc2VzIHN0cmluZyBmb3JtIG9mIFVSTCBpbnRvIGFuIG9iamVjdFxuICogLy8gYm9ycm93ZWQgZnJvbSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1CXG4gKiAvLyBpbnRlbnRpb25hbGx5IHVzaW5nIHJlZ2V4IGFuZCBub3QgPGEvPiBocmVmIHBhcnNpbmcgdHJpY2sgYmVjYXVzZSBSZWFjdCBOYXRpdmUgYW5kIG90aGVyXG4gKiAvLyBlbnZpcm9ubWVudHMgd2hlcmUgRE9NIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGVcbiAqIEByZXR1cm5zIHBhcnNlZCBVUkwgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKC9eKChbXjovPyNdKyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPyQvKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gY29lcmNlIHRvIHVuZGVmaW5lZCB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5nIHNvIHdlIGRvbid0IGdldCAndW5kZWZpbmVkJ1xuICBjb25zdCBxdWVyeSA9IG1hdGNoWzZdIHx8ICcnO1xuICBjb25zdCBmcmFnbWVudCA9IG1hdGNoWzhdIHx8ICcnO1xuICByZXR1cm4ge1xuICAgIGhvc3Q6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdLFxuICAgIHByb3RvY29sOiBtYXRjaFsyXSxcbiAgICBzZWFyY2g6IHF1ZXJ5LFxuICAgIGhhc2g6IGZyYWdtZW50LFxuICAgIHJlbGF0aXZlOiBtYXRjaFs1XSArIHF1ZXJ5ICsgZnJhZ21lbnQsIC8vIGV2ZXJ5dGhpbmcgbWludXMgb3JpZ2luXG4gIH07XG59XG5cbi8qKlxuICogU3RyaXAgdGhlIHF1ZXJ5IHN0cmluZyBhbmQgZnJhZ21lbnQgb2ZmIG9mIGEgZ2l2ZW4gVVJMIG9yIHBhdGggKGlmIHByZXNlbnQpXG4gKlxuICogQHBhcmFtIHVybFBhdGggRnVsbCBVUkwgb3IgcGF0aCwgaW5jbHVkaW5nIHBvc3NpYmxlIHF1ZXJ5IHN0cmluZyBhbmQvb3IgZnJhZ21lbnRcbiAqIEByZXR1cm5zIFVSTCBvciBwYXRoIHdpdGhvdXQgcXVlcnkgc3RyaW5nIG9yIGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIHN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudCh1cmxQYXRoKSB7XG4gIHJldHVybiAodXJsUGF0aC5zcGxpdCgvWz8jXS8sIDEpIClbMF07XG59XG5cbi8qKlxuICogVGFrZXMgYSBVUkwgb2JqZWN0IGFuZCByZXR1cm5zIGEgc2FuaXRpemVkIHN0cmluZyB3aGljaCBpcyBzYWZlIHRvIHVzZSBhcyBzcGFuIG5hbWVcbiAqIHNlZTogaHR0cHM6Ly9kZXZlbG9wLnNlbnRyeS5kZXYvc2RrL2RhdGEtaGFuZGxpbmcvI3N0cnVjdHVyaW5nLWRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0U2FuaXRpemVkVXJsU3RyaW5nKHVybCkge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0LCBwYXRoIH0gPSB1cmw7XG5cbiAgY29uc3QgZmlsdGVyZWRIb3N0ID1cbiAgICBob3N0XG4gICAgICAvLyBBbHdheXMgZmlsdGVyIG91dCBhdXRob3JpdHlcbiAgICAgID8ucmVwbGFjZSgvXi4qQC8sICdbZmlsdGVyZWRdOltmaWx0ZXJlZF1AJylcbiAgICAgIC8vIERvbid0IHNob3cgc3RhbmRhcmQgOjgwIChodHRwKSBhbmQgOjQ0MyAoaHR0cHMpIHBvcnRzIHRvIHJlZHVjZSB0aGUgbm9pc2VcbiAgICAgIC8vIFRPRE86IFVzZSBuZXcgVVJMIGdsb2JhbCBpZiBpdCBleGlzdHNcbiAgICAgIC5yZXBsYWNlKC8oOjgwKSQvLCAnJylcbiAgICAgIC5yZXBsYWNlKC8oOjQ0MykkLywgJycpIHx8ICcnO1xuXG4gIHJldHVybiBgJHtwcm90b2NvbCA/IGAke3Byb3RvY29sfTovL2AgOiAnJ30ke2ZpbHRlcmVkSG9zdH0ke3BhdGh9YDtcbn1cblxuZXhwb3J0IHsgZ2V0SHR0cFNwYW5EZXRhaWxzRnJvbVVybE9iamVjdCwgZ2V0U2FuaXRpemVkVXJsU3RyaW5nLCBnZXRTYW5pdGl6ZWRVcmxTdHJpbmdGcm9tVXJsT2JqZWN0LCBpc1VSTE9iamVjdFJlbGF0aXZlLCBwYXJzZVN0cmluZ1RvVVJMT2JqZWN0LCBwYXJzZVVybCwgc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/utils/url.js\n"));
- `./frontend/.next/static/chunks/main-app.js:2097` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pagesRouterInstrumentNavigation: () => (/* binding */ pagesRouterInstrumentNavigation),\n/* harmony export */   pagesRouterInstrumentPageLoad: () => (/* binding */ pagesRouterInstrumentPageLoad)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/index.js\");\n/* harmony import */ var _sentry_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/react */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+react@9.46.0_react@19.1.1/node_modules/@sentry/react/build/esm/index.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_@babel+core@7.28.3_@opentelemetry+api@1.9.0_@playwright+test@1.55.0_react-d_5cb839d67a79b5bc53dfde1d42b0ad7b/node_modules/next/dist/api/router.js\");\n/* harmony import */ var _common_debug_build_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/debug-build.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+nextjs@9.46.0_@opentelemetry+context-async-hooks@1.30.1_@opentelemetry+api@1.9._42796a51c56a345b0bf099c431630b51/node_modules/@sentry/nextjs/build/esm/common/debug-build.js\");\n\n\n\n\n\n// next/router v10 is CJS\n//\n// For ESM/CJS interoperability 'reasons', depending on how this file is loaded, Router might be on the default export\nconst Router = next_router__WEBPACK_IMPORTED_MODULE_2__[\"default\"].events\n  ? next_router__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n  : next_router__WEBPACK_IMPORTED_MODULE_2__[\"default\"][\"default\"];\n\nconst globalObject = _sentry_react__WEBPACK_IMPORTED_MODULE_1__.WINDOW\n\n;\n\n/**\n * Describes data located in the __NEXT_DATA__ script tag. This tag is present on every page of a Next.js app.\n */\n\n/**\n * Every Next.js page (static and dynamic ones) comes with a script tag with the id \"__NEXT_DATA__\". This script tag\n * contains a JSON object with data that was either generated at build time for static pages (`getStaticProps`), or at\n * runtime with data fetchers like `getServerSideProps.`.\n *\n * We can use this information to:\n * - Always get the parameterized route we're in when loading a page.\n * - Send trace information (trace-id, baggage) from the server to the client.\n *\n * This function extracts this information.\n */\nfunction extractNextDataTagInformation() {\n  let nextData;\n  // Let's be on the safe side and actually check first if there is really a __NEXT_DATA__ script tag on the page.\n  // Theoretically this should always be the case though.\n  const nextDataTag = globalObject.document.getElementById('__NEXT_DATA__');\n  if (nextDataTag?.innerHTML) {\n    try {\n      nextData = JSON.parse(nextDataTag.innerHTML);\n    } catch {\n      _common_debug_build_js__WEBPACK_IMPORTED_MODULE_3__.DEBUG_BUILD && _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.warn('Could not extract __NEXT_DATA__');\n    }\n  }\n\n  if (!nextData) {\n    return {};\n  }\n\n  const nextDataTagInfo = {};\n\n  const { page, query, props } = nextData;\n\n  // `nextData.page` always contains the parameterized route - except for when an error occurs in a data fetching\n  // function, then it is \"/_error\", but that isn't a problem since users know which route threw by looking at the\n  // parent transaction\n  // TODO: Actually this is a problem (even though it is not that big), because the DSC and the transaction payload will contain\n  // a different transaction name. Maybe we can fix this. Idea: Also send transaction name via pageProps when available.\n  nextDataTagInfo.route = page;\n  nextDataTagInfo.params = query;\n\n  if (props?.pageProps) {\n    nextDataTagInfo.sentryTrace = props.pageProps._sentryTraceData;\n    nextDataTagInfo.baggage = props.pageProps._sentryBaggage;\n  }\n\n  return nextDataTagInfo;\n}\n\n/**\n * Instruments the Next.js pages router for pageloads.\n * Only supported for client side routing. Works for Next >= 10.\n *\n * Leverages the SingletonRouter from the `next/router` to\n * generate pageload/navigation transactions and parameterize\n * transaction names.\n */\nfunction pagesRouterInstrumentPageLoad(client) {\n  const { route, params, sentryTrace, baggage } = extractNextDataTagInformation();\n  const parsedBaggage = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.parseBaggageHeader)(baggage);\n  let name = route || globalObject.location.pathname;\n\n  // /_error is the fallback page for all errors. If there is a transaction name for /_error, use that instead\n  if (parsedBaggage?.['sentry-transaction'] && name === '/_error') {\n    name = parsedBaggage['sentry-transaction'];\n    // Strip any HTTP method from the span name\n    name = name.replace(/^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS|TRACE|CONNECT)\\s+/i, '');\n  }\n\n  const origin = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.browserPerformanceTimeOrigin)();\n  (0,_sentry_react__WEBPACK_IMPORTED_MODULE_1__.startBrowserTracingPageLoadSpan)(\n    client,\n    {\n      name,\n      // pageload should always start at timeOrigin (and needs to be in s, not ms)\n      startTime: origin ? origin / 1000 : undefined,\n      attributes: {\n        [_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n        [_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.nextjs.pages_router_instrumentation',\n        [_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: route ? 'route' : 'url',\n        ...(params && client.getOptions().sendDefaultPii && { ...params }),\n      },\n    },\n    { sentryTrace, baggage },\n  );\n}\n\n/**\n * Instruments the Next.js pages router for navigation.\n * Only supported for client side routing. Works for Next >= 10.\n *\n * Leverages the SingletonRouter from the `next/router` to\n * generate pageload/navigation transactions and parameterize\n * transaction names.\n */\nfunction pagesRouterInstrumentNavigation(client) {\n  Router.events.on('routeChangeStart', (navigationTarget) => {\n    const strippedNavigationTarget = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.stripUrlQueryAndFragment)(navigationTarget);\n    const matchedRoute = getNextRouteFromPathname(strippedNavigationTarget);\n\n    let newLocation;\n    let spanSource;\n\n    if (matchedRoute) {\n      newLocation = matchedRoute;\n      spanSource = 'route';\n    } else {\n      newLocation = strippedNavigationTarget;\n      spanSource = 'url';\n    }\n\n    (0,_sentry_react__WEBPACK_IMPORTED_MODULE_1__.startBrowserTracingNavigationSpan)(client, {\n      name: newLocation,\n      attributes: {\n        [_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n        [_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.nextjs.pages_router_instrumentation',\n        [_sentry_core__WEBPACK_IMPORTED_MODULE_0__.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: spanSource,\n      },\n    });\n  });\n}\n\nfunction getNextRouteFromPathname(pathname) {\n  const pageRoutes = globalObject.__BUILD_MANIFEST?.sortedPages;\n\n  // Page route should in 99.999% of the cases be defined by now but just to be sure we make a check here\n  if (!pageRoutes) {\n    return;\n  }\n\n  return pageRoutes.find(route => {\n    const routeRegExp = convertNextRouteToRegExp(route);\n    return pathname.match(routeRegExp);\n  });\n}\n\n/**\n * Converts a Next.js style route to a regular expression that matches on pathnames (no query params or URL fragments).\n *\n * In general this involves replacing any instances of square brackets in a route with a wildcard:\n * e.g. \"/users/[id]/info\" becomes /\\/users\\/([^/]+?)\\/info/\n *\n * Some additional edgecases need to be considered:\n * - All routes have an optional slash at the end, meaning users can navigate to \"/users/[id]/info\" or\n *   \"/users/[id]/info/\" - both will be resolved to \"/users/[id]/info\".\n * - Non-optional \"catchall\"s at the end of a route must be considered when matching (e.g. \"/users/[...params]\").\n * - Optional \"catchall\"s at the end of a route must be considered when matching (e.g. \"/users/[[...params]]\").\n *\n * @param route A Next.js style route as it is found in `global.__BUILD_MANIFEST.sortedPages`\n */\nfunction convertNextRouteToRegExp(route) {\n  // We can assume a route is at least \"/\".\n  const routeParts = route.split('/');\n\n  let optionalCatchallWildcardRegex = '';\n  if (routeParts[routeParts.length - 1]?.match(/^\\[\\[\\.\\.\\..+\\]\\]$/)) {\n    // If last route part has pattern \"[[...xyz]]\" we pop the latest route part to get rid of the required trailing\n    // slash that would come before it if we didn't pop it.\n    routeParts.pop();\n    optionalCatchallWildcardRegex = '(?:/(.+?))?';\n  }\n\n  const rejoinedRouteParts = routeParts\n    .map(\n      routePart =>\n        routePart\n          .replace(/^\\[\\.\\.\\..+\\]$/, '(.+?)') // Replace catch all wildcard with regex wildcard\n          .replace(/^\\[.*\\]$/, '([^/]+?)'), // Replace route wildcards with lazy regex wildcards\n    )\n    .join('/');\n\n  // eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor -- routeParts are from the build manifest, so no raw user input\n  return new RegExp(\n    `^${rejoinedRouteParts}${optionalCatchallWildcardRegex}(?:/)?$`, // optional slash at the end\n  );\n}\n\n\n//# sourceMappingURL=pagesRouterRoutingInstrumentation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K25leHRqc0A5LjQ2LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AxLjMwLjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS5fNDI3OTZhNTFjNTZhMzQ1YjBiZjA5OWM0MzE2MzBiNTEvbm9kZV9tb2R1bGVzL0BzZW50cnkvbmV4dGpzL2J1aWxkL2VzbS9jbGllbnQvcm91dGluZy9wYWdlc1JvdXRlclJvdXRpbmdJbnN0cnVtZW50YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1OO0FBQ3hHO0FBQ3BFO0FBQ21COztBQUUxRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFtQjtBQUNsQyxJQUFJLG1EQUFZO0FBQ2hCLElBQUksOERBQXVCOztBQUUzQixxQkFBcUIsaURBQU07O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNLCtEQUFXLElBQUksK0NBQUs7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxxQkFBcUI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQ0FBc0M7QUFDaEQsd0JBQXdCLGdFQUFrQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDBFQUE0QjtBQUM3QyxFQUFFLDhFQUErQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNFQUE0QjtBQUNyQyxTQUFTLDBFQUFnQztBQUN6QyxTQUFTLDBFQUFnQztBQUN6Qyw4REFBOEQsV0FBVztBQUN6RSxPQUFPO0FBQ1AsS0FBSztBQUNMLE1BQU0sc0JBQXNCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0VBQXdCO0FBQzdEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGdGQUFpQztBQUNyQztBQUNBO0FBQ0EsU0FBUyxzRUFBNEI7QUFDckMsU0FBUywwRUFBZ0M7QUFDekMsU0FBUywwRUFBZ0M7QUFDekMsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQixFQUFFLDhCQUE4QjtBQUMzRDtBQUNBOztBQUUwRTtBQUMxRSIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K25leHRqc0A5LjQ2LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AxLjMwLjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS5fNDI3OTZhNTFjNTZhMzQ1YjBiZjA5OWM0MzE2MzBiNTEvbm9kZV9tb2R1bGVzL0BzZW50cnkvbmV4dGpzL2J1aWxkL2VzbS9jbGllbnQvcm91dGluZy9wYWdlc1JvdXRlclJvdXRpbmdJbnN0cnVtZW50YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50LCBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSwgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU4sIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1AsIHBhcnNlQmFnZ2FnZUhlYWRlciwgYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbiwgZGVidWcgfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHsgc3RhcnRCcm93c2VyVHJhY2luZ05hdmlnYXRpb25TcGFuLCBXSU5ET1csIHN0YXJ0QnJvd3NlclRyYWNpbmdQYWdlTG9hZFNwYW4gfSBmcm9tICdAc2VudHJ5L3JlYWN0JztcbmltcG9ydCBSb3V0ZXJJbXBvcnQgZnJvbSAnbmV4dC9yb3V0ZXInO1xuaW1wb3J0IHsgREVCVUdfQlVJTEQgfSBmcm9tICcuLi8uLi9jb21tb24vZGVidWctYnVpbGQuanMnO1xuXG4vLyBuZXh0L3JvdXRlciB2MTAgaXMgQ0pTXG4vL1xuLy8gRm9yIEVTTS9DSlMgaW50ZXJvcGVyYWJpbGl0eSAncmVhc29ucycsIGRlcGVuZGluZyBvbiBob3cgdGhpcyBmaWxlIGlzIGxvYWRlZCwgUm91dGVyIG1pZ2h0IGJlIG9uIHRoZSBkZWZhdWx0IGV4cG9ydFxuY29uc3QgUm91dGVyID0gUm91dGVySW1wb3J0LmV2ZW50c1xuICA/IFJvdXRlckltcG9ydFxuICA6IChSb3V0ZXJJbXBvcnQgKS5kZWZhdWx0O1xuXG5jb25zdCBnbG9iYWxPYmplY3QgPSBXSU5ET1dcblxuO1xuXG4vKipcbiAqIERlc2NyaWJlcyBkYXRhIGxvY2F0ZWQgaW4gdGhlIF9fTkVYVF9EQVRBX18gc2NyaXB0IHRhZy4gVGhpcyB0YWcgaXMgcHJlc2VudCBvbiBldmVyeSBwYWdlIG9mIGEgTmV4dC5qcyBhcHAuXG4gKi9cblxuLyoqXG4gKiBFdmVyeSBOZXh0LmpzIHBhZ2UgKHN0YXRpYyBhbmQgZHluYW1pYyBvbmVzKSBjb21lcyB3aXRoIGEgc2NyaXB0IHRhZyB3aXRoIHRoZSBpZCBcIl9fTkVYVF9EQVRBX19cIi4gVGhpcyBzY3JpcHQgdGFnXG4gKiBjb250YWlucyBhIEpTT04gb2JqZWN0IHdpdGggZGF0YSB0aGF0IHdhcyBlaXRoZXIgZ2VuZXJhdGVkIGF0IGJ1aWxkIHRpbWUgZm9yIHN0YXRpYyBwYWdlcyAoYGdldFN0YXRpY1Byb3BzYCksIG9yIGF0XG4gKiBydW50aW1lIHdpdGggZGF0YSBmZXRjaGVycyBsaWtlIGBnZXRTZXJ2ZXJTaWRlUHJvcHMuYC5cbiAqXG4gKiBXZSBjYW4gdXNlIHRoaXMgaW5mb3JtYXRpb24gdG86XG4gKiAtIEFsd2F5cyBnZXQgdGhlIHBhcmFtZXRlcml6ZWQgcm91dGUgd2UncmUgaW4gd2hlbiBsb2FkaW5nIGEgcGFnZS5cbiAqIC0gU2VuZCB0cmFjZSBpbmZvcm1hdGlvbiAodHJhY2UtaWQsIGJhZ2dhZ2UpIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZXh0cmFjdHMgdGhpcyBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdE5leHREYXRhVGFnSW5mb3JtYXRpb24oKSB7XG4gIGxldCBuZXh0RGF0YTtcbiAgLy8gTGV0J3MgYmUgb24gdGhlIHNhZmUgc2lkZSBhbmQgYWN0dWFsbHkgY2hlY2sgZmlyc3QgaWYgdGhlcmUgaXMgcmVhbGx5IGEgX19ORVhUX0RBVEFfXyBzY3JpcHQgdGFnIG9uIHRoZSBwYWdlLlxuICAvLyBUaGVvcmV0aWNhbGx5IHRoaXMgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY2FzZSB0aG91Z2guXG4gIGNvbnN0IG5leHREYXRhVGFnID0gZ2xvYmFsT2JqZWN0LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX05FWFRfREFUQV9fJyk7XG4gIGlmIChuZXh0RGF0YVRhZz8uaW5uZXJIVE1MKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5leHREYXRhID0gSlNPTi5wYXJzZShuZXh0RGF0YVRhZy5pbm5lckhUTUwpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgREVCVUdfQlVJTEQgJiYgZGVidWcud2FybignQ291bGQgbm90IGV4dHJhY3QgX19ORVhUX0RBVEFfXycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbmV4dERhdGEpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBjb25zdCBuZXh0RGF0YVRhZ0luZm8gPSB7fTtcblxuICBjb25zdCB7IHBhZ2UsIHF1ZXJ5LCBwcm9wcyB9ID0gbmV4dERhdGE7XG5cbiAgLy8gYG5leHREYXRhLnBhZ2VgIGFsd2F5cyBjb250YWlucyB0aGUgcGFyYW1ldGVyaXplZCByb3V0ZSAtIGV4Y2VwdCBmb3Igd2hlbiBhbiBlcnJvciBvY2N1cnMgaW4gYSBkYXRhIGZldGNoaW5nXG4gIC8vIGZ1bmN0aW9uLCB0aGVuIGl0IGlzIFwiL19lcnJvclwiLCBidXQgdGhhdCBpc24ndCBhIHByb2JsZW0gc2luY2UgdXNlcnMga25vdyB3aGljaCByb3V0ZSB0aHJldyBieSBsb29raW5nIGF0IHRoZVxuICAvLyBwYXJlbnQgdHJhbnNhY3Rpb25cbiAgLy8gVE9ETzogQWN0dWFsbHkgdGhpcyBpcyBhIHByb2JsZW0gKGV2ZW4gdGhvdWdoIGl0IGlzIG5vdCB0aGF0IGJpZyksIGJlY2F1c2UgdGhlIERTQyBhbmQgdGhlIHRyYW5zYWN0aW9uIHBheWxvYWQgd2lsbCBjb250YWluXG4gIC8vIGEgZGlmZmVyZW50IHRyYW5zYWN0aW9uIG5hbWUuIE1heWJlIHdlIGNhbiBmaXggdGhpcy4gSWRlYTogQWxzbyBzZW5kIHRyYW5zYWN0aW9uIG5hbWUgdmlhIHBhZ2VQcm9wcyB3aGVuIGF2YWlsYWJsZS5cbiAgbmV4dERhdGFUYWdJbmZvLnJvdXRlID0gcGFnZTtcbiAgbmV4dERhdGFUYWdJbmZvLnBhcmFtcyA9IHF1ZXJ5O1xuXG4gIGlmIChwcm9wcz8ucGFnZVByb3BzKSB7XG4gICAgbmV4dERhdGFUYWdJbmZvLnNlbnRyeVRyYWNlID0gcHJvcHMucGFnZVByb3BzLl9zZW50cnlUcmFjZURhdGE7XG4gICAgbmV4dERhdGFUYWdJbmZvLmJhZ2dhZ2UgPSBwcm9wcy5wYWdlUHJvcHMuX3NlbnRyeUJhZ2dhZ2U7XG4gIH1cblxuICByZXR1cm4gbmV4dERhdGFUYWdJbmZvO1xufVxuXG4vKipcbiAqIEluc3RydW1lbnRzIHRoZSBOZXh0LmpzIHBhZ2VzIHJvdXRlciBmb3IgcGFnZWxvYWRzLlxuICogT25seSBzdXBwb3J0ZWQgZm9yIGNsaWVudCBzaWRlIHJvdXRpbmcuIFdvcmtzIGZvciBOZXh0ID49IDEwLlxuICpcbiAqIExldmVyYWdlcyB0aGUgU2luZ2xldG9uUm91dGVyIGZyb20gdGhlIGBuZXh0L3JvdXRlcmAgdG9cbiAqIGdlbmVyYXRlIHBhZ2Vsb2FkL25hdmlnYXRpb24gdHJhbnNhY3Rpb25zIGFuZCBwYXJhbWV0ZXJpemVcbiAqIHRyYW5zYWN0aW9uIG5hbWVzLlxuICovXG5mdW5jdGlvbiBwYWdlc1JvdXRlckluc3RydW1lbnRQYWdlTG9hZChjbGllbnQpIHtcbiAgY29uc3QgeyByb3V0ZSwgcGFyYW1zLCBzZW50cnlUcmFjZSwgYmFnZ2FnZSB9ID0gZXh0cmFjdE5leHREYXRhVGFnSW5mb3JtYXRpb24oKTtcbiAgY29uc3QgcGFyc2VkQmFnZ2FnZSA9IHBhcnNlQmFnZ2FnZUhlYWRlcihiYWdnYWdlKTtcbiAgbGV0IG5hbWUgPSByb3V0ZSB8fCBnbG9iYWxPYmplY3QubG9jYXRpb24ucGF0aG5hbWU7XG5cbiAgLy8gL19lcnJvciBpcyB0aGUgZmFsbGJhY2sgcGFnZSBmb3IgYWxsIGVycm9ycy4gSWYgdGhlcmUgaXMgYSB0cmFuc2FjdGlvbiBuYW1lIGZvciAvX2Vycm9yLCB1c2UgdGhhdCBpbnN0ZWFkXG4gIGlmIChwYXJzZWRCYWdnYWdlPy5bJ3NlbnRyeS10cmFuc2FjdGlvbiddICYmIG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgIG5hbWUgPSBwYXJzZWRCYWdnYWdlWydzZW50cnktdHJhbnNhY3Rpb24nXTtcbiAgICAvLyBTdHJpcCBhbnkgSFRUUCBtZXRob2QgZnJvbSB0aGUgc3BhbiBuYW1lXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXihHRVR8UE9TVHxQVVR8REVMRVRFfFBBVENIfEhFQUR8T1BUSU9OU3xUUkFDRXxDT05ORUNUKVxccysvaSwgJycpO1xuICB9XG5cbiAgY29uc3Qgb3JpZ2luID0gYnJvd3NlclBlcmZvcm1hbmNlVGltZU9yaWdpbigpO1xuICBzdGFydEJyb3dzZXJUcmFjaW5nUGFnZUxvYWRTcGFuKFxuICAgIGNsaWVudCxcbiAgICB7XG4gICAgICBuYW1lLFxuICAgICAgLy8gcGFnZWxvYWQgc2hvdWxkIGFsd2F5cyBzdGFydCBhdCB0aW1lT3JpZ2luIChhbmQgbmVlZHMgdG8gYmUgaW4gcywgbm90IG1zKVxuICAgICAgc3RhcnRUaW1lOiBvcmlnaW4gPyBvcmlnaW4gLyAxMDAwIDogdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06ICdwYWdlbG9hZCcsXG4gICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLnBhZ2Vsb2FkLm5leHRqcy5wYWdlc19yb3V0ZXJfaW5zdHJ1bWVudGF0aW9uJyxcbiAgICAgICAgW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTogcm91dGUgPyAncm91dGUnIDogJ3VybCcsXG4gICAgICAgIC4uLihwYXJhbXMgJiYgY2xpZW50LmdldE9wdGlvbnMoKS5zZW5kRGVmYXVsdFBpaSAmJiB7IC4uLnBhcmFtcyB9KSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICB7IHNlbnRyeVRyYWNlLCBiYWdnYWdlIH0sXG4gICk7XG59XG5cbi8qKlxuICogSW5zdHJ1bWVudHMgdGhlIE5leHQuanMgcGFnZXMgcm91dGVyIGZvciBuYXZpZ2F0aW9uLlxuICogT25seSBzdXBwb3J0ZWQgZm9yIGNsaWVudCBzaWRlIHJvdXRpbmcuIFdvcmtzIGZvciBOZXh0ID49IDEwLlxuICpcbiAqIExldmVyYWdlcyB0aGUgU2luZ2xldG9uUm91dGVyIGZyb20gdGhlIGBuZXh0L3JvdXRlcmAgdG9cbiAqIGdlbmVyYXRlIHBhZ2Vsb2FkL25hdmlnYXRpb24gdHJhbnNhY3Rpb25zIGFuZCBwYXJhbWV0ZXJpemVcbiAqIHRyYW5zYWN0aW9uIG5hbWVzLlxuICovXG5mdW5jdGlvbiBwYWdlc1JvdXRlckluc3RydW1lbnROYXZpZ2F0aW9uKGNsaWVudCkge1xuICBSb3V0ZXIuZXZlbnRzLm9uKCdyb3V0ZUNoYW5nZVN0YXJ0JywgKG5hdmlnYXRpb25UYXJnZXQpID0+IHtcbiAgICBjb25zdCBzdHJpcHBlZE5hdmlnYXRpb25UYXJnZXQgPSBzdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQobmF2aWdhdGlvblRhcmdldCk7XG4gICAgY29uc3QgbWF0Y2hlZFJvdXRlID0gZ2V0TmV4dFJvdXRlRnJvbVBhdGhuYW1lKHN0cmlwcGVkTmF2aWdhdGlvblRhcmdldCk7XG5cbiAgICBsZXQgbmV3TG9jYXRpb247XG4gICAgbGV0IHNwYW5Tb3VyY2U7XG5cbiAgICBpZiAobWF0Y2hlZFJvdXRlKSB7XG4gICAgICBuZXdMb2NhdGlvbiA9IG1hdGNoZWRSb3V0ZTtcbiAgICAgIHNwYW5Tb3VyY2UgPSAncm91dGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdMb2NhdGlvbiA9IHN0cmlwcGVkTmF2aWdhdGlvblRhcmdldDtcbiAgICAgIHNwYW5Tb3VyY2UgPSAndXJsJztcbiAgICB9XG5cbiAgICBzdGFydEJyb3dzZXJUcmFjaW5nTmF2aWdhdGlvblNwYW4oY2xpZW50LCB7XG4gICAgICBuYW1lOiBuZXdMb2NhdGlvbixcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiAnbmF2aWdhdGlvbicsXG4gICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLm5hdmlnYXRpb24ubmV4dGpzLnBhZ2VzX3JvdXRlcl9pbnN0cnVtZW50YXRpb24nLFxuICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiBzcGFuU291cmNlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRSb3V0ZUZyb21QYXRobmFtZShwYXRobmFtZSkge1xuICBjb25zdCBwYWdlUm91dGVzID0gZ2xvYmFsT2JqZWN0Ll9fQlVJTERfTUFOSUZFU1Q/LnNvcnRlZFBhZ2VzO1xuXG4gIC8vIFBhZ2Ugcm91dGUgc2hvdWxkIGluIDk5Ljk5OSUgb2YgdGhlIGNhc2VzIGJlIGRlZmluZWQgYnkgbm93IGJ1dCBqdXN0IHRvIGJlIHN1cmUgd2UgbWFrZSBhIGNoZWNrIGhlcmVcbiAgaWYgKCFwYWdlUm91dGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIHBhZ2VSb3V0ZXMuZmluZChyb3V0ZSA9PiB7XG4gICAgY29uc3Qgcm91dGVSZWdFeHAgPSBjb252ZXJ0TmV4dFJvdXRlVG9SZWdFeHAocm91dGUpO1xuICAgIHJldHVybiBwYXRobmFtZS5tYXRjaChyb3V0ZVJlZ0V4cCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgTmV4dC5qcyBzdHlsZSByb3V0ZSB0byBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgb24gcGF0aG5hbWVzIChubyBxdWVyeSBwYXJhbXMgb3IgVVJMIGZyYWdtZW50cykuXG4gKlxuICogSW4gZ2VuZXJhbCB0aGlzIGludm9sdmVzIHJlcGxhY2luZyBhbnkgaW5zdGFuY2VzIG9mIHNxdWFyZSBicmFja2V0cyBpbiBhIHJvdXRlIHdpdGggYSB3aWxkY2FyZDpcbiAqIGUuZy4gXCIvdXNlcnMvW2lkXS9pbmZvXCIgYmVjb21lcyAvXFwvdXNlcnNcXC8oW14vXSs/KVxcL2luZm8vXG4gKlxuICogU29tZSBhZGRpdGlvbmFsIGVkZ2VjYXNlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQ6XG4gKiAtIEFsbCByb3V0ZXMgaGF2ZSBhbiBvcHRpb25hbCBzbGFzaCBhdCB0aGUgZW5kLCBtZWFuaW5nIHVzZXJzIGNhbiBuYXZpZ2F0ZSB0byBcIi91c2Vycy9baWRdL2luZm9cIiBvclxuICogICBcIi91c2Vycy9baWRdL2luZm8vXCIgLSBib3RoIHdpbGwgYmUgcmVzb2x2ZWQgdG8gXCIvdXNlcnMvW2lkXS9pbmZvXCIuXG4gKiAtIE5vbi1vcHRpb25hbCBcImNhdGNoYWxsXCJzIGF0IHRoZSBlbmQgb2YgYSByb3V0ZSBtdXN0IGJlIGNvbnNpZGVyZWQgd2hlbiBtYXRjaGluZyAoZS5nLiBcIi91c2Vycy9bLi4ucGFyYW1zXVwiKS5cbiAqIC0gT3B0aW9uYWwgXCJjYXRjaGFsbFwicyBhdCB0aGUgZW5kIG9mIGEgcm91dGUgbXVzdCBiZSBjb25zaWRlcmVkIHdoZW4gbWF0Y2hpbmcgKGUuZy4gXCIvdXNlcnMvW1suLi5wYXJhbXNdXVwiKS5cbiAqXG4gKiBAcGFyYW0gcm91dGUgQSBOZXh0LmpzIHN0eWxlIHJvdXRlIGFzIGl0IGlzIGZvdW5kIGluIGBnbG9iYWwuX19CVUlMRF9NQU5JRkVTVC5zb3J0ZWRQYWdlc2BcbiAqL1xuZnVuY3Rpb24gY29udmVydE5leHRSb3V0ZVRvUmVnRXhwKHJvdXRlKSB7XG4gIC8vIFdlIGNhbiBhc3N1bWUgYSByb3V0ZSBpcyBhdCBsZWFzdCBcIi9cIi5cbiAgY29uc3Qgcm91dGVQYXJ0cyA9IHJvdXRlLnNwbGl0KCcvJyk7XG5cbiAgbGV0IG9wdGlvbmFsQ2F0Y2hhbGxXaWxkY2FyZFJlZ2V4ID0gJyc7XG4gIGlmIChyb3V0ZVBhcnRzW3JvdXRlUGFydHMubGVuZ3RoIC0gMV0/Lm1hdGNoKC9eXFxbXFxbXFwuXFwuXFwuLitcXF1cXF0kLykpIHtcbiAgICAvLyBJZiBsYXN0IHJvdXRlIHBhcnQgaGFzIHBhdHRlcm4gXCJbWy4uLnh5el1dXCIgd2UgcG9wIHRoZSBsYXRlc3Qgcm91dGUgcGFydCB0byBnZXQgcmlkIG9mIHRoZSByZXF1aXJlZCB0cmFpbGluZ1xuICAgIC8vIHNsYXNoIHRoYXQgd291bGQgY29tZSBiZWZvcmUgaXQgaWYgd2UgZGlkbid0IHBvcCBpdC5cbiAgICByb3V0ZVBhcnRzLnBvcCgpO1xuICAgIG9wdGlvbmFsQ2F0Y2hhbGxXaWxkY2FyZFJlZ2V4ID0gJyg/Oi8oLis/KSk/JztcbiAgfVxuXG4gIGNvbnN0IHJlam9pbmVkUm91dGVQYXJ0cyA9IHJvdXRlUGFydHNcbiAgICAubWFwKFxuICAgICAgcm91dGVQYXJ0ID0+XG4gICAgICAgIHJvdXRlUGFydFxuICAgICAgICAgIC5yZXBsYWNlKC9eXFxbXFwuXFwuXFwuLitcXF0kLywgJyguKz8pJykgLy8gUmVwbGFjZSBjYXRjaCBhbGwgd2lsZGNhcmQgd2l0aCByZWdleCB3aWxkY2FyZFxuICAgICAgICAgIC5yZXBsYWNlKC9eXFxbLipcXF0kLywgJyhbXi9dKz8pJyksIC8vIFJlcGxhY2Ugcm91dGUgd2lsZGNhcmRzIHdpdGggbGF6eSByZWdleCB3aWxkY2FyZHNcbiAgICApXG4gICAgLmpvaW4oJy8nKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHNlbnRyeS1pbnRlcm5hbC9zZGsvbm8tcmVnZXhwLWNvbnN0cnVjdG9yIC0tIHJvdXRlUGFydHMgYXJlIGZyb20gdGhlIGJ1aWxkIG1hbmlmZXN0LCBzbyBubyByYXcgdXNlciBpbnB1dFxuICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICBgXiR7cmVqb2luZWRSb3V0ZVBhcnRzfSR7b3B0aW9uYWxDYXRjaGFsbFdpbGRjYXJkUmVnZXh9KD86Lyk/JGAsIC8vIG9wdGlvbmFsIHNsYXNoIGF0IHRoZSBlbmRcbiAgKTtcbn1cblxuZXhwb3J0IHsgcGFnZXNSb3V0ZXJJbnN0cnVtZW50TmF2aWdhdGlvbiwgcGFnZXNSb3V0ZXJJbnN0cnVtZW50UGFnZUxvYWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzUm91dGVyUm91dGluZ0luc3RydW1lbnRhdGlvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+nextjs@9.46.0_@opentelemetry+context-async-hooks@1.30.1_@opentelemetry+api@1.9._42796a51c56a345b0bf099c431630b51/node_modules/@sentry/nextjs/build/esm/client/routing/pagesRouterRoutingInstrumentation.js\n"));
- `./frontend/.next/static/chunks/main-app.js:2152` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devErrorSymbolicationEventProcessor: () => (/* binding */ devErrorSymbolicationEventProcessor)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/index.js\");\n/* harmony import */ var stacktrace_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stacktrace-parser */ \"(app-pages-browser)/./node_modules/.pnpm/stacktrace-parser@0.1.11/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug-build.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+nextjs@9.46.0_@opentelemetry+context-async-hooks@1.30.1_@opentelemetry+api@1.9._42796a51c56a345b0bf099c431630b51/node_modules/@sentry/nextjs/build/esm/common/debug-build.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js\");\n\n\n\n\nconst globalWithInjectedValues = _sentry_core__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ\n\n;\n\n/**\n * Event processor that will symbolicate errors by using the webpack/nextjs dev server that is used to show stack traces\n * in the dev overlay.\n */\nasync function devErrorSymbolicationEventProcessor(event, hint) {\n  // Filter out spans for requests resolving source maps for stack frames in dev mode\n  if (event.type === 'transaction') {\n    event.spans = event.spans?.filter(span => {\n      const httpUrlAttribute = span.data?.['http.url'];\n      if (typeof httpUrlAttribute === 'string') {\n        return !httpUrlAttribute.includes('__nextjs_original-stack-frame'); // could also be __nextjs_original-stack-frames (plural)\n      }\n\n      return true;\n    });\n  }\n\n  // Due to changes across Next.js versions, there are a million things that can go wrong here so we just try-catch the\n  // entire event processor. Symbolicated stack traces are just a nice to have.\n  try {\n    if (hint.originalException && hint.originalException instanceof Error && hint.originalException.stack) {\n      const frames = stacktrace_parser__WEBPACK_IMPORTED_MODULE_1__.parse(hint.originalException.stack);\n\n      const nextjsVersion = globalWithInjectedValues.next?.version || '0.0.0';\n      const parsedNextjsVersion = nextjsVersion ? (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.parseSemver)(nextjsVersion) : {};\n\n      let resolvedFrames\n\n;\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      if (parsedNextjsVersion.major > 15 || (parsedNextjsVersion.major === 15 && parsedNextjsVersion.minor >= 2)) {\n        const r = await resolveStackFrames(frames);\n        if (r === null) {\n          return event;\n        }\n        resolvedFrames = r;\n      } else {\n        resolvedFrames = await Promise.all(\n          frames.map(frame => resolveStackFrame(frame, hint.originalException )),\n        );\n      }\n\n      if (event.exception?.values?.[0]?.stacktrace?.frames) {\n        event.exception.values[0].stacktrace.frames = event.exception.values[0].stacktrace.frames.map(\n          (frame, i, frames) => {\n            const resolvedFrame = resolvedFrames[frames.length - 1 - i];\n            if (!resolvedFrame?.originalStackFrame || !resolvedFrame.originalCodeFrame) {\n              return {\n                ...frame,\n                platform: frame.filename?.startsWith('node:internal') ? 'nodejs' : undefined, // simple hack that will prevent a source mapping error from showing up\n                in_app: false,\n              };\n            }\n\n            const { contextLine, preContextLines, postContextLines } = parseOriginalCodeFrame(\n              resolvedFrame.originalCodeFrame,\n            );\n\n            return {\n              ...frame,\n              pre_context: preContextLines,\n              context_line: contextLine,\n              post_context: postContextLines,\n              function: resolvedFrame.originalStackFrame.methodName,\n              filename: resolvedFrame.originalStackFrame.file || undefined,\n              lineno:\n                resolvedFrame.originalStackFrame.lineNumber || resolvedFrame.originalStackFrame.line1 || undefined,\n              colno: resolvedFrame.originalStackFrame.column || resolvedFrame.originalStackFrame.column1 || undefined,\n            };\n          },\n        );\n      }\n    }\n  } catch {\n    return event;\n  }\n\n  return event;\n}\n\nasync function resolveStackFrame(\n  frame,\n  error,\n) {\n  try {\n    if (!(frame.file?.startsWith('webpack-internal:') || frame.file?.startsWith('file:'))) {\n      return null;\n    }\n\n    const params = new URLSearchParams();\n    params.append('isServer', String(false)); // doesn't matter since it is overwritten by isAppDirectory\n    params.append('isEdgeServer', String(false)); // doesn't matter since it is overwritten by isAppDirectory\n    params.append('isAppDirectory', String(true)); // will force server to do more thorough checking\n    params.append('errorMessage', error.toString());\n    Object.keys(frame).forEach(key => {\n      params.append(key, (frame[key ] ?? '').toString());\n    });\n\n    let basePath = process.env._sentryBasePath ?? globalWithInjectedValues._sentryBasePath ?? '';\n\n    // Prefix the basepath with a slash if it doesn't have one\n    if (basePath !== '' && !basePath.match(/^\\//)) {\n      basePath = `/${basePath}`;\n    }\n\n    const controller = new AbortController();\n    const timer = setTimeout(() => controller.abort(), 3000);\n    const res = await (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.suppressTracing)(() =>\n      fetch(\n        `${\n          // eslint-disable-next-line no-restricted-globals\n          typeof window === 'undefined' ? 'http://localhost:3000' : '' // TODO: handle the case where users define a different port\n        }${basePath}/__nextjs_original-stack-frame?${params.toString()}`,\n        {\n          signal: controller.signal,\n        },\n      ).finally(() => {\n        clearTimeout(timer);\n      }),\n    );\n\n    if (!res.ok || res.status === 204) {\n      return null;\n    }\n\n    const body = await res.json();\n\n    return {\n      originalCodeFrame: body.originalCodeFrame,\n      originalStackFrame: body.originalStackFrame,\n    };\n  } catch (e) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.error('Failed to symbolicate event with Next.js dev server', e);\n    return null;\n  }\n}\n\nasync function resolveStackFrames(\n  frames,\n) {\n  try {\n    const postBody = {\n      frames: frames\n        .filter(frame => {\n          return !!frame.file;\n        })\n        .map(frame => {\n          // https://github.com/vercel/next.js/blob/df0573a478baa8b55478a7963c473dddd59a5e40/packages/next/src/client/components/react-dev-overlay/server/middleware-turbopack.ts#L129\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          frame.file = frame.file.replace(/^rsc:\\/\\/React\\/[^/]+\\//, '').replace(/\\?\\d+$/, '');\n\n          return {\n            file: frame.file,\n            methodName: frame.methodName ?? '<unknown>',\n            arguments: [],\n            lineNumber: frame.lineNumber ?? 0,\n            column: frame.column ?? 0,\n            line1: frame.lineNumber ?? 0,\n            column1: frame.column ?? 0,\n          };\n        }),\n      isServer: false,\n      isEdgeServer: false,\n      isAppDirectory: true,\n    };\n\n    let basePath = process.env._sentryBasePath ?? globalWithInjectedValues._sentryBasePath ?? '';\n\n    // Prefix the basepath with a slash if it doesn't have one\n    if (basePath !== '' && !basePath.match(/^\\//)) {\n      basePath = `/${basePath}`;\n    }\n\n    const controller = new AbortController();\n    const timer = setTimeout(() => controller.abort(), 3000);\n\n    const res = await (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.suppressTracing)(() =>\n      fetch(\n        `${\n          // eslint-disable-next-line no-restricted-globals\n          typeof window === 'undefined' ? 'http://localhost:3000' : '' // TODO: handle the case where users define a different port\n        }${basePath}/__nextjs_original-stack-frames`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          signal: controller.signal,\n          body: JSON.stringify(postBody),\n        },\n      ).finally(() => {\n        clearTimeout(timer);\n      }),\n    );\n\n    if (!res.ok || res.status === 204) {\n      return null;\n    }\n\n    const body = await res.json();\n\n    return body.map(frame => {\n      return {\n        originalCodeFrame: frame.value.originalCodeFrame,\n        originalStackFrame: frame.value.originalStackFrame,\n      };\n    });\n  } catch (e) {\n    _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _sentry_core__WEBPACK_IMPORTED_MODULE_0__.debug.error('Failed to symbolicate event with Next.js dev server', e);\n    return null;\n  }\n}\n\nfunction parseOriginalCodeFrame(codeFrame)\n\n {\n  const preProcessedLines = codeFrame\n    // Remove ASCII control characters that are used for syntax highlighting\n    .replace(\n      // eslint-disable-next-line no-control-regex\n      /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, // https://stackoverflow.com/a/29497680\n      '',\n    )\n    .split('\\n')\n    // Remove line that is supposed to indicate where the error happened\n    .filter(line => !line.match(/^\\s*\\|/))\n    // Find the error line\n    .map(line => ({\n      line,\n      isErrorLine: !!line.match(/^>/),\n    }))\n    // Remove the leading part that is just for prettier output\n    .map(lineObj => ({\n      ...lineObj,\n      line: lineObj.line.replace(/^.*\\|/, ''),\n    }));\n\n  const preContextLines = [];\n  let contextLine = undefined;\n  const postContextLines = [];\n\n  let reachedContextLine = false;\n\n  for (const preProcessedLine of preProcessedLines) {\n    if (preProcessedLine.isErrorLine) {\n      contextLine = preProcessedLine.line;\n      reachedContextLine = true;\n    } else if (reachedContextLine) {\n      postContextLines.push(preProcessedLine.line);\n    } else {\n      preContextLines.push(preProcessedLine.line);\n    }\n  }\n\n  return {\n    contextLine,\n    preContextLines,\n    postContextLines,\n  };\n}\n\n\n//# sourceMappingURL=devErrorSymbolicationEventProcessor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K25leHRqc0A5LjQ2LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AxLjMwLjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS5fNDI3OTZhNTFjNTZhMzQ1YjBiZjA5OWM0MzE2MzBiNTEvbm9kZV9tb2R1bGVzL0BzZW50cnkvbmV4dGpzL2J1aWxkL2VzbS9jb21tb24vZGV2RXJyb3JTeW1ib2xpY2F0aW9uRXZlbnRQcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0U7QUFDekI7QUFDUDs7QUFFL0MsaUNBQWlDLG9EQUFVOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBc0I7O0FBRTNDO0FBQ0Esa0RBQWtELHlEQUFXOztBQUU3RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpREFBaUQ7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QyxrREFBa0Q7QUFDbEQsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDZEQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFLFNBQVMsaUNBQWlDLGtCQUFrQjtBQUN2RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUksd0RBQVcsSUFBSSwrQ0FBSztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5Qjs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQiw2REFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRSxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osSUFBSSx3REFBVyxJQUFJLCtDQUFLO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVksSUFBSSxJQUFJLE1BQU0sSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQztBQUMvQyIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K25leHRqc0A5LjQ2LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AxLjMwLjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS5fNDI3OTZhNTFjNTZhMzQ1YjBiZjA5OWM0MzE2MzBiNTEvbm9kZV9tb2R1bGVzL0BzZW50cnkvbmV4dGpzL2J1aWxkL2VzbS9jb21tb24vZGV2RXJyb3JTeW1ib2xpY2F0aW9uRXZlbnRQcm9jZXNzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR0xPQkFMX09CSiwgcGFyc2VTZW12ZXIsIHN1cHByZXNzVHJhY2luZywgZGVidWcgfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0ICogYXMgc3RhY2tUcmFjZVBhcnNlciBmcm9tICdzdGFja3RyYWNlLXBhcnNlcic7XG5pbXBvcnQgeyBERUJVR19CVUlMRCB9IGZyb20gJy4vZGVidWctYnVpbGQuanMnO1xuXG5jb25zdCBnbG9iYWxXaXRoSW5qZWN0ZWRWYWx1ZXMgPSBHTE9CQUxfT0JKXG5cbjtcblxuLyoqXG4gKiBFdmVudCBwcm9jZXNzb3IgdGhhdCB3aWxsIHN5bWJvbGljYXRlIGVycm9ycyBieSB1c2luZyB0aGUgd2VicGFjay9uZXh0anMgZGV2IHNlcnZlciB0aGF0IGlzIHVzZWQgdG8gc2hvdyBzdGFjayB0cmFjZXNcbiAqIGluIHRoZSBkZXYgb3ZlcmxheS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGV2RXJyb3JTeW1ib2xpY2F0aW9uRXZlbnRQcm9jZXNzb3IoZXZlbnQsIGhpbnQpIHtcbiAgLy8gRmlsdGVyIG91dCBzcGFucyBmb3IgcmVxdWVzdHMgcmVzb2x2aW5nIHNvdXJjZSBtYXBzIGZvciBzdGFjayBmcmFtZXMgaW4gZGV2IG1vZGVcbiAgaWYgKGV2ZW50LnR5cGUgPT09ICd0cmFuc2FjdGlvbicpIHtcbiAgICBldmVudC5zcGFucyA9IGV2ZW50LnNwYW5zPy5maWx0ZXIoc3BhbiA9PiB7XG4gICAgICBjb25zdCBodHRwVXJsQXR0cmlidXRlID0gc3Bhbi5kYXRhPy5bJ2h0dHAudXJsJ107XG4gICAgICBpZiAodHlwZW9mIGh0dHBVcmxBdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAhaHR0cFVybEF0dHJpYnV0ZS5pbmNsdWRlcygnX19uZXh0anNfb3JpZ2luYWwtc3RhY2stZnJhbWUnKTsgLy8gY291bGQgYWxzbyBiZSBfX25leHRqc19vcmlnaW5hbC1zdGFjay1mcmFtZXMgKHBsdXJhbClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyBEdWUgdG8gY2hhbmdlcyBhY3Jvc3MgTmV4dC5qcyB2ZXJzaW9ucywgdGhlcmUgYXJlIGEgbWlsbGlvbiB0aGluZ3MgdGhhdCBjYW4gZ28gd3JvbmcgaGVyZSBzbyB3ZSBqdXN0IHRyeS1jYXRjaCB0aGVcbiAgLy8gZW50aXJlIGV2ZW50IHByb2Nlc3Nvci4gU3ltYm9saWNhdGVkIHN0YWNrIHRyYWNlcyBhcmUganVzdCBhIG5pY2UgdG8gaGF2ZS5cbiAgdHJ5IHtcbiAgICBpZiAoaGludC5vcmlnaW5hbEV4Y2VwdGlvbiAmJiBoaW50Lm9yaWdpbmFsRXhjZXB0aW9uIGluc3RhbmNlb2YgRXJyb3IgJiYgaGludC5vcmlnaW5hbEV4Y2VwdGlvbi5zdGFjaykge1xuICAgICAgY29uc3QgZnJhbWVzID0gc3RhY2tUcmFjZVBhcnNlci5wYXJzZShoaW50Lm9yaWdpbmFsRXhjZXB0aW9uLnN0YWNrKTtcblxuICAgICAgY29uc3QgbmV4dGpzVmVyc2lvbiA9IGdsb2JhbFdpdGhJbmplY3RlZFZhbHVlcy5uZXh0Py52ZXJzaW9uIHx8ICcwLjAuMCc7XG4gICAgICBjb25zdCBwYXJzZWROZXh0anNWZXJzaW9uID0gbmV4dGpzVmVyc2lvbiA/IHBhcnNlU2VtdmVyKG5leHRqc1ZlcnNpb24pIDoge307XG5cbiAgICAgIGxldCByZXNvbHZlZEZyYW1lc1xuXG47XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICBpZiAocGFyc2VkTmV4dGpzVmVyc2lvbi5tYWpvciA+IDE1IHx8IChwYXJzZWROZXh0anNWZXJzaW9uLm1ham9yID09PSAxNSAmJiBwYXJzZWROZXh0anNWZXJzaW9uLm1pbm9yID49IDIpKSB7XG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCByZXNvbHZlU3RhY2tGcmFtZXMoZnJhbWVzKTtcbiAgICAgICAgaWYgKHIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRGcmFtZXMgPSByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZWRGcmFtZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBmcmFtZXMubWFwKGZyYW1lID0+IHJlc29sdmVTdGFja0ZyYW1lKGZyYW1lLCBoaW50Lm9yaWdpbmFsRXhjZXB0aW9uICkpLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuZXhjZXB0aW9uPy52YWx1ZXM/LlswXT8uc3RhY2t0cmFjZT8uZnJhbWVzKSB7XG4gICAgICAgIGV2ZW50LmV4Y2VwdGlvbi52YWx1ZXNbMF0uc3RhY2t0cmFjZS5mcmFtZXMgPSBldmVudC5leGNlcHRpb24udmFsdWVzWzBdLnN0YWNrdHJhY2UuZnJhbWVzLm1hcChcbiAgICAgICAgICAoZnJhbWUsIGksIGZyYW1lcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRGcmFtZSA9IHJlc29sdmVkRnJhbWVzW2ZyYW1lcy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkRnJhbWU/Lm9yaWdpbmFsU3RhY2tGcmFtZSB8fCAhcmVzb2x2ZWRGcmFtZS5vcmlnaW5hbENvZGVGcmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmZyYW1lLFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiBmcmFtZS5maWxlbmFtZT8uc3RhcnRzV2l0aCgnbm9kZTppbnRlcm5hbCcpID8gJ25vZGVqcycgOiB1bmRlZmluZWQsIC8vIHNpbXBsZSBoYWNrIHRoYXQgd2lsbCBwcmV2ZW50IGEgc291cmNlIG1hcHBpbmcgZXJyb3IgZnJvbSBzaG93aW5nIHVwXG4gICAgICAgICAgICAgICAgaW5fYXBwOiBmYWxzZSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgeyBjb250ZXh0TGluZSwgcHJlQ29udGV4dExpbmVzLCBwb3N0Q29udGV4dExpbmVzIH0gPSBwYXJzZU9yaWdpbmFsQ29kZUZyYW1lKFxuICAgICAgICAgICAgICByZXNvbHZlZEZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uZnJhbWUsXG4gICAgICAgICAgICAgIHByZV9jb250ZXh0OiBwcmVDb250ZXh0TGluZXMsXG4gICAgICAgICAgICAgIGNvbnRleHRfbGluZTogY29udGV4dExpbmUsXG4gICAgICAgICAgICAgIHBvc3RfY29udGV4dDogcG9zdENvbnRleHRMaW5lcyxcbiAgICAgICAgICAgICAgZnVuY3Rpb246IHJlc29sdmVkRnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lLm1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiByZXNvbHZlZEZyYW1lLm9yaWdpbmFsU3RhY2tGcmFtZS5maWxlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbGluZW5vOlxuICAgICAgICAgICAgICAgIHJlc29sdmVkRnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lLmxpbmVOdW1iZXIgfHwgcmVzb2x2ZWRGcmFtZS5vcmlnaW5hbFN0YWNrRnJhbWUubGluZTEgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjb2xubzogcmVzb2x2ZWRGcmFtZS5vcmlnaW5hbFN0YWNrRnJhbWUuY29sdW1uIHx8IHJlc29sdmVkRnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lLmNvbHVtbjEgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlU3RhY2tGcmFtZShcbiAgZnJhbWUsXG4gIGVycm9yLFxuKSB7XG4gIHRyeSB7XG4gICAgaWYgKCEoZnJhbWUuZmlsZT8uc3RhcnRzV2l0aCgnd2VicGFjay1pbnRlcm5hbDonKSB8fCBmcmFtZS5maWxlPy5zdGFydHNXaXRoKCdmaWxlOicpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIHBhcmFtcy5hcHBlbmQoJ2lzU2VydmVyJywgU3RyaW5nKGZhbHNlKSk7IC8vIGRvZXNuJ3QgbWF0dGVyIHNpbmNlIGl0IGlzIG92ZXJ3cml0dGVuIGJ5IGlzQXBwRGlyZWN0b3J5XG4gICAgcGFyYW1zLmFwcGVuZCgnaXNFZGdlU2VydmVyJywgU3RyaW5nKGZhbHNlKSk7IC8vIGRvZXNuJ3QgbWF0dGVyIHNpbmNlIGl0IGlzIG92ZXJ3cml0dGVuIGJ5IGlzQXBwRGlyZWN0b3J5XG4gICAgcGFyYW1zLmFwcGVuZCgnaXNBcHBEaXJlY3RvcnknLCBTdHJpbmcodHJ1ZSkpOyAvLyB3aWxsIGZvcmNlIHNlcnZlciB0byBkbyBtb3JlIHRob3JvdWdoIGNoZWNraW5nXG4gICAgcGFyYW1zLmFwcGVuZCgnZXJyb3JNZXNzYWdlJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgT2JqZWN0LmtleXMoZnJhbWUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCAoZnJhbWVba2V5IF0gPz8gJycpLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuXG4gICAgbGV0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX3NlbnRyeUJhc2VQYXRoID8/IGdsb2JhbFdpdGhJbmplY3RlZFZhbHVlcy5fc2VudHJ5QmFzZVBhdGggPz8gJyc7XG5cbiAgICAvLyBQcmVmaXggdGhlIGJhc2VwYXRoIHdpdGggYSBzbGFzaCBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgaWYgKGJhc2VQYXRoICE9PSAnJyAmJiAhYmFzZVBhdGgubWF0Y2goL15cXC8vKSkge1xuICAgICAgYmFzZVBhdGggPSBgLyR7YmFzZVBhdGh9YDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDMwMDApO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHN1cHByZXNzVHJhY2luZygoKSA9PlxuICAgICAgZmV0Y2goXG4gICAgICAgIGAke1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnIDogJycgLy8gVE9ETzogaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHVzZXJzIGRlZmluZSBhIGRpZmZlcmVudCBwb3J0XG4gICAgICAgIH0ke2Jhc2VQYXRofS9fX25leHRqc19vcmlnaW5hbC1zdGFjay1mcmFtZT8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICB9LFxuICAgICAgKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBpZiAoIXJlcy5vayB8fCByZXMuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBib2R5Lm9yaWdpbmFsQ29kZUZyYW1lLFxuICAgICAgb3JpZ2luYWxTdGFja0ZyYW1lOiBib2R5Lm9yaWdpbmFsU3RhY2tGcmFtZSxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgREVCVUdfQlVJTEQgJiYgZGVidWcuZXJyb3IoJ0ZhaWxlZCB0byBzeW1ib2xpY2F0ZSBldmVudCB3aXRoIE5leHQuanMgZGV2IHNlcnZlcicsIGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVTdGFja0ZyYW1lcyhcbiAgZnJhbWVzLFxuKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcG9zdEJvZHkgPSB7XG4gICAgICBmcmFtZXM6IGZyYW1lc1xuICAgICAgICAuZmlsdGVyKGZyYW1lID0+IHtcbiAgICAgICAgICByZXR1cm4gISFmcmFtZS5maWxlO1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGZyYW1lID0+IHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvYmxvYi9kZjA1NzNhNDc4YmFhOGI1NTQ3OGE3OTYzYzQ3M2RkZGQ1OWE1ZTQwL3BhY2thZ2VzL25leHQvc3JjL2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3NlcnZlci9taWRkbGV3YXJlLXR1cmJvcGFjay50cyNMMTI5XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICBmcmFtZS5maWxlID0gZnJhbWUuZmlsZS5yZXBsYWNlKC9ecnNjOlxcL1xcL1JlYWN0XFwvW14vXStcXC8vLCAnJykucmVwbGFjZSgvXFw/XFxkKyQvLCAnJyk7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZTogZnJhbWUuZmlsZSxcbiAgICAgICAgICAgIG1ldGhvZE5hbWU6IGZyYW1lLm1ldGhvZE5hbWUgPz8gJzx1bmtub3duPicsXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtdLFxuICAgICAgICAgICAgbGluZU51bWJlcjogZnJhbWUubGluZU51bWJlciA/PyAwLFxuICAgICAgICAgICAgY29sdW1uOiBmcmFtZS5jb2x1bW4gPz8gMCxcbiAgICAgICAgICAgIGxpbmUxOiBmcmFtZS5saW5lTnVtYmVyID8/IDAsXG4gICAgICAgICAgICBjb2x1bW4xOiBmcmFtZS5jb2x1bW4gPz8gMCxcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgIGlzU2VydmVyOiBmYWxzZSxcbiAgICAgIGlzRWRnZVNlcnZlcjogZmFsc2UsXG4gICAgICBpc0FwcERpcmVjdG9yeTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgbGV0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX3NlbnRyeUJhc2VQYXRoID8/IGdsb2JhbFdpdGhJbmplY3RlZFZhbHVlcy5fc2VudHJ5QmFzZVBhdGggPz8gJyc7XG5cbiAgICAvLyBQcmVmaXggdGhlIGJhc2VwYXRoIHdpdGggYSBzbGFzaCBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgaWYgKGJhc2VQYXRoICE9PSAnJyAmJiAhYmFzZVBhdGgubWF0Y2goL15cXC8vKSkge1xuICAgICAgYmFzZVBhdGggPSBgLyR7YmFzZVBhdGh9YDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDMwMDApO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgc3VwcHJlc3NUcmFjaW5nKCgpID0+XG4gICAgICBmZXRjaChcbiAgICAgICAgYCR7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcgOiAnJyAvLyBUT0RPOiBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdXNlcnMgZGVmaW5lIGEgZGlmZmVyZW50IHBvcnRcbiAgICAgICAgfSR7YmFzZVBhdGh9L19fbmV4dGpzX29yaWdpbmFsLXN0YWNrLWZyYW1lc2AsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwb3N0Qm9keSksXG4gICAgICAgIH0sXG4gICAgICApLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfSksXG4gICAgKTtcblxuICAgIGlmICghcmVzLm9rIHx8IHJlcy5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcy5qc29uKCk7XG5cbiAgICByZXR1cm4gYm9keS5tYXAoZnJhbWUgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWxDb2RlRnJhbWU6IGZyYW1lLnZhbHVlLm9yaWdpbmFsQ29kZUZyYW1lLFxuICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IGZyYW1lLnZhbHVlLm9yaWdpbmFsU3RhY2tGcmFtZSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBERUJVR19CVUlMRCAmJiBkZWJ1Zy5lcnJvcignRmFpbGVkIHRvIHN5bWJvbGljYXRlIGV2ZW50IHdpdGggTmV4dC5qcyBkZXYgc2VydmVyJywgZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VPcmlnaW5hbENvZGVGcmFtZShjb2RlRnJhbWUpXG5cbiB7XG4gIGNvbnN0IHByZVByb2Nlc3NlZExpbmVzID0gY29kZUZyYW1lXG4gICAgLy8gUmVtb3ZlIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyB0aGF0IGFyZSB1c2VkIGZvciBzeW50YXggaGlnaGxpZ2h0aW5nXG4gICAgLnJlcGxhY2UoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtT1JaY2YtbnFyeT0+PF0vZywgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI5NDk3NjgwXG4gICAgICAnJyxcbiAgICApXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC8vIFJlbW92ZSBsaW5lIHRoYXQgaXMgc3VwcG9zZWQgdG8gaW5kaWNhdGUgd2hlcmUgdGhlIGVycm9yIGhhcHBlbmVkXG4gICAgLmZpbHRlcihsaW5lID0+ICFsaW5lLm1hdGNoKC9eXFxzKlxcfC8pKVxuICAgIC8vIEZpbmQgdGhlIGVycm9yIGxpbmVcbiAgICAubWFwKGxpbmUgPT4gKHtcbiAgICAgIGxpbmUsXG4gICAgICBpc0Vycm9yTGluZTogISFsaW5lLm1hdGNoKC9ePi8pLFxuICAgIH0pKVxuICAgIC8vIFJlbW92ZSB0aGUgbGVhZGluZyBwYXJ0IHRoYXQgaXMganVzdCBmb3IgcHJldHRpZXIgb3V0cHV0XG4gICAgLm1hcChsaW5lT2JqID0+ICh7XG4gICAgICAuLi5saW5lT2JqLFxuICAgICAgbGluZTogbGluZU9iai5saW5lLnJlcGxhY2UoL14uKlxcfC8sICcnKSxcbiAgICB9KSk7XG5cbiAgY29uc3QgcHJlQ29udGV4dExpbmVzID0gW107XG4gIGxldCBjb250ZXh0TGluZSA9IHVuZGVmaW5lZDtcbiAgY29uc3QgcG9zdENvbnRleHRMaW5lcyA9IFtdO1xuXG4gIGxldCByZWFjaGVkQ29udGV4dExpbmUgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IHByZVByb2Nlc3NlZExpbmUgb2YgcHJlUHJvY2Vzc2VkTGluZXMpIHtcbiAgICBpZiAocHJlUHJvY2Vzc2VkTGluZS5pc0Vycm9yTGluZSkge1xuICAgICAgY29udGV4dExpbmUgPSBwcmVQcm9jZXNzZWRMaW5lLmxpbmU7XG4gICAgICByZWFjaGVkQ29udGV4dExpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVhY2hlZENvbnRleHRMaW5lKSB7XG4gICAgICBwb3N0Q29udGV4dExpbmVzLnB1c2gocHJlUHJvY2Vzc2VkTGluZS5saW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlQ29udGV4dExpbmVzLnB1c2gocHJlUHJvY2Vzc2VkTGluZS5saW5lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbnRleHRMaW5lLFxuICAgIHByZUNvbnRleHRMaW5lcyxcbiAgICBwb3N0Q29udGV4dExpbmVzLFxuICB9O1xufVxuXG5leHBvcnQgeyBkZXZFcnJvclN5bWJvbGljYXRpb25FdmVudFByb2Nlc3NvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV2RXJyb3JTeW1ib2xpY2F0aW9uRXZlbnRQcm9jZXNzb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+nextjs@9.46.0_@opentelemetry+context-async-hooks@1.30.1_@opentelemetry+api@1.9._42796a51c56a345b0bf099c431630b51/node_modules/@sentry/nextjs/build/esm/common/devErrorSymbolicationEventProcessor.js\n"));
- `./frontend/.next/static/chunks/main-app.js:2339` - eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   callDataFetcherTraced: () => (/* binding */ callDataFetcherTraced),\n/* harmony export */   maybeExtractSynchronousParamsAndSearchParams: () => (/* binding */ maybeExtractSynchronousParamsAndSearchParams),\n/* harmony export */   withErrorInstrumentation: () => (/* binding */ withErrorInstrumentation),\n/* harmony export */   withTracedServerSideDataFetcher: () => (/* binding */ withTracedServerSideDataFetcher)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+core@9.46.0/node_modules/@sentry/core/build/esm/index.js\");\n/* harmony import */ var _span_attributes_with_logic_attached_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../span-attributes-with-logic-attached.js */ \"(app-pages-browser)/./node_modules/.pnpm/@sentry+nextjs@9.46.0_@opentelemetry+context-async-hooks@1.30.1_@opentelemetry+api@1.9._42796a51c56a345b0bf099c431630b51/node_modules/@sentry/nextjs/build/esm/common/span-attributes-with-logic-attached.js\");\n\n\n\n/**\n * Wraps a function that potentially throws. If it does, the error is passed to `captureException` and rethrown.\n *\n * Note: This function turns the wrapped function into an asynchronous one.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withErrorInstrumentation(\n  origFunction,\n) {\n  return async function ( ...origFunctionArguments) {\n    try {\n      return await origFunction.apply(this, origFunctionArguments);\n    } catch (e) {\n      // TODO: Extract error logic from `withSentry` in here or create a new wrapper with said logic or something like that.\n      (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.captureException)(e, { mechanism: { handled: false } });\n      throw e;\n    }\n  };\n}\n\n/**\n * Calls a server-side data fetching function (that takes a `req` and `res` object in its context) with tracing\n * instrumentation. A transaction will be created for the incoming request (if it doesn't already exist) in addition to\n * a span for the wrapped data fetching function.\n *\n * All of the above happens in an isolated domain, meaning all thrown errors will be associated with the correct span.\n *\n * @param origDataFetcher The data fetching method to call.\n * @param origFunctionArguments The arguments to call the data fetching method with.\n * @param req The data fetching function's request object.\n * @param res The data fetching function's response object.\n * @param options Options providing details for the created transaction and span.\n * @returns what the data fetching method call returned.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withTracedServerSideDataFetcher(\n  origDataFetcher,\n  req,\n  res,\n  options\n\n,\n) {\n  return async function (\n\n    ...args\n  ) {\n    const normalizedRequest = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.httpRequestToRequestData)(req);\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)().setTransactionName(`${options.dataFetchingMethodName} (${options.dataFetcherRouteName})`);\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getIsolationScope)().setSDKProcessingMetadata({ normalizedRequest });\n\n    const span = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getActiveSpan)();\n\n    // Only set the route backfill if the span is not for /_error\n    if (span && options.requestedRouteName !== '/_error') {\n      const root = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getRootSpan)(span);\n      root.setAttribute(_span_attributes_with_logic_attached_js__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL, options.requestedRouteName);\n    }\n\n    const { 'sentry-trace': sentryTrace, baggage } = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.getTraceData)();\n\n    return {\n      sentryTrace: sentryTrace,\n      baggage: baggage,\n      data: await origDataFetcher.apply(this, args),\n    };\n  };\n}\n\n/**\n * Call a data fetcher and trace it. Only traces the function if there is an active transaction on the scope.\n *\n * We only do the following until we move transaction creation into this function: When called, the wrapped function\n * will also update the name of the active transaction with a parameterized route provided via the `options` argument.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function callDataFetcherTraced(\n  origFunction,\n  origFunctionArgs,\n) {\n  try {\n    return await origFunction(...origFunctionArgs);\n  } catch (e) {\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.captureException)(e, { mechanism: { handled: false } });\n    throw e;\n  }\n}\n\n/**\n * Extracts the params and searchParams from the props object.\n *\n * Depending on the next version, params and searchParams may be a promise which we do not want to resolve in this function.\n */\nfunction maybeExtractSynchronousParamsAndSearchParams(props)\n\n {\n  let params =\n    props && typeof props === 'object' && 'params' in props\n      ? (props.params )\n      : undefined;\n  if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.isThenable)(params)) {\n    params = undefined;\n  }\n\n  let searchParams =\n    props && typeof props === 'object' && 'searchParams' in props\n      ? (props.searchParams )\n      : undefined;\n  if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.isThenable)(searchParams)) {\n    searchParams = undefined;\n  }\n\n  return { params, searchParams };\n}\n\n\n//# sourceMappingURL=wrapperUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K25leHRqc0A5LjQ2LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AxLjMwLjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS5fNDI3OTZhNTFjNTZhMzQ1YjBiZjA5OWM0MzE2MzBiNTEvbm9kZV9tb2R1bGVzL0BzZW50cnkvbmV4dGpzL2J1aWxkL2VzbS9jb21tb24vdXRpbHMvd3JhcHBlclV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvSztBQUNqRTs7QUFFbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTSw4REFBZ0IsTUFBTSxhQUFhLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHNFQUF3QjtBQUN0RCxJQUFJLDZEQUFlLHlCQUF5QixnQ0FBZ0MsR0FBRyw2QkFBNkI7QUFDNUcsSUFBSSwrREFBaUIsOEJBQThCLG1CQUFtQjs7QUFFdEUsaUJBQWlCLDJEQUFhOztBQUU5QjtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFXO0FBQzlCLHdCQUF3QiwyR0FBc0M7QUFDOUQ7O0FBRUEsWUFBWSx1Q0FBdUMsRUFBRSwwREFBWTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSSw4REFBZ0IsTUFBTSxhQUFhLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdEQUFVO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdEQUFVO0FBQ2hCO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUUwSTtBQUMxSSIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K25leHRqc0A5LjQ2LjBfQG9wZW50ZWxlbWV0cnkrY29udGV4dC1hc3luYy1ob29rc0AxLjMwLjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS5fNDI3OTZhNTFjNTZhMzQ1YjBiZjA5OWM0MzE2MzBiNTEvbm9kZV9tb2R1bGVzL0BzZW50cnkvbmV4dGpzL2J1aWxkL2VzbS9jb21tb24vdXRpbHMvd3JhcHBlclV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNhcHR1cmVFeGNlcHRpb24sIGh0dHBSZXF1ZXN0VG9SZXF1ZXN0RGF0YSwgZ2V0Q3VycmVudFNjb3BlLCBnZXRJc29sYXRpb25TY29wZSwgZ2V0QWN0aXZlU3BhbiwgZ2V0Um9vdFNwYW4sIGdldFRyYWNlRGF0YSwgaXNUaGVuYWJsZSB9IGZyb20gJ0BzZW50cnkvY29yZSc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9BVFRSX1NFTlRSWV9ST1VURV9CQUNLRklMTCB9IGZyb20gJy4uL3NwYW4tYXR0cmlidXRlcy13aXRoLWxvZ2ljLWF0dGFjaGVkLmpzJztcblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHRoYXQgcG90ZW50aWFsbHkgdGhyb3dzLiBJZiBpdCBkb2VzLCB0aGUgZXJyb3IgaXMgcGFzc2VkIHRvIGBjYXB0dXJlRXhjZXB0aW9uYCBhbmQgcmV0aHJvd24uXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiB0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvbiBpbnRvIGFuIGFzeW5jaHJvbm91cyBvbmUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB3aXRoRXJyb3JJbnN0cnVtZW50YXRpb24oXG4gIG9yaWdGdW5jdGlvbixcbikge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKCAuLi5vcmlnRnVuY3Rpb25Bcmd1bWVudHMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IG9yaWdGdW5jdGlvbi5hcHBseSh0aGlzLCBvcmlnRnVuY3Rpb25Bcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRPRE86IEV4dHJhY3QgZXJyb3IgbG9naWMgZnJvbSBgd2l0aFNlbnRyeWAgaW4gaGVyZSBvciBjcmVhdGUgYSBuZXcgd3JhcHBlciB3aXRoIHNhaWQgbG9naWMgb3Igc29tZXRoaW5nIGxpa2UgdGhhdC5cbiAgICAgIGNhcHR1cmVFeGNlcHRpb24oZSwgeyBtZWNoYW5pc206IHsgaGFuZGxlZDogZmFsc2UgfSB9KTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmVyLXNpZGUgZGF0YSBmZXRjaGluZyBmdW5jdGlvbiAodGhhdCB0YWtlcyBhIGByZXFgIGFuZCBgcmVzYCBvYmplY3QgaW4gaXRzIGNvbnRleHQpIHdpdGggdHJhY2luZ1xuICogaW5zdHJ1bWVudGF0aW9uLiBBIHRyYW5zYWN0aW9uIHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIGluY29taW5nIHJlcXVlc3QgKGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCkgaW4gYWRkaXRpb24gdG9cbiAqIGEgc3BhbiBmb3IgdGhlIHdyYXBwZWQgZGF0YSBmZXRjaGluZyBmdW5jdGlvbi5cbiAqXG4gKiBBbGwgb2YgdGhlIGFib3ZlIGhhcHBlbnMgaW4gYW4gaXNvbGF0ZWQgZG9tYWluLCBtZWFuaW5nIGFsbCB0aHJvd24gZXJyb3JzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb3JyZWN0IHNwYW4uXG4gKlxuICogQHBhcmFtIG9yaWdEYXRhRmV0Y2hlciBUaGUgZGF0YSBmZXRjaGluZyBtZXRob2QgdG8gY2FsbC5cbiAqIEBwYXJhbSBvcmlnRnVuY3Rpb25Bcmd1bWVudHMgVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBkYXRhIGZldGNoaW5nIG1ldGhvZCB3aXRoLlxuICogQHBhcmFtIHJlcSBUaGUgZGF0YSBmZXRjaGluZyBmdW5jdGlvbidzIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIHJlcyBUaGUgZGF0YSBmZXRjaGluZyBmdW5jdGlvbidzIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgcHJvdmlkaW5nIGRldGFpbHMgZm9yIHRoZSBjcmVhdGVkIHRyYW5zYWN0aW9uIGFuZCBzcGFuLlxuICogQHJldHVybnMgd2hhdCB0aGUgZGF0YSBmZXRjaGluZyBtZXRob2QgY2FsbCByZXR1cm5lZC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHdpdGhUcmFjZWRTZXJ2ZXJTaWRlRGF0YUZldGNoZXIoXG4gIG9yaWdEYXRhRmV0Y2hlcixcbiAgcmVxLFxuICByZXMsXG4gIG9wdGlvbnNcblxuLFxuKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAoXG5cbiAgICAuLi5hcmdzXG4gICkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRSZXF1ZXN0ID0gaHR0cFJlcXVlc3RUb1JlcXVlc3REYXRhKHJlcSk7XG4gICAgZ2V0Q3VycmVudFNjb3BlKCkuc2V0VHJhbnNhY3Rpb25OYW1lKGAke29wdGlvbnMuZGF0YUZldGNoaW5nTWV0aG9kTmFtZX0gKCR7b3B0aW9ucy5kYXRhRmV0Y2hlclJvdXRlTmFtZX0pYCk7XG4gICAgZ2V0SXNvbGF0aW9uU2NvcGUoKS5zZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEoeyBub3JtYWxpemVkUmVxdWVzdCB9KTtcblxuICAgIGNvbnN0IHNwYW4gPSBnZXRBY3RpdmVTcGFuKCk7XG5cbiAgICAvLyBPbmx5IHNldCB0aGUgcm91dGUgYmFja2ZpbGwgaWYgdGhlIHNwYW4gaXMgbm90IGZvciAvX2Vycm9yXG4gICAgaWYgKHNwYW4gJiYgb3B0aW9ucy5yZXF1ZXN0ZWRSb3V0ZU5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgY29uc3Qgcm9vdCA9IGdldFJvb3RTcGFuKHNwYW4pO1xuICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoVFJBTlNBQ1RJT05fQVRUUl9TRU5UUllfUk9VVEVfQkFDS0ZJTEwsIG9wdGlvbnMucmVxdWVzdGVkUm91dGVOYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCB7ICdzZW50cnktdHJhY2UnOiBzZW50cnlUcmFjZSwgYmFnZ2FnZSB9ID0gZ2V0VHJhY2VEYXRhKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2VudHJ5VHJhY2U6IHNlbnRyeVRyYWNlLFxuICAgICAgYmFnZ2FnZTogYmFnZ2FnZSxcbiAgICAgIGRhdGE6IGF3YWl0IG9yaWdEYXRhRmV0Y2hlci5hcHBseSh0aGlzLCBhcmdzKSxcbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIENhbGwgYSBkYXRhIGZldGNoZXIgYW5kIHRyYWNlIGl0LiBPbmx5IHRyYWNlcyB0aGUgZnVuY3Rpb24gaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHRyYW5zYWN0aW9uIG9uIHRoZSBzY29wZS5cbiAqXG4gKiBXZSBvbmx5IGRvIHRoZSBmb2xsb3dpbmcgdW50aWwgd2UgbW92ZSB0cmFuc2FjdGlvbiBjcmVhdGlvbiBpbnRvIHRoaXMgZnVuY3Rpb246IFdoZW4gY2FsbGVkLCB0aGUgd3JhcHBlZCBmdW5jdGlvblxuICogd2lsbCBhbHNvIHVwZGF0ZSB0aGUgbmFtZSBvZiB0aGUgYWN0aXZlIHRyYW5zYWN0aW9uIHdpdGggYSBwYXJhbWV0ZXJpemVkIHJvdXRlIHByb3ZpZGVkIHZpYSB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFGZXRjaGVyVHJhY2VkKFxuICBvcmlnRnVuY3Rpb24sXG4gIG9yaWdGdW5jdGlvbkFyZ3MsXG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgb3JpZ0Z1bmN0aW9uKC4uLm9yaWdGdW5jdGlvbkFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FwdHVyZUV4Y2VwdGlvbihlLCB7IG1lY2hhbmlzbTogeyBoYW5kbGVkOiBmYWxzZSB9IH0pO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgcGFyYW1zIGFuZCBzZWFyY2hQYXJhbXMgZnJvbSB0aGUgcHJvcHMgb2JqZWN0LlxuICpcbiAqIERlcGVuZGluZyBvbiB0aGUgbmV4dCB2ZXJzaW9uLCBwYXJhbXMgYW5kIHNlYXJjaFBhcmFtcyBtYXkgYmUgYSBwcm9taXNlIHdoaWNoIHdlIGRvIG5vdCB3YW50IHRvIHJlc29sdmUgaW4gdGhpcyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF5YmVFeHRyYWN0U3luY2hyb25vdXNQYXJhbXNBbmRTZWFyY2hQYXJhbXMocHJvcHMpXG5cbiB7XG4gIGxldCBwYXJhbXMgPVxuICAgIHByb3BzICYmIHR5cGVvZiBwcm9wcyA9PT0gJ29iamVjdCcgJiYgJ3BhcmFtcycgaW4gcHJvcHNcbiAgICAgID8gKHByb3BzLnBhcmFtcyApXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzVGhlbmFibGUocGFyYW1zKSkge1xuICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxldCBzZWFyY2hQYXJhbXMgPVxuICAgIHByb3BzICYmIHR5cGVvZiBwcm9wcyA9PT0gJ29iamVjdCcgJiYgJ3NlYXJjaFBhcmFtcycgaW4gcHJvcHNcbiAgICAgID8gKHByb3BzLnNlYXJjaFBhcmFtcyApXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzVGhlbmFibGUoc2VhcmNoUGFyYW1zKSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB7IHBhcmFtcywgc2VhcmNoUGFyYW1zIH07XG59XG5cbmV4cG9ydCB7IGNhbGxEYXRhRmV0Y2hlclRyYWNlZCwgbWF5YmVFeHRyYWN0U3luY2hyb25vdXNQYXJhbXNBbmRTZWFyY2hQYXJhbXMsIHdpdGhFcnJvckluc3RydW1lbnRhdGlvbiwgd2l0aFRyYWNlZFNlcnZlclNpZGVEYXRhRmV0Y2hlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcHBlclV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/@sentry+nextjs@9.46.0_@opentelemetry+context-async-hooks@1.30.1_@opentelemetry+api@1.9._42796a51c56a345b0bf099c431630b51/node_modules/@sentry/nextjs/build/esm/common/utils/wrapperUtils.js\n"));

## TypeScript TODOs

- `./frontend/sentry.edge.config.ts:50` - // TODO: Replace with proper logging
- `./frontend/instrumentation-client.ts:86` - // TODO: Replace with proper logging
- `./frontend/sentry.client.config.ts:86` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:108` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:117` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:134` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:198` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:227` - buildTime: 0 // TODO: Measure build time
- `./frontend/scripts/qa-quality-dashboard.ts:263` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:290` - criticalIssues: [] // TODO: Parse specific issues
- `./frontend/scripts/qa-quality-dashboard.ts:294` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:321` - slowestTests: [] // TODO: Extract slowest tests
- `./frontend/scripts/qa-quality-dashboard.ts:335` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:359` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:432` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:438` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:577` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:579` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:581` - // TODO: Replace with proper logging
- `./frontend/scripts/qa-quality-dashboard.ts:583` - // TODO: Replace with proper logging
