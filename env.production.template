# Backend production environment template
# Copy to .env.prod and fill secrets, then run:
# docker compose -f docker-compose.prod.yml --env-file .env.prod up -d app redis
# or for HTTP-only nginx proxy (no TLS) use:
# docker compose -f docker-compose.prod.http.yml --env-file .env.prod up -d

# Runtime
ENVIRONMENT=production

# Database (PostgreSQL)
# e.g., postgresql://user:pass@host:5432/dbname
DATABASE_URL=

# JWT
# Must be at least 32 characters
JWT_SECRET_KEY=

# Redis
# Strong password for Redis container (used by healthcheck and optional authentication)
REDIS_PASSWORD=

# Optional explicit Redis URL; if not set, services will default to redis://:${REDIS_PASSWORD}@redis:6379/0
# REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0

# Google AI (optional if AI features are disabled)
GOOGLE_API_KEY=

# Encryption key for sensitive data (Fernet base64 urlsafe key)
# You can generate one with: python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
FERNET_KEY=

# Observability (optional)
SENTRY_DSN=

# CORS (optional overrides)
# ALLOWED_ORIGINS=https://app.ruleiq.com,https://www.ruleiq.com

# Celery (optional; workers are disabled unless you run with --profile celery)
# If not set, celery_app.py will fall back to REDIS_URL db 1 and 2
# CELERY_BROKER_URL=redis://:${REDIS_PASSWORD}@redis:6379/1
# CELERY_RESULT_BACKEND=redis://:${REDIS_PASSWORD}@redis:6379/2