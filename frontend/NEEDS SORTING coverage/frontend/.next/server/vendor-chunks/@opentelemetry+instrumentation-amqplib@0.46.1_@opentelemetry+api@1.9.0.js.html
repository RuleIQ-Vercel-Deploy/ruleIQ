
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for frontend/.next/server/vendor-chunks/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">frontend/.next/server/vendor-chunks</a> @opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/119</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/119</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >"use strict";</span></span></span>
<span class="cstat-no" title="statement not covered" >/*</span>
<span class="cstat-no" title="statement not covered" > * ATTENTION: An "eval-source-map" devtool has been used.</span>
<span class="cstat-no" title="statement not covered" > * This devtool is neither made for production nor for readable output files.</span>
<span class="cstat-no" title="statement not covered" > * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.</span>
<span class="cstat-no" title="statement not covered" > * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)</span>
<span class="cstat-no" title="statement not covered" > * or disable the default devtool with "devtool: false".</span>
<span class="cstat-no" title="statement not covered" > * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).</span>
<span class="cstat-no" title="statement not covered" > */</span>
<span class="cstat-no" title="statement not covered" >exports.id = "vendor-chunks/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0";</span>
<span class="cstat-no" title="statement not covered" >exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0"];</span>
<span class="cstat-no" title="statement not covered" >exports.modules = {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js":</span>
<span class="cstat-no" title="statement not covered" >/*!****************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \****************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.36.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\");\nconst supportedVersions = ['&gt;=0.5.5 &lt;1'];\nclass AmqplibInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config));\n    }\n    setConfig(config = {}) {\n        super.setConfig(Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config));\n    }\n    init() {\n        const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/channel_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/callback_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/connect.js', supportedVersions, this.patchConnect.bind(this), this.unpatchConnect.bind(this));\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('amqplib', supportedVersions, undefined, undefined, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);\n        return module;\n    }\n    patchConnect(moduleExports) {\n        moduleExports = this.unpatchConnect(moduleExports);\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._wrap(moduleExports, 'connect', this.getConnectPatch.bind(this));\n        }\n        return moduleExports;\n    }\n    unpatchConnect(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._unwrap(moduleExports, 'connect');\n        }\n        return moduleExports;\n    }\n    patchChannelModel(moduleExports, moduleVersion) {\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._wrap(moduleExports.Channel.prototype, 'publish', this.getPublishPatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._wrap(moduleExports.Channel.prototype, 'consume', this.getConsumePatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._wrap(moduleExports.Channel.prototype, 'ack', this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._wrap(moduleExports.Channel.prototype, 'nack', this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._wrap(moduleExports.Channel.prototype, 'reject', this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'ackAll', this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'nackAll', this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._wrap(moduleExports.Channel.prototype, 'emit', this.getChannelEmitPatch.bind(this));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._wrap(moduleExports.ConfirmChannel.prototype, 'publish', this.getConfirmedPublishPatch.bind(this, moduleVersion));\n        }\n        return moduleExports;\n    }\n    unpatchChannelModel(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._unwrap(moduleExports.Channel.prototype, 'publish');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._unwrap(moduleExports.Channel.prototype, 'consume');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._unwrap(moduleExports.Channel.prototype, 'reject');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._unwrap(moduleExports.Channel.prototype, 'emit');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._unwrap(moduleExports.ConfirmChannel.prototype, 'publish');\n        }\n        return moduleExports;\n    }\n    getConnectPatch(original) {\n        return function patchedConnect(url, socketOptions, openCallback) {\n            return original.call(this, url, socketOptions, function (err, conn) {\n                if (err == null) {\n                    const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url);\n                    // the type of conn in @types/amqplib is amqp.Connection, but in practice the library send the\n                    // `serverProperties` on the `conn` and not in a property `connection`.\n                    // I don't have capacity to debug it currently but it should probably be fixed in @types or\n                    // in the package itself\n                    // currently setting as any to calm typescript\n                    const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);\n                    conn[utils_1.CONNECTION_ATTRIBUTES] = Object.assign(Object.assign({}, urlAttributes), serverAttributes);\n                }\n                openCallback.apply(this, arguments);\n            });\n        };\n    }\n    getChannelEmitPatch(original) {\n        const self = this;\n        return function emit(eventName) {\n            if (eventName === 'close') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, undefined);\n                const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];\n                if (activeTimer) {\n                    clearInterval(activeTimer);\n                }\n                this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = undefined;\n            }\n            else if (eventName === 'error') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, undefined);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getAckAllPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ackAll(requeueOrEmpty) {\n            self.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);\n            return original.apply(this, arguments);\n        };\n    }\n    getAckPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ack(message, allUpToOrRequeue, requeue) {\n            var _a;\n            const channel = this;\n            // we use this patch in reject function as well, but it has different signature\n            const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;\n            const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n            const msgIndex = spansNotEnded.findIndex(msgDetails =&gt; msgDetails.msg === message);\n            if (msgIndex &lt; 0) {\n                // should not happen in happy flow\n                // but possible if user is calling the api function ack twice with same message\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n            }\n            else if (endOperation !== types_1.EndOperation.Reject &amp;&amp; allUpToOrRequeue) {\n                for (let i = 0; i &lt;= msgIndex; i++) {\n                    self.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);\n                }\n                spansNotEnded.splice(0, msgIndex + 1);\n            }\n            else {\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n                spansNotEnded.splice(msgIndex, 1);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getConsumePatch(moduleVersion, original) {\n        const self = this;\n        return function consume(queue, onMessage, options) {\n            const channel = this;\n            if (!Object.prototype.hasOwnProperty.call(channel, utils_1.CHANNEL_SPANS_NOT_ENDED)) {\n                const { consumeTimeoutMs } = self.getConfig();\n                if (consumeTimeoutMs) {\n                    const timer = setInterval(() =&gt; {\n                        self.checkConsumeTimeoutOnChannel(channel);\n                    }, consumeTimeoutMs);\n                    timer.unref();\n                    channel[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;\n                }\n                channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n            }\n            const patchedOnMessage = function (msg) {\n                var _a, _b, _c, _d, _e;\n                // msg is expected to be null for signaling consumer cancel notification\n                // https://www.rabbitmq.com/consumer-cancel.html\n                // in this case, we do not start a span, as this is not a real message.\n                if (!msg) {\n                    return onMessage.call(this, msg);\n                }\n                const headers = (_a = msg.properties.headers) !== null &amp;&amp; _a !== void 0 ? _a : {};\n                let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n                const exchange = (_b = msg.fields) === null || _b === void 0 ? void 0 : _b.exchange;\n                let links;\n                if (self._config.useLinksForConsume) {\n                    const parentSpanContext = parentContext\n                        ? (_c = api_1.trace.getSpan(parentContext)) === null || _c === void 0 ? void 0 : _c.spanContext()\n                        : undefined;\n                    parentContext = undefined;\n                    if (parentSpanContext) {\n                        links = [\n                            {\n                                context: parentSpanContext,\n                            },\n                        ];\n                    }\n                }\n                const span = self.tracer.startSpan(`${queue} process`, {\n                    kind: api_1.SpanKind.CONSUMER,\n                    attributes: Object.assign(Object.assign({}, (_d = channel === null || channel === void 0 ? void 0 : channel.connection) === null || _d === void 0 ? void 0 : _d[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: (_e = msg.fields) === null || _e === void 0 ? void 0 : _e.routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: msg === null || msg === void 0 ? void 0 : msg.properties.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: msg === null || msg === void 0 ? void 0 : msg.properties.correlationId }),\n                    links,\n                }, parentContext);\n                const { consumeHook } = self.getConfig();\n                if (consumeHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; consumeHook(span, { moduleVersion, msg }), e =&gt; {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: consumerHook error', e);\n                        }\n                    }, true);\n                }\n                if (!(options === null || options === void 0 ? void 0 : options.noAck)) {\n                    // store the message on the channel so we can close the span on ackAll etc\n                    channel[utils_1.CHANNEL_SPANS_NOT_ENDED].push({\n                        msg,\n                        timeOfConsume: (0, core_1.hrTime)(),\n                    });\n                    // store the span on the message, so we can end it when user call 'ack' on it\n                    msg[utils_1.MESSAGE_STORED_SPAN] = span;\n                }\n                const setContext = parentContext\n                    ? parentContext\n                    : api_1.ROOT_CONTEXT;\n                api_1.context.with(api_1.trace.setSpan(setContext, span), () =&gt; {\n                    onMessage.call(this, msg);\n                });\n                if (options === null || options === void 0 ? void 0 : options.noAck) {\n                    self.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);\n                    span.end();\n                }\n            };\n            arguments[1] = patchedOnMessage;\n            return original.apply(this, arguments);\n        };\n    }\n    getConfirmedPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function confirmedPublish(exchange, routingKey, content, options, callback) {\n            const channel = this;\n            const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n            const { publishHook } = self.getConfig();\n            if (publishHook) {\n                (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishHook(span, {\n                    moduleVersion,\n                    exchange,\n                    routingKey,\n                    content,\n                    options: modifiedOptions,\n                    isConfirmChannel: true,\n                }), e =&gt; {\n                    if (e) {\n                        api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                    }\n                }, true);\n            }\n            const patchedOnConfirm = function (err, ok) {\n                try {\n                    callback === null || callback === void 0 ? void 0 : callback.call(this, err, ok);\n                }\n                finally {\n                    const { publishConfirmHook } = self.getConfig();\n                    if (publishConfirmHook) {\n                        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishConfirmHook(span, {\n                            moduleVersion,\n                            exchange,\n                            routingKey,\n                            content,\n                            options,\n                            isConfirmChannel: true,\n                            confirmError: err,\n                        }), e =&gt; {\n                            if (e) {\n                                api_1.diag.error('amqplib instrumentation: publishConfirmHook error', e);\n                            }\n                        }, true);\n                    }\n                    if (err) {\n                        span.setStatus({\n                            code: api_1.SpanStatusCode.ERROR,\n                            message: \"message confirmation has been nack'ed\",\n                        });\n                    }\n                    span.end();\n                }\n            };\n            // calling confirm channel publish function is storing the message in queue and registering the callback for broker confirm.\n            // span ends in the patched callback.\n            const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());\n            const argumentsCopy = [...arguments];\n            argumentsCopy[3] = modifiedOptions;\n            argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);\n            return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));\n        };\n    }\n    getPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function publish(exchange, routingKey, content, options) {\n            if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {\n                // work already done\n                return original.apply(this, arguments);\n            }\n            else {\n                const channel = this;\n                const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n                const { publishHook } = self.getConfig();\n                if (publishHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishHook(span, {\n                        moduleVersion,\n                        exchange,\n                        routingKey,\n                        content,\n                        options: modifiedOptions,\n                        isConfirmChannel: false,\n                    }), e =&gt; {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                        }\n                    }, true);\n                }\n                // calling normal channel publish function is only storing the message in queue.\n                // it does not send it and waits for an ack, so the span duration is expected to be very short.\n                const argumentsCopy = [...arguments];\n                argumentsCopy[3] = modifiedOptions;\n                const originalRes = original.apply(this, argumentsCopy);\n                span.end();\n                return originalRes;\n            }\n        };\n    }\n    createPublishSpan(self, exchange, routingKey, channel, options) {\n        var _a;\n        const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);\n        const span = self.tracer.startSpan(`publish ${normalizedExchange}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: Object.assign(Object.assign({}, channel.connection[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: options === null || options === void 0 ? void 0 : options.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: options === null || options === void 0 ? void 0 : options.correlationId }),\n        });\n        const modifiedOptions = options !== null &amp;&amp; options !== void 0 ? options : {};\n        modifiedOptions.headers = (_a = modifiedOptions.headers) !== null &amp;&amp; _a !== void 0 ? _a : {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);\n        return { span, modifiedOptions };\n    }\n    endConsumerSpan(message, isRejected, operation, requeue) {\n        const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];\n        if (!storedSpan)\n            return;\n        if (isRejected !== false) {\n            storedSpan.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: operation !== types_1.EndOperation.ChannelClosed &amp;&amp;\n                    operation !== types_1.EndOperation.ChannelError\n                    ? `${operation} called on message${requeue === true\n                        ? ' with requeue'\n                        : requeue === false\n                            ? ' without requeue'\n                            : ''}`\n                    : operation,\n            });\n        }\n        this.callConsumeEndHook(storedSpan, message, isRejected, operation);\n        storedSpan.end();\n        message[utils_1.MESSAGE_STORED_SPAN] = undefined;\n    }\n    endAllSpansOnChannel(channel, isRejected, operation, requeue) {\n        var _a;\n        const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n        spansNotEnded.forEach(msgDetails =&gt; {\n            this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);\n        });\n        channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n    }\n    callConsumeEndHook(span, msg, rejected, endOperation) {\n        const { consumeEndHook } = this.getConfig();\n        if (!consumeEndHook)\n            return;\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; consumeEndHook(span, { msg, rejected, endOperation }), e =&gt; {\n            if (e) {\n                api_1.diag.error('amqplib instrumentation: consumerEndHook error', e);\n            }\n        }, true);\n    }\n    checkConsumeTimeoutOnChannel(channel) {\n        var _a;\n        const currentTime = (0, core_1.hrTime)();\n        const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n        let i;\n        const { consumeTimeoutMs } = this.getConfig();\n        for (i = 0; i &lt; spansNotEnded.length; i++) {\n            const currMessage = spansNotEnded[i];\n            const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);\n            if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) &lt; consumeTimeoutMs) {\n                break;\n            }\n            this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);\n        }\n        spansNotEnded.splice(0, i);\n    }\n}\nexports.AmqplibInstrumentation = AmqplibInstrumentation;\n//# sourceMappingURL=amqplib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9hbXFwbGliLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMseUlBQW9CO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxzS0FBcUI7QUFDNUMsMEJBQTBCLG1CQUFPLENBQUMsdU1BQWdDO0FBQ2xFLCtCQUErQixtQkFBTyxDQUFDLDZMQUFxQztBQUM1RSxnQkFBZ0IsbUJBQU8sQ0FBQyxnTUFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnTUFBUztBQUNqQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLG9NQUFXO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsK0ZBQStGO0FBQy9GO0FBQ0EseUJBQXlCO0FBQ3pCLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBLDhEQUE4RCx5SkFBeUosdXJCQUF1ckI7QUFDOTRCO0FBQ0EsaUJBQWlCO0FBQ2pCLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0EsNEZBQTRGLG9CQUFvQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRCx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFtQjtBQUN6RTtBQUNBLHNEQUFzRCx3REFBd0QsK2dCQUErZ0I7QUFDN25CLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLG1GQUFtRiw2QkFBNkI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjQ2LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvYW1xcGxpYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW1xcGxpYkluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29yZVwiKTtcbmNvbnN0IGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiKTtcbmNvbnN0IHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5jb25zdCBzdXBwb3J0ZWRWZXJzaW9ucyA9IFsnPj0wLjUuNSA8MSddO1xuY2xhc3MgQW1xcGxpYkluc3RydW1lbnRhdGlvbiBleHRlbmRzIGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHZlcnNpb25fMS5QQUNLQUdFX05BTUUsIHZlcnNpb25fMS5QQUNLQUdFX1ZFUlNJT04sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHlwZXNfMS5ERUZBVUxUX0NPTkZJRyksIGNvbmZpZykpO1xuICAgIH1cbiAgICBzZXRDb25maWcoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIuc2V0Q29uZmlnKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHlwZXNfMS5ERUZBVUxUX0NPTkZJRyksIGNvbmZpZykpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBjaGFubmVsTW9kZWxNb2R1bGVGaWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVGaWxlKCdhbXFwbGliL2xpYi9jaGFubmVsX21vZGVsLmpzJywgc3VwcG9ydGVkVmVyc2lvbnMsIHRoaXMucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSwgdGhpcy51bnBhdGNoQ2hhbm5lbE1vZGVsLmJpbmQodGhpcykpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01vZGVsTW9kdWxlRmlsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRmlsZSgnYW1xcGxpYi9saWIvY2FsbGJhY2tfbW9kZWwuanMnLCBzdXBwb3J0ZWRWZXJzaW9ucywgdGhpcy5wYXRjaENoYW5uZWxNb2RlbC5iaW5kKHRoaXMpLCB0aGlzLnVucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RNb2R1bGVGaWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVGaWxlKCdhbXFwbGliL2xpYi9jb25uZWN0LmpzJywgc3VwcG9ydGVkVmVyc2lvbnMsIHRoaXMucGF0Y2hDb25uZWN0LmJpbmQodGhpcyksIHRoaXMudW5wYXRjaENvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbignYW1xcGxpYicsIHN1cHBvcnRlZFZlcnNpb25zLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgW2NoYW5uZWxNb2RlbE1vZHVsZUZpbGUsIGNvbm5lY3RNb2R1bGVGaWxlLCBjYWxsYmFja01vZGVsTW9kdWxlRmlsZV0pO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICBwYXRjaENvbm5lY3QobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBtb2R1bGVFeHBvcnRzID0gdGhpcy51bnBhdGNoQ29ubmVjdChtb2R1bGVFeHBvcnRzKTtcbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLmNvbm5lY3QpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMsICdjb25uZWN0JywgdGhpcy5nZXRDb25uZWN0UGF0Y2guYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgfVxuICAgIHVucGF0Y2hDb25uZWN0KG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuY29ubmVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAnY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICBwYXRjaENoYW5uZWxNb2RlbChtb2R1bGVFeHBvcnRzLCBtb2R1bGVWZXJzaW9uKSB7XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcsIHRoaXMuZ2V0UHVibGlzaFBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5jb25zdW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnY29uc3VtZScsIHRoaXMuZ2V0Q29uc3VtZVBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdhY2snLCB0aGlzLmdldEFja1BhdGNoLmJpbmQodGhpcywgZmFsc2UsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5uYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFjaycsIHRoaXMuZ2V0QWNrUGF0Y2guYmluZCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5OYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLnJlamVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ3JlamVjdCcsIHRoaXMuZ2V0QWNrUGF0Y2guYmluZCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5SZWplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrQWxsJywgdGhpcy5nZXRBY2tBbGxQYXRjaC5iaW5kKHRoaXMsIGZhbHNlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5BY2tBbGwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ25hY2tBbGwnLCB0aGlzLmdldEFja0FsbFBhdGNoLmJpbmQodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uTmFja0FsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5lbWl0KSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnZW1pdCcsIHRoaXMuZ2V0Q2hhbm5lbEVtaXRQYXRjaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2gpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcsIHRoaXMuZ2V0Q29uZmlybWVkUHVibGlzaFBhdGNoLmJpbmQodGhpcywgbW9kdWxlVmVyc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICB1bnBhdGNoQ2hhbm5lbE1vZGVsKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmNvbnN1bWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2NvbnN1bWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2FjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLm5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ25hY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5yZWplY3QpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ3JlamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrQWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFja0FsbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmVtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2VtaXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5Db25maXJtQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNvbmZpcm1DaGFubmVsLnByb3RvdHlwZSwgJ3B1Ymxpc2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICB9XG4gICAgZ2V0Q29ubmVjdFBhdGNoKG9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaGVkQ29ubmVjdCh1cmwsIHNvY2tldE9wdGlvbnMsIG9wZW5DYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmNhbGwodGhpcywgdXJsLCBzb2NrZXRPcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBjb25uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybEF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwpKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0eXBlIG9mIGNvbm4gaW4gQHR5cGVzL2FtcXBsaWIgaXMgYW1xcC5Db25uZWN0aW9uLCBidXQgaW4gcHJhY3RpY2UgdGhlIGxpYnJhcnkgc2VuZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYHNlcnZlclByb3BlcnRpZXNgIG9uIHRoZSBgY29ubmAgYW5kIG5vdCBpbiBhIHByb3BlcnR5IGBjb25uZWN0aW9uYC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSSBkb24ndCBoYXZlIGNhcGFjaXR5IHRvIGRlYnVnIGl0IGN1cnJlbnRseSBidXQgaXQgc2hvdWxkIHByb2JhYmx5IGJlIGZpeGVkIGluIEB0eXBlcyBvclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgcGFja2FnZSBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudGx5IHNldHRpbmcgYXMgYW55IHRvIGNhbG0gdHlwZXNjcmlwdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tU2VydmVyKShjb25uKTtcbiAgICAgICAgICAgICAgICAgICAgY29ublt1dGlsc18xLkNPTk5FQ1RJT05fQVRUUklCVVRFU10gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVybEF0dHJpYnV0ZXMpLCBzZXJ2ZXJBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3BlbkNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbEVtaXRQYXRjaChvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbmRBbGxTcGFuc09uQ2hhbm5lbCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5DaGFubmVsQ2xvc2VkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVRpbWVyID0gdGhpc1t1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChhY3RpdmVUaW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbdXRpbHNfMS5DSEFOTkVMX0NPTlNVTUVfVElNRU9VVF9USU1FUl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZEFsbFNwYW5zT25DaGFubmVsKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxFcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRBY2tBbGxQYXRjaChpc1JlamVjdGVkLCBlbmRPcGVyYXRpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYWNrQWxsKHJlcXVldWVPckVtcHR5KSB7XG4gICAgICAgICAgICBzZWxmLmVuZEFsbFNwYW5zT25DaGFubmVsKHRoaXMsIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZU9yRW1wdHkpO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEFja1BhdGNoKGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhY2sobWVzc2FnZSwgYWxsVXBUb09yUmVxdWV1ZSwgcmVxdWV1ZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXM7XG4gICAgICAgICAgICAvLyB3ZSB1c2UgdGhpcyBwYXRjaCBpbiByZWplY3QgZnVuY3Rpb24gYXMgd2VsbCwgYnV0IGl0IGhhcyBkaWZmZXJlbnQgc2lnbmF0dXJlXG4gICAgICAgICAgICBjb25zdCByZXF1ZXVlUmVzb2x2ZWQgPSBlbmRPcGVyYXRpb24gPT09IHR5cGVzXzEuRW5kT3BlcmF0aW9uLlJlamVjdCA/IGFsbFVwVG9PclJlcXVldWUgOiByZXF1ZXVlO1xuICAgICAgICAgICAgY29uc3Qgc3BhbnNOb3RFbmRlZCA9IChfYSA9IGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgY29uc3QgbXNnSW5kZXggPSBzcGFuc05vdEVuZGVkLmZpbmRJbmRleChtc2dEZXRhaWxzID0+IG1zZ0RldGFpbHMubXNnID09PSBtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChtc2dJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlbiBpbiBoYXBweSBmbG93XG4gICAgICAgICAgICAgICAgLy8gYnV0IHBvc3NpYmxlIGlmIHVzZXIgaXMgY2FsbGluZyB0aGUgYXBpIGZ1bmN0aW9uIGFjayB0d2ljZSB3aXRoIHNhbWUgbWVzc2FnZVxuICAgICAgICAgICAgICAgIHNlbGYuZW5kQ29uc3VtZXJTcGFuKG1lc3NhZ2UsIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZVJlc29sdmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZE9wZXJhdGlvbiAhPT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uUmVqZWN0ICYmIGFsbFVwVG9PclJlcXVldWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtc2dJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kQ29uc3VtZXJTcGFuKHNwYW5zTm90RW5kZWRbaV0ubXNnLCBpc1JlamVjdGVkLCBlbmRPcGVyYXRpb24sIHJlcXVldWVSZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW5zTm90RW5kZWQuc3BsaWNlKDAsIG1zZ0luZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZENvbnN1bWVyU3BhbihtZXNzYWdlLCBpc1JlamVjdGVkLCBlbmRPcGVyYXRpb24sIHJlcXVldWVSZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgc3BhbnNOb3RFbmRlZC5zcGxpY2UobXNnSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENvbnN1bWVQYXRjaChtb2R1bGVWZXJzaW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN1bWUocXVldWUsIG9uTWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGFubmVsLCB1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29uc3VtZVRpbWVvdXRNcyB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZVRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hlY2tDb25zdW1lVGltZW91dE9uQ2hhbm5lbChjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgY29uc3VtZVRpbWVvdXRNcyk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX0NPTlNVTUVfVElNRU9VVF9USU1FUl0gPSB0aW1lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF0Y2hlZE9uTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgICAgIC8vIG1zZyBpcyBleHBlY3RlZCB0byBiZSBudWxsIGZvciBzaWduYWxpbmcgY29uc3VtZXIgY2FuY2VsIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJhYmJpdG1xLmNvbS9jb25zdW1lci1jYW5jZWwuaHRtbFxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSwgd2UgZG8gbm90IHN0YXJ0IGEgc3BhbiwgYXMgdGhpcyBpcyBub3QgYSByZWFsIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uTWVzc2FnZS5jYWxsKHRoaXMsIG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSAoX2EgPSBtc2cucHJvcGVydGllcy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50Q29udGV4dCA9IGFwaV8xLnByb3BhZ2F0aW9uLmV4dHJhY3QoYXBpXzEuUk9PVF9DT05URVhULCBoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGNoYW5nZSA9IChfYiA9IG1zZy5maWVsZHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5leGNoYW5nZTtcbiAgICAgICAgICAgICAgICBsZXQgbGlua3M7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2NvbmZpZy51c2VMaW5rc0ZvckNvbnN1bWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U3BhbkNvbnRleHQgPSBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IChfYyA9IGFwaV8xLnRyYWNlLmdldFNwYW4ocGFyZW50Q29udGV4dCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zcGFuQ29udGV4dCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFNwYW5Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHBhcmVudFNwYW5Db250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBzZWxmLnRyYWNlci5zdGFydFNwYW4oYCR7cXVldWV9IHByb2Nlc3NgLCB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLkNPTlNVTUVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfZCA9IGNoYW5uZWwgPT09IG51bGwgfHwgY2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbC5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbdXRpbHNfMS5DT05ORUNUSU9OX0FUVFJJQlVURVNdKSwgeyBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05dOiBleGNoYW5nZSwgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRdOiBzZW1hbnRpY19jb252ZW50aW9uc18xLk1FU1NBR0lOR0RFU1RJTkFUSU9OS0lORFZBTFVFU19UT1BJQywgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZXTogKF9lID0gbXNnLmZpZWxkcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJvdXRpbmdLZXksIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19PUEVSQVRJT05dOiBzZW1hbnRpY19jb252ZW50aW9uc18xLk1FU1NBR0lOR09QRVJBVElPTlZBTFVFU19QUk9DRVNTLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9JRF06IG1zZyA9PT0gbnVsbCB8fCBtc2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1zZy5wcm9wZXJ0aWVzLm1lc3NhZ2VJZCwgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX0NPTlZFUlNBVElPTl9JRF06IG1zZyA9PT0gbnVsbCB8fCBtc2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1zZy5wcm9wZXJ0aWVzLmNvcnJlbGF0aW9uSWQgfSksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLFxuICAgICAgICAgICAgICAgIH0sIHBhcmVudENvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29uc3VtZUhvb2sgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25zdW1lSG9vayhzcGFuLCB7IG1vZHVsZVZlcnNpb24sIG1zZyB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBjb25zdW1lckhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub0FjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIG1lc3NhZ2Ugb24gdGhlIGNoYW5uZWwgc28gd2UgY2FuIGNsb3NlIHRoZSBzcGFuIG9uIGFja0FsbCBldGNcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPZkNvbnN1bWU6ICgwLCBjb3JlXzEuaHJUaW1lKSgpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHNwYW4gb24gdGhlIG1lc3NhZ2UsIHNvIHdlIGNhbiBlbmQgaXQgd2hlbiB1c2VyIGNhbGwgJ2Fjaycgb24gaXRcbiAgICAgICAgICAgICAgICAgICAgbXNnW3V0aWxzXzEuTUVTU0FHRV9TVE9SRURfU1BBTl0gPSBzcGFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzZXRDb250ZXh0ID0gcGFyZW50Q29udGV4dFxuICAgICAgICAgICAgICAgICAgICA/IHBhcmVudENvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgOiBhcGlfMS5ST09UX0NPTlRFWFQ7XG4gICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC53aXRoKGFwaV8xLnRyYWNlLnNldFNwYW4oc2V0Q29udGV4dCwgc3BhbiksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25NZXNzYWdlLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vQWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsbENvbnN1bWVFbmRIb29rKHNwYW4sIG1zZywgZmFsc2UsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkF1dG9BY2spO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhcmd1bWVudHNbMV0gPSBwYXRjaGVkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENvbmZpcm1lZFB1Ymxpc2hQYXRjaChtb2R1bGVWZXJzaW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbmZpcm1lZFB1Ymxpc2goZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3BhbiwgbW9kaWZpZWRPcHRpb25zIH0gPSBzZWxmLmNyZWF0ZVB1Ymxpc2hTcGFuKHNlbGYsIGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjaGFubmVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHVibGlzaEhvb2sgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICBpZiAocHVibGlzaEhvb2spIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gcHVibGlzaEhvb2soc3Bhbiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBleGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgcm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogbW9kaWZpZWRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpc0NvbmZpcm1DaGFubmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBwdWJsaXNoSG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaGVkT25Db25maXJtID0gZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2suY2FsbCh0aGlzLCBlcnIsIG9rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHVibGlzaENvbmZpcm1Ib29rIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHVibGlzaENvbmZpcm1Ib29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gcHVibGlzaENvbmZpcm1Ib29rKHNwYW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRpbmdLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29uZmlybUNoYW5uZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IHB1Ymxpc2hDb25maXJtSG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIm1lc3NhZ2UgY29uZmlybWF0aW9uIGhhcyBiZWVuIG5hY2snZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgY29uZmlybSBjaGFubmVsIHB1Ymxpc2ggZnVuY3Rpb24gaXMgc3RvcmluZyB0aGUgbWVzc2FnZSBpbiBxdWV1ZSBhbmQgcmVnaXN0ZXJpbmcgdGhlIGNhbGxiYWNrIGZvciBicm9rZXIgY29uZmlybS5cbiAgICAgICAgICAgIC8vIHNwYW4gZW5kcyBpbiB0aGUgcGF0Y2hlZCBjYWxsYmFjay5cbiAgICAgICAgICAgIGNvbnN0IG1hcmtlZENvbnRleHQgPSAoMCwgdXRpbHNfMS5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nKShhcGlfMS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c0NvcHkgPSBbLi4uYXJndW1lbnRzXTtcbiAgICAgICAgICAgIGFyZ3VtZW50c0NvcHlbM10gPSBtb2RpZmllZE9wdGlvbnM7XG4gICAgICAgICAgICBhcmd1bWVudHNDb3B5WzRdID0gYXBpXzEuY29udGV4dC5iaW5kKCgwLCB1dGlsc18xLnVubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZykoYXBpXzEudHJhY2Uuc2V0U3BhbihtYXJrZWRDb250ZXh0LCBzcGFuKSksIHBhdGNoZWRPbkNvbmZpcm0pO1xuICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChtYXJrZWRDb250ZXh0LCBvcmlnaW5hbC5iaW5kKHRoaXMsIC4uLmFyZ3VtZW50c0NvcHkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UHVibGlzaFBhdGNoKG1vZHVsZVZlcnNpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzQ29uZmlybUNoYW5uZWxUcmFjaW5nKShhcGlfMS5jb250ZXh0LmFjdGl2ZSgpKSkge1xuICAgICAgICAgICAgICAgIC8vIHdvcmsgYWxyZWFkeSBkb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNwYW4sIG1vZGlmaWVkT3B0aW9ucyB9ID0gc2VsZi5jcmVhdGVQdWJsaXNoU3BhbihzZWxmLCBleGNoYW5nZSwgcm91dGluZ0tleSwgY2hhbm5lbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwdWJsaXNoSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAocHVibGlzaEhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHB1Ymxpc2hIb29rKHNwYW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZVZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRpbmdLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogbW9kaWZpZWRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25maXJtQ2hhbm5lbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IHB1Ymxpc2hIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIG5vcm1hbCBjaGFubmVsIHB1Ymxpc2ggZnVuY3Rpb24gaXMgb25seSBzdG9yaW5nIHRoZSBtZXNzYWdlIGluIHF1ZXVlLlxuICAgICAgICAgICAgICAgIC8vIGl0IGRvZXMgbm90IHNlbmQgaXQgYW5kIHdhaXRzIGZvciBhbiBhY2ssIHNvIHRoZSBzcGFuIGR1cmF0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIHZlcnkgc2hvcnQuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzQ29weSA9IFsuLi5hcmd1bWVudHNdO1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50c0NvcHlbM10gPSBtb2RpZmllZE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXMgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHNDb3B5KTtcbiAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlUHVibGlzaFNwYW4oc2VsZiwgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNoYW5uZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRXhjaGFuZ2UgPSAoMCwgdXRpbHNfMS5ub3JtYWxpemVFeGNoYW5nZSkoZXhjaGFuZ2UpO1xuICAgICAgICBjb25zdCBzcGFuID0gc2VsZi50cmFjZXIuc3RhcnRTcGFuKGBwdWJsaXNoICR7bm9ybWFsaXplZEV4Y2hhbmdlfWAsIHtcbiAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLlBST0RVQ0VSLFxuICAgICAgICAgICAgYXR0cmlidXRlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFubmVsLmNvbm5lY3Rpb25bdXRpbHNfMS5DT05ORUNUSU9OX0FUVFJJQlVURVNdKSwgeyBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05dOiBleGNoYW5nZSwgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX0RFU1RJTkFUSU9OX0tJTkRdOiBzZW1hbnRpY19jb252ZW50aW9uc18xLk1FU1NBR0lOR0RFU1RJTkFUSU9OS0lORFZBTFVFU19UT1BJQywgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZXTogcm91dGluZ0tleSwgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX01FU1NBR0VfSURdOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZUlkLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfQ09OVkVSU0FUSU9OX0lEXTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvcnJlbGF0aW9uSWQgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtb2RpZmllZE9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgbW9kaWZpZWRPcHRpb25zLmhlYWRlcnMgPSAoX2EgPSBtb2RpZmllZE9wdGlvbnMuaGVhZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgIGFwaV8xLnByb3BhZ2F0aW9uLmluamVjdChhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pLCBtb2RpZmllZE9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHJldHVybiB7IHNwYW4sIG1vZGlmaWVkT3B0aW9ucyB9O1xuICAgIH1cbiAgICBlbmRDb25zdW1lclNwYW4obWVzc2FnZSwgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZFNwYW4gPSBtZXNzYWdlW3V0aWxzXzEuTUVTU0FHRV9TVE9SRURfU1BBTl07XG4gICAgICAgIGlmICghc3RvcmVkU3BhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGlzUmVqZWN0ZWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdG9yZWRTcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3BlcmF0aW9uICE9PSB0eXBlc18xLkVuZE9wZXJhdGlvbi5DaGFubmVsQ2xvc2VkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiAhPT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uQ2hhbm5lbEVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gYCR7b3BlcmF0aW9ufSBjYWxsZWQgb24gbWVzc2FnZSR7cmVxdWV1ZSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnIHdpdGggcmVxdWV1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVxdWV1ZSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcgd2l0aG91dCByZXF1ZXVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyd9YFxuICAgICAgICAgICAgICAgICAgICA6IG9wZXJhdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvbnN1bWVFbmRIb29rKHN0b3JlZFNwYW4sIG1lc3NhZ2UsIGlzUmVqZWN0ZWQsIG9wZXJhdGlvbik7XG4gICAgICAgIHN0b3JlZFNwYW4uZW5kKCk7XG4gICAgICAgIG1lc3NhZ2VbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZW5kQWxsU3BhbnNPbkNoYW5uZWwoY2hhbm5lbCwgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc3BhbnNOb3RFbmRlZCA9IChfYSA9IGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICBzcGFuc05vdEVuZGVkLmZvckVhY2gobXNnRGV0YWlscyA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZENvbnN1bWVyU3Bhbihtc2dEZXRhaWxzLm1zZywgaXNSZWplY3RlZCwgb3BlcmF0aW9uLCByZXF1ZXVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0gPSBbXTtcbiAgICB9XG4gICAgY2FsbENvbnN1bWVFbmRIb29rKHNwYW4sIG1zZywgcmVqZWN0ZWQsIGVuZE9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVFbmRIb29rIH0gPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBpZiAoIWNvbnN1bWVFbmRIb29rKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uc3VtZUVuZEhvb2soc3BhbiwgeyBtc2csIHJlamVjdGVkLCBlbmRPcGVyYXRpb24gfSksIGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogY29uc3VtZXJFbmRIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICBjaGVja0NvbnN1bWVUaW1lb3V0T25DaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9ICgwLCBjb3JlXzEuaHJUaW1lKSgpO1xuICAgICAgICBjb25zdCBzcGFuc05vdEVuZGVkID0gKF9hID0gY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCB7IGNvbnN1bWVUaW1lb3V0TXMgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFuc05vdEVuZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyTWVzc2FnZSA9IHNwYW5zTm90RW5kZWRbaV07XG4gICAgICAgICAgICBjb25zdCB0aW1lRnJvbUNvbnN1bWUgPSAoMCwgY29yZV8xLmhyVGltZUR1cmF0aW9uKShjdXJyTWVzc2FnZS50aW1lT2ZDb25zdW1lLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICBpZiAoKDAsIGNvcmVfMS5oclRpbWVUb01pbGxpc2Vjb25kcykodGltZUZyb21Db25zdW1lKSA8IGNvbnN1bWVUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW5kQ29uc3VtZXJTcGFuKGN1cnJNZXNzYWdlLm1zZywgbnVsbCwgdHlwZXNfMS5FbmRPcGVyYXRpb24uSW5zdHJ1bWVudGF0aW9uVGltZW91dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnNOb3RFbmRlZC5zcGxpY2UoMCwgaSk7XG4gICAgfVxufVxuZXhwb3J0cy5BbXFwbGliSW5zdHJ1bWVudGF0aW9uID0gQW1xcGxpYkluc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcXBsaWIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ (function(__unused_webpack_module, exports, __webpack_require__) {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nvar __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this &amp;&amp; this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" &amp;&amp; !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n__exportStar(__webpack_require__(/*! ./amqplib */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLG9NQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxnTUFBUztBQUM5QiIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjQ2LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYW1xcGxpYlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CONFIG = exports.EndOperation = void 0;\nvar EndOperation;\n(function (EndOperation) {\n    EndOperation[\"AutoAck\"] = \"auto ack\";\n    EndOperation[\"Ack\"] = \"ack\";\n    EndOperation[\"AckAll\"] = \"ackAll\";\n    EndOperation[\"Reject\"] = \"reject\";\n    EndOperation[\"Nack\"] = \"nack\";\n    EndOperation[\"NackAll\"] = \"nackAll\";\n    EndOperation[\"ChannelClosed\"] = \"channel closed\";\n    EndOperation[\"ChannelError\"] = \"channel error\";\n    EndOperation[\"InstrumentationTimeout\"] = \"instrumentation timeout\";\n})(EndOperation = exports.EndOperation || (exports.EndOperation = {}));\nexports.DEFAULT_CONFIG = {\n    consumeTimeoutMs: 1000 * 60,\n    useLinksForConsume: false,\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDLG9CQUFvQixLQUFLO0FBQ3BFLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjQ2LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfQ09ORklHID0gZXhwb3J0cy5FbmRPcGVyYXRpb24gPSB2b2lkIDA7XG52YXIgRW5kT3BlcmF0aW9uO1xuKGZ1bmN0aW9uIChFbmRPcGVyYXRpb24pIHtcbiAgICBFbmRPcGVyYXRpb25bXCJBdXRvQWNrXCJdID0gXCJhdXRvIGFja1wiO1xuICAgIEVuZE9wZXJhdGlvbltcIkFja1wiXSA9IFwiYWNrXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQWNrQWxsXCJdID0gXCJhY2tBbGxcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJSZWplY3RcIl0gPSBcInJlamVjdFwiO1xuICAgIEVuZE9wZXJhdGlvbltcIk5hY2tcIl0gPSBcIm5hY2tcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJOYWNrQWxsXCJdID0gXCJuYWNrQWxsXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQ2hhbm5lbENsb3NlZFwiXSA9IFwiY2hhbm5lbCBjbG9zZWRcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJDaGFubmVsRXJyb3JcIl0gPSBcImNoYW5uZWwgZXJyb3JcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJJbnN0cnVtZW50YXRpb25UaW1lb3V0XCJdID0gXCJpbnN0cnVtZW50YXRpb24gdGltZW91dFwiO1xufSkoRW5kT3BlcmF0aW9uID0gZXhwb3J0cy5FbmRPcGVyYXRpb24gfHwgKGV4cG9ydHMuRW5kT3BlcmF0aW9uID0ge30pKTtcbmV4cG9ydHMuREVGQVVMVF9DT05GSUcgPSB7XG4gICAgY29uc3VtZVRpbWVvdXRNczogMTAwMCAqIDYwLFxuICAgIHVzZUxpbmtzRm9yQ29uc3VtZTogZmFsc2UsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isConfirmChannelTracing = exports.unmarkConfirmChannelTracing = exports.markConfirmChannelTracing = exports.getConnectionAttributesFromUrl = exports.getConnectionAttributesFromServer = exports.normalizeExchange = exports.CONNECTION_ATTRIBUTES = exports.CHANNEL_CONSUME_TIMEOUT_TIMER = exports.CHANNEL_SPANS_NOT_ENDED = exports.MESSAGE_STORED_SPAN = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.36.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nexports.MESSAGE_STORED_SPAN = Symbol('opentelemetry.amqplib.message.stored-span');\nexports.CHANNEL_SPANS_NOT_ENDED = Symbol('opentelemetry.amqplib.channel.spans-not-ended');\nexports.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol('opentelemetry.amqplib.channel.consumer-timeout-timer');\nexports.CONNECTION_ATTRIBUTES = Symbol('opentelemetry.amqplib.connection.attributes');\nconst IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)('opentelemetry.amqplib.channel.is-confirm-channel');\nconst normalizeExchange = (exchangeName) =&gt; exchangeName !== '' ? exchangeName : '&lt;default&gt;';\nexports.normalizeExchange = normalizeExchange;\nconst censorPassword = (url) =&gt; {\n    return url.replace(/:[^:@/]*@/, ':***@');\n};\nconst getPort = (portFromUrl, resolvedProtocol) =&gt; {\n    // we are using the resolved protocol which is upper case\n    // this code mimic the behavior of the amqplib which is used to set connection params\n    return portFromUrl || (resolvedProtocol === 'AMQP' ? 5672 : 5671);\n};\nconst getProtocol = (protocolFromUrl) =&gt; {\n    const resolvedProtocol = protocolFromUrl || 'amqp';\n    // the substring removed the ':' part of the protocol ('amqp:' -&gt; 'amqp')\n    const noEndingColon = resolvedProtocol.endsWith(':')\n        ? resolvedProtocol.substring(0, resolvedProtocol.length - 1)\n        : resolvedProtocol;\n    // upper cases to match spec\n    return noEndingColon.toUpperCase();\n};\nconst getHostname = (hostnameFromUrl) =&gt; {\n    // if user supplies empty hostname, it gets forwarded to 'net' package which default it to localhost.\n    // https://nodejs.org/docs/latest-v12.x/api/net.html#net_socket_connect_options_connectlistener\n    return hostnameFromUrl || 'localhost';\n};\nconst extractConnectionAttributeOrLog = (url, attributeKey, attributeValue, nameForLog) =&gt; {\n    if (attributeValue) {\n        return { [attributeKey]: attributeValue };\n    }\n    else {\n        api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {\n            url,\n        });\n        return {};\n    }\n};\nconst getConnectionAttributesFromServer = (conn) =&gt; {\n    var _a, _b;\n    const product = (_b = (_a = conn.serverProperties.product) === null || _a === void 0 ? void 0 : _a.toLowerCase) === null || _b === void 0 ? void 0 : _b.call(_a);\n    if (product) {\n        return {\n            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: product,\n        };\n    }\n    else {\n        return {};\n    }\n};\nexports.getConnectionAttributesFromServer = getConnectionAttributesFromServer;\nconst getConnectionAttributesFromUrl = (url) =&gt; {\n    const attributes = {\n        [semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL_VERSION]: '0.9.1', // this is the only protocol supported by the instrumented library\n    };\n    url = url || 'amqp://localhost';\n    if (typeof url === 'object') {\n        const connectOptions = url;\n        const protocol = getProtocol(connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.protocol);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, 'protocol')));\n        const hostname = getHostname(connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.hostname);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, 'hostname')));\n        const port = getPort(connectOptions.port, protocol);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, 'port')));\n    }\n    else {\n        const censoredUrl = censorPassword(url);\n        attributes[semantic_conventions_1.SEMATTRS_MESSAGING_URL] = censoredUrl;\n        try {\n            const urlParts = new URL(censoredUrl);\n            const protocol = getProtocol(urlParts.protocol);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, 'protocol')));\n            const hostname = getHostname(urlParts.hostname);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, 'hostname')));\n            const port = getPort(urlParts.port ? parseInt(urlParts.port) : undefined, protocol);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, 'port')));\n        }\n        catch (err) {\n            api_1.diag.error('amqplib instrumentation: error while extracting connection details from connection url', {\n                censoredUrl,\n                err,\n            });\n        }\n    }\n    return attributes;\n};\nexports.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;\nconst markConfirmChannelTracing = (context) =&gt; {\n    return context.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);\n};\nexports.markConfirmChannelTracing = markConfirmChannelTracing;\nconst unmarkConfirmChannelTracing = (context) =&gt; {\n    return context.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);\n};\nexports.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;\nconst isConfirmChannelTracing = (context) =&gt; {\n    return context.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;\n};\nexports.isConfirmChannelTracing = isConfirmChannelTracing;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxzQ0FBc0MsR0FBRyx5Q0FBeUMsR0FBRyx5QkFBeUIsR0FBRyw2QkFBNkIsR0FBRyxxQ0FBcUMsR0FBRywrQkFBK0IsR0FBRywyQkFBMkI7QUFDbFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHlJQUFvQjtBQUMxQywrQkFBK0IsbUJBQU8sQ0FBQyw2TEFBcUM7QUFDNUUsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0RkFBNEYsWUFBWTtBQUN4RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBleHBvcnRzLnVubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IGV4cG9ydHMubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IGV4cG9ydHMuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsID0gZXhwb3J0cy5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXIgPSBleHBvcnRzLm5vcm1hbGl6ZUV4Y2hhbmdlID0gZXhwb3J0cy5DT05ORUNUSU9OX0FUVFJJQlVURVMgPSBleHBvcnRzLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSID0gZXhwb3J0cy5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRCA9IGV4cG9ydHMuTUVTU0FHRV9TVE9SRURfU1BBTiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuZXhwb3J0cy5NRVNTQUdFX1NUT1JFRF9TUEFOID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIubWVzc2FnZS5zdG9yZWQtc3BhbicpO1xuZXhwb3J0cy5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRCA9IFN5bWJvbCgnb3BlbnRlbGVtZXRyeS5hbXFwbGliLmNoYW5uZWwuc3BhbnMtbm90LWVuZGVkJyk7XG5leHBvcnRzLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIuY2hhbm5lbC5jb25zdW1lci10aW1lb3V0LXRpbWVyJyk7XG5leHBvcnRzLkNPTk5FQ1RJT05fQVRUUklCVVRFUyA9IFN5bWJvbCgnb3BlbnRlbGVtZXRyeS5hbXFwbGliLmNvbm5lY3Rpb24uYXR0cmlidXRlcycpO1xuY29uc3QgSVNfQ09ORklSTV9DSEFOTkVMX0NPTlRFWFRfS0VZID0gKDAsIGFwaV8xLmNyZWF0ZUNvbnRleHRLZXkpKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIuY2hhbm5lbC5pcy1jb25maXJtLWNoYW5uZWwnKTtcbmNvbnN0IG5vcm1hbGl6ZUV4Y2hhbmdlID0gKGV4Y2hhbmdlTmFtZSkgPT4gZXhjaGFuZ2VOYW1lICE9PSAnJyA/IGV4Y2hhbmdlTmFtZSA6ICc8ZGVmYXVsdD4nO1xuZXhwb3J0cy5ub3JtYWxpemVFeGNoYW5nZSA9IG5vcm1hbGl6ZUV4Y2hhbmdlO1xuY29uc3QgY2Vuc29yUGFzc3dvcmQgPSAodXJsKSA9PiB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC86W146QC9dKkAvLCAnOioqKkAnKTtcbn07XG5jb25zdCBnZXRQb3J0ID0gKHBvcnRGcm9tVXJsLCByZXNvbHZlZFByb3RvY29sKSA9PiB7XG4gICAgLy8gd2UgYXJlIHVzaW5nIHRoZSByZXNvbHZlZCBwcm90b2NvbCB3aGljaCBpcyB1cHBlciBjYXNlXG4gICAgLy8gdGhpcyBjb2RlIG1pbWljIHRoZSBiZWhhdmlvciBvZiB0aGUgYW1xcGxpYiB3aGljaCBpcyB1c2VkIHRvIHNldCBjb25uZWN0aW9uIHBhcmFtc1xuICAgIHJldHVybiBwb3J0RnJvbVVybCB8fCAocmVzb2x2ZWRQcm90b2NvbCA9PT0gJ0FNUVAnID8gNTY3MiA6IDU2NzEpO1xufTtcbmNvbnN0IGdldFByb3RvY29sID0gKHByb3RvY29sRnJvbVVybCkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkUHJvdG9jb2wgPSBwcm90b2NvbEZyb21VcmwgfHwgJ2FtcXAnO1xuICAgIC8vIHRoZSBzdWJzdHJpbmcgcmVtb3ZlZCB0aGUgJzonIHBhcnQgb2YgdGhlIHByb3RvY29sICgnYW1xcDonIC0+ICdhbXFwJylcbiAgICBjb25zdCBub0VuZGluZ0NvbG9uID0gcmVzb2x2ZWRQcm90b2NvbC5lbmRzV2l0aCgnOicpXG4gICAgICAgID8gcmVzb2x2ZWRQcm90b2NvbC5zdWJzdHJpbmcoMCwgcmVzb2x2ZWRQcm90b2NvbC5sZW5ndGggLSAxKVxuICAgICAgICA6IHJlc29sdmVkUHJvdG9jb2w7XG4gICAgLy8gdXBwZXIgY2FzZXMgdG8gbWF0Y2ggc3BlY1xuICAgIHJldHVybiBub0VuZGluZ0NvbG9uLnRvVXBwZXJDYXNlKCk7XG59O1xuY29uc3QgZ2V0SG9zdG5hbWUgPSAoaG9zdG5hbWVGcm9tVXJsKSA9PiB7XG4gICAgLy8gaWYgdXNlciBzdXBwbGllcyBlbXB0eSBob3N0bmFtZSwgaXQgZ2V0cyBmb3J3YXJkZWQgdG8gJ25ldCcgcGFja2FnZSB3aGljaCBkZWZhdWx0IGl0IHRvIGxvY2FsaG9zdC5cbiAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QtdjEyLngvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfY29ubmVjdF9vcHRpb25zX2Nvbm5lY3RsaXN0ZW5lclxuICAgIHJldHVybiBob3N0bmFtZUZyb21VcmwgfHwgJ2xvY2FsaG9zdCc7XG59O1xuY29uc3QgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyA9ICh1cmwsIGF0dHJpYnV0ZUtleSwgYXR0cmlidXRlVmFsdWUsIG5hbWVGb3JMb2cpID0+IHtcbiAgICBpZiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgW2F0dHJpYnV0ZUtleV06IGF0dHJpYnV0ZVZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcGlfMS5kaWFnLmVycm9yKGBhbXFwbGliIGluc3RydW1lbnRhdGlvbjogY291bGQgbm90IGV4dHJhY3QgY29ubmVjdGlvbiBhdHRyaWJ1dGUgJHtuYW1lRm9yTG9nfSBmcm9tIHVzZXIgc3VwcGxpZWQgdXJsYCwge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn07XG5jb25zdCBnZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXIgPSAoY29ubikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgcHJvZHVjdCA9IChfYiA9IChfYSA9IGNvbm4uc2VydmVyUHJvcGVydGllcy5wcm9kdWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1NZU1RFTV06IHByb2R1Y3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tU2VydmVyID0gZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tU2VydmVyO1xuY29uc3QgZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsID0gKHVybCkgPT4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19QUk9UT0NPTF9WRVJTSU9OXTogJzAuOS4xJywgLy8gdGhpcyBpcyB0aGUgb25seSBwcm90b2NvbCBzdXBwb3J0ZWQgYnkgdGhlIGluc3RydW1lbnRlZCBsaWJyYXJ5XG4gICAgfTtcbiAgICB1cmwgPSB1cmwgfHwgJ2FtcXA6Ly9sb2NhbGhvc3QnO1xuICAgIGlmICh0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBjb25uZWN0T3B0aW9ucyA9IHVybDtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBnZXRQcm90b2NvbChjb25uZWN0T3B0aW9ucyA9PT0gbnVsbCB8fCBjb25uZWN0T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdE9wdGlvbnMucHJvdG9jb2wpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24oe30sIGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2codXJsLCBzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19QUk9UT0NPTCwgcHJvdG9jb2wsICdwcm90b2NvbCcpKSk7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gZ2V0SG9zdG5hbWUoY29ubmVjdE9wdGlvbnMgPT09IG51bGwgfHwgY29ubmVjdE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3RPcHRpb25zLmhvc3RuYW1lKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBPYmplY3QuYXNzaWduKHt9LCBleHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKHVybCwgc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9OQU1FLCBob3N0bmFtZSwgJ2hvc3RuYW1lJykpKTtcbiAgICAgICAgY29uc3QgcG9ydCA9IGdldFBvcnQoY29ubmVjdE9wdGlvbnMucG9ydCwgcHJvdG9jb2wpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24oe30sIGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2codXJsLCBzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX1BPUlQsIHBvcnQsICdwb3J0JykpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNlbnNvcmVkVXJsID0gY2Vuc29yUGFzc3dvcmQodXJsKTtcbiAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19VUkxdID0gY2Vuc29yZWRVcmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmxQYXJ0cyA9IG5ldyBVUkwoY2Vuc29yZWRVcmwpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBnZXRQcm90b2NvbCh1cmxQYXJ0cy5wcm90b2NvbCk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24oe30sIGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2coY2Vuc29yZWRVcmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MLCBwcm90b2NvbCwgJ3Byb3RvY29sJykpKTtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RuYW1lID0gZ2V0SG9zdG5hbWUodXJsUGFydHMuaG9zdG5hbWUpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBPYmplY3QuYXNzaWduKHt9LCBleHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKGNlbnNvcmVkVXJsLCBzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX05BTUUsIGhvc3RuYW1lLCAnaG9zdG5hbWUnKSkpO1xuICAgICAgICAgICAgY29uc3QgcG9ydCA9IGdldFBvcnQodXJsUGFydHMucG9ydCA/IHBhcnNlSW50KHVybFBhcnRzLnBvcnQpIDogdW5kZWZpbmVkLCBwcm90b2NvbCk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24oe30sIGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2coY2Vuc29yZWRVcmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVCwgcG9ydCwgJ3BvcnQnKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBlcnJvciB3aGlsZSBleHRyYWN0aW5nIGNvbm5lY3Rpb24gZGV0YWlscyBmcm9tIGNvbm5lY3Rpb24gdXJsJywge1xuICAgICAgICAgICAgICAgIGNlbnNvcmVkVXJsLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsID0gZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsO1xuY29uc3QgbWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHQuc2V0VmFsdWUoSVNfQ09ORklSTV9DSEFOTkVMX0NPTlRFWFRfS0VZLCB0cnVlKTtcbn07XG5leHBvcnRzLm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBtYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuY29uc3QgdW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gY29udGV4dC5kZWxldGVWYWx1ZShJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVkpO1xufTtcbmV4cG9ydHMudW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gdW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuY29uc3QgaXNDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSAoY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBjb250ZXh0LmdldFZhbHVlKElTX0NPTkZJUk1fQ0hBTk5FTF9DT05URVhUX0tFWSkgPT09IHRydWU7XG59O1xuZXhwb3J0cy5pc0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IGlzQ29uZmlybUNoYW5uZWxUcmFjaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js":</span>
<span class="cstat-no" title="statement not covered" >/*!****************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \****************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.46.1';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-amqplib';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSBleHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSAnMC40Ni4xJztcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js":</span>
<span class="cstat-no" title="statement not covered" >/*!****************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \****************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.36.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\");\nconst supportedVersions = ['&gt;=0.5.5 &lt;1'];\nclass AmqplibInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config));\n    }\n    setConfig(config = {}) {\n        super.setConfig(Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config));\n    }\n    init() {\n        const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/channel_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/callback_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/connect.js', supportedVersions, this.patchConnect.bind(this), this.unpatchConnect.bind(this));\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('amqplib', supportedVersions, undefined, undefined, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);\n        return module;\n    }\n    patchConnect(moduleExports) {\n        moduleExports = this.unpatchConnect(moduleExports);\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._wrap(moduleExports, 'connect', this.getConnectPatch.bind(this));\n        }\n        return moduleExports;\n    }\n    unpatchConnect(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._unwrap(moduleExports, 'connect');\n        }\n        return moduleExports;\n    }\n    patchChannelModel(moduleExports, moduleVersion) {\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._wrap(moduleExports.Channel.prototype, 'publish', this.getPublishPatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._wrap(moduleExports.Channel.prototype, 'consume', this.getConsumePatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._wrap(moduleExports.Channel.prototype, 'ack', this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._wrap(moduleExports.Channel.prototype, 'nack', this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._wrap(moduleExports.Channel.prototype, 'reject', this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'ackAll', this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'nackAll', this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._wrap(moduleExports.Channel.prototype, 'emit', this.getChannelEmitPatch.bind(this));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._wrap(moduleExports.ConfirmChannel.prototype, 'publish', this.getConfirmedPublishPatch.bind(this, moduleVersion));\n        }\n        return moduleExports;\n    }\n    unpatchChannelModel(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._unwrap(moduleExports.Channel.prototype, 'publish');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._unwrap(moduleExports.Channel.prototype, 'consume');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._unwrap(moduleExports.Channel.prototype, 'reject');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._unwrap(moduleExports.Channel.prototype, 'emit');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._unwrap(moduleExports.ConfirmChannel.prototype, 'publish');\n        }\n        return moduleExports;\n    }\n    getConnectPatch(original) {\n        return function patchedConnect(url, socketOptions, openCallback) {\n            return original.call(this, url, socketOptions, function (err, conn) {\n                if (err == null) {\n                    const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url);\n                    // the type of conn in @types/amqplib is amqp.Connection, but in practice the library send the\n                    // `serverProperties` on the `conn` and not in a property `connection`.\n                    // I don't have capacity to debug it currently but it should probably be fixed in @types or\n                    // in the package itself\n                    // currently setting as any to calm typescript\n                    const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);\n                    conn[utils_1.CONNECTION_ATTRIBUTES] = Object.assign(Object.assign({}, urlAttributes), serverAttributes);\n                }\n                openCallback.apply(this, arguments);\n            });\n        };\n    }\n    getChannelEmitPatch(original) {\n        const self = this;\n        return function emit(eventName) {\n            if (eventName === 'close') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, undefined);\n                const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];\n                if (activeTimer) {\n                    clearInterval(activeTimer);\n                }\n                this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = undefined;\n            }\n            else if (eventName === 'error') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, undefined);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getAckAllPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ackAll(requeueOrEmpty) {\n            self.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);\n            return original.apply(this, arguments);\n        };\n    }\n    getAckPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ack(message, allUpToOrRequeue, requeue) {\n            var _a;\n            const channel = this;\n            // we use this patch in reject function as well, but it has different signature\n            const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;\n            const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n            const msgIndex = spansNotEnded.findIndex(msgDetails =&gt; msgDetails.msg === message);\n            if (msgIndex &lt; 0) {\n                // should not happen in happy flow\n                // but possible if user is calling the api function ack twice with same message\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n            }\n            else if (endOperation !== types_1.EndOperation.Reject &amp;&amp; allUpToOrRequeue) {\n                for (let i = 0; i &lt;= msgIndex; i++) {\n                    self.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);\n                }\n                spansNotEnded.splice(0, msgIndex + 1);\n            }\n            else {\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n                spansNotEnded.splice(msgIndex, 1);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getConsumePatch(moduleVersion, original) {\n        const self = this;\n        return function consume(queue, onMessage, options) {\n            const channel = this;\n            if (!Object.prototype.hasOwnProperty.call(channel, utils_1.CHANNEL_SPANS_NOT_ENDED)) {\n                const { consumeTimeoutMs } = self.getConfig();\n                if (consumeTimeoutMs) {\n                    const timer = setInterval(() =&gt; {\n                        self.checkConsumeTimeoutOnChannel(channel);\n                    }, consumeTimeoutMs);\n                    timer.unref();\n                    channel[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;\n                }\n                channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n            }\n            const patchedOnMessage = function (msg) {\n                var _a, _b, _c, _d, _e;\n                // msg is expected to be null for signaling consumer cancel notification\n                // https://www.rabbitmq.com/consumer-cancel.html\n                // in this case, we do not start a span, as this is not a real message.\n                if (!msg) {\n                    return onMessage.call(this, msg);\n                }\n                const headers = (_a = msg.properties.headers) !== null &amp;&amp; _a !== void 0 ? _a : {};\n                let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n                const exchange = (_b = msg.fields) === null || _b === void 0 ? void 0 : _b.exchange;\n                let links;\n                if (self._config.useLinksForConsume) {\n                    const parentSpanContext = parentContext\n                        ? (_c = api_1.trace.getSpan(parentContext)) === null || _c === void 0 ? void 0 : _c.spanContext()\n                        : undefined;\n                    parentContext = undefined;\n                    if (parentSpanContext) {\n                        links = [\n                            {\n                                context: parentSpanContext,\n                            },\n                        ];\n                    }\n                }\n                const span = self.tracer.startSpan(`${queue} process`, {\n                    kind: api_1.SpanKind.CONSUMER,\n                    attributes: Object.assign(Object.assign({}, (_d = channel === null || channel === void 0 ? void 0 : channel.connection) === null || _d === void 0 ? void 0 : _d[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: (_e = msg.fields) === null || _e === void 0 ? void 0 : _e.routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: msg === null || msg === void 0 ? void 0 : msg.properties.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: msg === null || msg === void 0 ? void 0 : msg.properties.correlationId }),\n                    links,\n                }, parentContext);\n                const { consumeHook } = self.getConfig();\n                if (consumeHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; consumeHook(span, { moduleVersion, msg }), e =&gt; {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: consumerHook error', e);\n                        }\n                    }, true);\n                }\n                if (!(options === null || options === void 0 ? void 0 : options.noAck)) {\n                    // store the message on the channel so we can close the span on ackAll etc\n                    channel[utils_1.CHANNEL_SPANS_NOT_ENDED].push({\n                        msg,\n                        timeOfConsume: (0, core_1.hrTime)(),\n                    });\n                    // store the span on the message, so we can end it when user call 'ack' on it\n                    msg[utils_1.MESSAGE_STORED_SPAN] = span;\n                }\n                const setContext = parentContext\n                    ? parentContext\n                    : api_1.ROOT_CONTEXT;\n                api_1.context.with(api_1.trace.setSpan(setContext, span), () =&gt; {\n                    onMessage.call(this, msg);\n                });\n                if (options === null || options === void 0 ? void 0 : options.noAck) {\n                    self.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);\n                    span.end();\n                }\n            };\n            arguments[1] = patchedOnMessage;\n            return original.apply(this, arguments);\n        };\n    }\n    getConfirmedPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function confirmedPublish(exchange, routingKey, content, options, callback) {\n            const channel = this;\n            const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n            const { publishHook } = self.getConfig();\n            if (publishHook) {\n                (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishHook(span, {\n                    moduleVersion,\n                    exchange,\n                    routingKey,\n                    content,\n                    options: modifiedOptions,\n                    isConfirmChannel: true,\n                }), e =&gt; {\n                    if (e) {\n                        api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                    }\n                }, true);\n            }\n            const patchedOnConfirm = function (err, ok) {\n                try {\n                    callback === null || callback === void 0 ? void 0 : callback.call(this, err, ok);\n                }\n                finally {\n                    const { publishConfirmHook } = self.getConfig();\n                    if (publishConfirmHook) {\n                        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishConfirmHook(span, {\n                            moduleVersion,\n                            exchange,\n                            routingKey,\n                            content,\n                            options,\n                            isConfirmChannel: true,\n                            confirmError: err,\n                        }), e =&gt; {\n                            if (e) {\n                                api_1.diag.error('amqplib instrumentation: publishConfirmHook error', e);\n                            }\n                        }, true);\n                    }\n                    if (err) {\n                        span.setStatus({\n                            code: api_1.SpanStatusCode.ERROR,\n                            message: \"message confirmation has been nack'ed\",\n                        });\n                    }\n                    span.end();\n                }\n            };\n            // calling confirm channel publish function is storing the message in queue and registering the callback for broker confirm.\n            // span ends in the patched callback.\n            const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());\n            const argumentsCopy = [...arguments];\n            argumentsCopy[3] = modifiedOptions;\n            argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);\n            return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));\n        };\n    }\n    getPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function publish(exchange, routingKey, content, options) {\n            if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {\n                // work already done\n                return original.apply(this, arguments);\n            }\n            else {\n                const channel = this;\n                const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n                const { publishHook } = self.getConfig();\n                if (publishHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishHook(span, {\n                        moduleVersion,\n                        exchange,\n                        routingKey,\n                        content,\n                        options: modifiedOptions,\n                        isConfirmChannel: false,\n                    }), e =&gt; {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                        }\n                    }, true);\n                }\n                // calling normal channel publish function is only storing the message in queue.\n                // it does not send it and waits for an ack, so the span duration is expected to be very short.\n                const argumentsCopy = [...arguments];\n                argumentsCopy[3] = modifiedOptions;\n                const originalRes = original.apply(this, argumentsCopy);\n                span.end();\n                return originalRes;\n            }\n        };\n    }\n    createPublishSpan(self, exchange, routingKey, channel, options) {\n        var _a;\n        const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);\n        const span = self.tracer.startSpan(`publish ${normalizedExchange}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: Object.assign(Object.assign({}, channel.connection[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: options === null || options === void 0 ? void 0 : options.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: options === null || options === void 0 ? void 0 : options.correlationId }),\n        });\n        const modifiedOptions = options !== null &amp;&amp; options !== void 0 ? options : {};\n        modifiedOptions.headers = (_a = modifiedOptions.headers) !== null &amp;&amp; _a !== void 0 ? _a : {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);\n        return { span, modifiedOptions };\n    }\n    endConsumerSpan(message, isRejected, operation, requeue) {\n        const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];\n        if (!storedSpan)\n            return;\n        if (isRejected !== false) {\n            storedSpan.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: operation !== types_1.EndOperation.ChannelClosed &amp;&amp;\n                    operation !== types_1.EndOperation.ChannelError\n                    ? `${operation} called on message${requeue === true\n                        ? ' with requeue'\n                        : requeue === false\n                            ? ' without requeue'\n                            : ''}`\n                    : operation,\n            });\n        }\n        this.callConsumeEndHook(storedSpan, message, isRejected, operation);\n        storedSpan.end();\n        message[utils_1.MESSAGE_STORED_SPAN] = undefined;\n    }\n    endAllSpansOnChannel(channel, isRejected, operation, requeue) {\n        var _a;\n        const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n        spansNotEnded.forEach(msgDetails =&gt; {\n            this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);\n        });\n        channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n    }\n    callConsumeEndHook(span, msg, rejected, endOperation) {\n        const { consumeEndHook } = this.getConfig();\n        if (!consumeEndHook)\n            return;\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; consumeEndHook(span, { msg, rejected, endOperation }), e =&gt; {\n            if (e) {\n                api_1.diag.error('amqplib instrumentation: consumerEndHook error', e);\n            }\n        }, true);\n    }\n    checkConsumeTimeoutOnChannel(channel) {\n        var _a;\n        const currentTime = (0, core_1.hrTime)();\n        const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n        let i;\n        const { consumeTimeoutMs } = this.getConfig();\n        for (i = 0; i &lt; spansNotEnded.length; i++) {\n            const currMessage = spansNotEnded[i];\n            const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);\n            if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) &lt; consumeTimeoutMs) {\n                break;\n            }\n            this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);\n        }\n        spansNotEnded.splice(0, i);\n    }\n}\nexports.AmqplibInstrumentation = AmqplibInstrumentation;\n//# sourceMappingURL=amqplib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL2FtcXBsaWIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxrSUFBb0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLCtKQUFxQjtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyxnTUFBZ0M7QUFDbEUsK0JBQStCLG1CQUFPLENBQUMsc0xBQXFDO0FBQzVFLGdCQUFnQixtQkFBTyxDQUFDLHlMQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHlMQUFTO0FBQ2pDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNkxBQVc7QUFDckM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwrRkFBK0Y7QUFDL0Y7QUFDQSx5QkFBeUI7QUFDekIsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0EsOERBQThELHlKQUF5Six1ckJBQXVyQjtBQUM5NEI7QUFDQSxpQkFBaUI7QUFDakIsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQSw0RkFBNEYsb0JBQW9CO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hELHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0Esc0RBQXNELHdEQUF3RCwrZ0JBQStnQjtBQUM3bkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0EsbUZBQW1GLDZCQUE2QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9hbXFwbGliLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbXFwbGliSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuY29uc3QgaW5zdHJ1bWVudGF0aW9uXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uXCIpO1xuY29uc3Qgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKiBAa25pcGlnbm9yZSAqL1xuY29uc3QgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmNvbnN0IHN1cHBvcnRlZFZlcnNpb25zID0gWyc+PTAuNS41IDwxJ107XG5jbGFzcyBBbXFwbGliSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIodmVyc2lvbl8xLlBBQ0tBR0VfTkFNRSwgdmVyc2lvbl8xLlBBQ0tBR0VfVkVSU0lPTiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0eXBlc18xLkRFRkFVTFRfQ09ORklHKSwgY29uZmlnKSk7XG4gICAgfVxuICAgIHNldENvbmZpZyhjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlci5zZXRDb25maWcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0eXBlc18xLkRFRkFVTFRfQ09ORklHKSwgY29uZmlnKSk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxNb2RlbE1vZHVsZUZpbGUgPSBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZUZpbGUoJ2FtcXBsaWIvbGliL2NoYW5uZWxfbW9kZWwuanMnLCBzdXBwb3J0ZWRWZXJzaW9ucywgdGhpcy5wYXRjaENoYW5uZWxNb2RlbC5iaW5kKHRoaXMpLCB0aGlzLnVucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTW9kZWxNb2R1bGVGaWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVGaWxlKCdhbXFwbGliL2xpYi9jYWxsYmFja19tb2RlbC5qcycsIHN1cHBvcnRlZFZlcnNpb25zLCB0aGlzLnBhdGNoQ2hhbm5lbE1vZGVsLmJpbmQodGhpcyksIHRoaXMudW5wYXRjaENoYW5uZWxNb2RlbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3QgY29ubmVjdE1vZHVsZUZpbGUgPSBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZUZpbGUoJ2FtcXBsaWIvbGliL2Nvbm5lY3QuanMnLCBzdXBwb3J0ZWRWZXJzaW9ucywgdGhpcy5wYXRjaENvbm5lY3QuYmluZCh0aGlzKSwgdGhpcy51bnBhdGNoQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKCdhbXFwbGliJywgc3VwcG9ydGVkVmVyc2lvbnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBbY2hhbm5lbE1vZGVsTW9kdWxlRmlsZSwgY29ubmVjdE1vZHVsZUZpbGUsIGNhbGxiYWNrTW9kZWxNb2R1bGVGaWxlXSk7XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICAgIHBhdGNoQ29ubmVjdChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZUV4cG9ydHMgPSB0aGlzLnVucGF0Y2hDb25uZWN0KG1vZHVsZUV4cG9ydHMpO1xuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuY29ubmVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgJ2Nvbm5lY3QnLCB0aGlzLmdldENvbm5lY3RQYXRjaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICB9XG4gICAgdW5wYXRjaENvbm5lY3QobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5jb25uZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsICdjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgfVxuICAgIHBhdGNoQ2hhbm5lbE1vZGVsKG1vZHVsZUV4cG9ydHMsIG1vZHVsZVZlcnNpb24pIHtcbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2gpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdwdWJsaXNoJywgdGhpcy5nZXRQdWJsaXNoUGF0Y2guYmluZCh0aGlzLCBtb2R1bGVWZXJzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmNvbnN1bWUpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdjb25zdW1lJywgdGhpcy5nZXRDb25zdW1lUGF0Y2guYmluZCh0aGlzLCBtb2R1bGVWZXJzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2FjaycsIHRoaXMuZ2V0QWNrUGF0Y2guYmluZCh0aGlzLCBmYWxzZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLm5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICduYWNrJywgdGhpcy5nZXRBY2tQYXRjaC5iaW5kKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLk5hY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUucmVqZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncmVqZWN0JywgdGhpcy5nZXRBY2tQYXRjaC5iaW5kKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLlJlamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2tBbGwpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdhY2tBbGwnLCB0aGlzLmdldEFja0FsbFBhdGNoLmJpbmQodGhpcywgZmFsc2UsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkFja0FsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5uYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFja0FsbCcsIHRoaXMuZ2V0QWNrQWxsUGF0Y2guYmluZCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5OYWNrQWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmVtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdlbWl0JywgdGhpcy5nZXRDaGFubmVsRW1pdFBhdGNoLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5Db25maXJtQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5Db25maXJtQ2hhbm5lbC5wcm90b3R5cGUsICdwdWJsaXNoJywgdGhpcy5nZXRDb25maXJtZWRQdWJsaXNoUGF0Y2guYmluZCh0aGlzLCBtb2R1bGVWZXJzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgfVxuICAgIHVucGF0Y2hDaGFubmVsTW9kZWwobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdwdWJsaXNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuY29uc3VtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnY29uc3VtZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLnJlamVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncmVqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdhY2tBbGwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5uYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICduYWNrQWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuZW1pdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnZW1pdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNvbmZpcm1DaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICBnZXRDb25uZWN0UGF0Y2gob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoZWRDb25uZWN0KHVybCwgc29ja2V0T3B0aW9ucywgb3BlbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuY2FsbCh0aGlzLCB1cmwsIHNvY2tldE9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGNvbm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsQXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybCkodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHR5cGUgb2YgY29ubiBpbiBAdHlwZXMvYW1xcGxpYiBpcyBhbXFwLkNvbm5lY3Rpb24sIGJ1dCBpbiBwcmFjdGljZSB0aGUgbGlicmFyeSBzZW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBgc2VydmVyUHJvcGVydGllc2Agb24gdGhlIGBjb25uYCBhbmQgbm90IGluIGEgcHJvcGVydHkgYGNvbm5lY3Rpb25gLlxuICAgICAgICAgICAgICAgICAgICAvLyBJIGRvbid0IGhhdmUgY2FwYWNpdHkgdG8gZGVidWcgaXQgY3VycmVudGx5IGJ1dCBpdCBzaG91bGQgcHJvYmFibHkgYmUgZml4ZWQgaW4gQHR5cGVzIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBwYWNrYWdlIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50bHkgc2V0dGluZyBhcyBhbnkgdG8gY2FsbSB0eXBlc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXIpKGNvbm4pO1xuICAgICAgICAgICAgICAgICAgICBjb25uW3V0aWxzXzEuQ09OTkVDVElPTl9BVFRSSUJVVEVTXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXJsQXR0cmlidXRlcyksIHNlcnZlckF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcGVuQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDaGFubmVsRW1pdFBhdGNoKG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZW1pdChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZEFsbFNwYW5zT25DaGFubmVsKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxDbG9zZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVGltZXIgPSB0aGlzW3V0aWxzXzEuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVJdO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGFjdGl2ZVRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1t1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHNlbGYuZW5kQWxsU3BhbnNPbkNoYW5uZWwodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQ2hhbm5lbEVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEFja0FsbFBhdGNoKGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhY2tBbGwocmVxdWV1ZU9yRW1wdHkpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kQWxsU3BhbnNPbkNoYW5uZWwodGhpcywgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlT3JFbXB0eSk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0QWNrUGF0Y2goaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFjayhtZXNzYWdlLCBhbGxVcFRvT3JSZXF1ZXVlLCByZXF1ZXVlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIC8vIHdlIHVzZSB0aGlzIHBhdGNoIGluIHJlamVjdCBmdW5jdGlvbiBhcyB3ZWxsLCBidXQgaXQgaGFzIGRpZmZlcmVudCBzaWduYXR1cmVcbiAgICAgICAgICAgIGNvbnN0IHJlcXVldWVSZXNvbHZlZCA9IGVuZE9wZXJhdGlvbiA9PT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uUmVqZWN0ID8gYWxsVXBUb09yUmVxdWV1ZSA6IHJlcXVldWU7XG4gICAgICAgICAgICBjb25zdCBzcGFuc05vdEVuZGVkID0gKF9hID0gY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICBjb25zdCBtc2dJbmRleCA9IHNwYW5zTm90RW5kZWQuZmluZEluZGV4KG1zZ0RldGFpbHMgPT4gbXNnRGV0YWlscy5tc2cgPT09IG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG1zZ0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuIGluIGhhcHB5IGZsb3dcbiAgICAgICAgICAgICAgICAvLyBidXQgcG9zc2libGUgaWYgdXNlciBpcyBjYWxsaW5nIHRoZSBhcGkgZnVuY3Rpb24gYWNrIHR3aWNlIHdpdGggc2FtZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgc2VsZi5lbmRDb25zdW1lclNwYW4obWVzc2FnZSwgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlUmVzb2x2ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kT3BlcmF0aW9uICE9PSB0eXBlc18xLkVuZE9wZXJhdGlvbi5SZWplY3QgJiYgYWxsVXBUb09yUmVxdWV1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1zZ0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmRDb25zdW1lclNwYW4oc3BhbnNOb3RFbmRlZFtpXS5tc2csIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZVJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BhbnNOb3RFbmRlZC5zcGxpY2UoMCwgbXNnSW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZW5kQ29uc3VtZXJTcGFuKG1lc3NhZ2UsIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZVJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICBzcGFuc05vdEVuZGVkLnNwbGljZShtc2dJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q29uc3VtZVBhdGNoKG1vZHVsZVZlcnNpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uc3VtZShxdWV1ZSwgb25NZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoYW5uZWwsIHV0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25zdW1lVGltZW91dE1zIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lVGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaGVja0NvbnN1bWVUaW1lb3V0T25DaGFubmVsKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICB9LCBjb25zdW1lVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXSA9IHRpbWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaGVkT25NZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgLy8gbXNnIGlzIGV4cGVjdGVkIHRvIGJlIG51bGwgZm9yIHNpZ25hbGluZyBjb25zdW1lciBjYW5jZWwgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmFiYml0bXEuY29tL2NvbnN1bWVyLWNhbmNlbC5odG1sXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlLCB3ZSBkbyBub3Qgc3RhcnQgYSBzcGFuLCBhcyB0aGlzIGlzIG5vdCBhIHJlYWwgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICBpZiAoIW1zZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25NZXNzYWdlLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IChfYSA9IG1zZy5wcm9wZXJ0aWVzLmhlYWRlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRDb250ZXh0ID0gYXBpXzEucHJvcGFnYXRpb24uZXh0cmFjdChhcGlfMS5ST09UX0NPTlRFWFQsIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2hhbmdlID0gKF9iID0gbXNnLmZpZWxkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4Y2hhbmdlO1xuICAgICAgICAgICAgICAgIGxldCBsaW5rcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fY29uZmlnLnVzZUxpbmtzRm9yQ29uc3VtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRTcGFuQ29udGV4dCA9IHBhcmVudENvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9jID0gYXBpXzEudHJhY2UuZ2V0U3BhbihwYXJlbnRDb250ZXh0KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwYW5Db250ZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50U3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogcGFyZW50U3BhbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHNlbGYudHJhY2VyLnN0YXJ0U3BhbihgJHtxdWV1ZX0gcHJvY2Vzc2AsIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuQ09OU1VNRVIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9kID0gY2hhbm5lbCA9PT0gbnVsbCB8fCBjaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVsLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFt1dGlsc18xLkNPTk5FQ1RJT05fQVRUUklCVVRFU10pLCB7IFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19ERVNUSU5BVElPTl06IGV4Y2hhbmdlLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05fS0lORF06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1RPUElDLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVldOiAoX2UgPSBtc2cuZmllbGRzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uucm91dGluZ0tleSwgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX09QRVJBVElPTl06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVTU0FHSU5HT1BFUkFUSU9OVkFMVUVTX1BST0NFU1MsIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19NRVNTQUdFX0lEXTogbXNnID09PSBudWxsIHx8IG1zZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXNnLnByb3BlcnRpZXMubWVzc2FnZUlkLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfQ09OVkVSU0FUSU9OX0lEXTogbXNnID09PSBudWxsIHx8IG1zZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXNnLnByb3BlcnRpZXMuY29ycmVsYXRpb25JZCB9KSxcbiAgICAgICAgICAgICAgICAgICAgbGlua3MsXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25zdW1lSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbnN1bWVIb29rKHNwYW4sIHsgbW9kdWxlVmVyc2lvbiwgbXNnIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGNvbnN1bWVySG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vQWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgbWVzc2FnZSBvbiB0aGUgY2hhbm5lbCBzbyB3ZSBjYW4gY2xvc2UgdGhlIHNwYW4gb24gYWNrQWxsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9mQ29uc3VtZTogKDAsIGNvcmVfMS5oclRpbWUpKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgc3BhbiBvbiB0aGUgbWVzc2FnZSwgc28gd2UgY2FuIGVuZCBpdCB3aGVuIHVzZXIgY2FsbCAnYWNrJyBvbiBpdFxuICAgICAgICAgICAgICAgICAgICBtc2dbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXSA9IHNwYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNldENvbnRleHQgPSBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgID8gcGFyZW50Q29udGV4dFxuICAgICAgICAgICAgICAgICAgICA6IGFwaV8xLlJPT1RfQ09OVEVYVDtcbiAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LndpdGgoYXBpXzEudHJhY2Uuc2V0U3BhbihzZXRDb250ZXh0LCBzcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2UuY2FsbCh0aGlzLCBtc2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9BY2spIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxsQ29uc3VtZUVuZEhvb2soc3BhbiwgbXNnLCBmYWxzZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQXV0b0Fjayk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFyZ3VtZW50c1sxXSA9IHBhdGNoZWRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q29uZmlybWVkUHVibGlzaFBhdGNoKG1vZHVsZVZlcnNpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uZmlybWVkUHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBzcGFuLCBtb2RpZmllZE9wdGlvbnMgfSA9IHNlbGYuY3JlYXRlUHVibGlzaFNwYW4oc2VsZiwgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNoYW5uZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyBwdWJsaXNoSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgIGlmIChwdWJsaXNoSG9vaykge1xuICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwdWJsaXNoSG9vayhzcGFuLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZVZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICByb3V0aW5nS2V5LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBtb2RpZmllZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGlzQ29uZmlybUNoYW5uZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IHB1Ymxpc2hIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRPbkNvbmZpcm0gPSBmdW5jdGlvbiAoZXJyLCBvaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjay5jYWxsKHRoaXMsIGVyciwgb2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwdWJsaXNoQ29uZmlybUhvb2sgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoQ29uZmlybUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwdWJsaXNoQ29uZmlybUhvb2soc3Bhbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZVZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25maXJtQ2hhbm5lbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogcHVibGlzaENvbmZpcm1Ib29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZSBjb25maXJtYXRpb24gaGFzIGJlZW4gbmFjaydlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2FsbGluZyBjb25maXJtIGNoYW5uZWwgcHVibGlzaCBmdW5jdGlvbiBpcyBzdG9yaW5nIHRoZSBtZXNzYWdlIGluIHF1ZXVlIGFuZCByZWdpc3RlcmluZyB0aGUgY2FsbGJhY2sgZm9yIGJyb2tlciBjb25maXJtLlxuICAgICAgICAgICAgLy8gc3BhbiBlbmRzIGluIHRoZSBwYXRjaGVkIGNhbGxiYWNrLlxuICAgICAgICAgICAgY29uc3QgbWFya2VkQ29udGV4dCA9ICgwLCB1dGlsc18xLm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcpKGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpO1xuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzQ29weSA9IFsuLi5hcmd1bWVudHNdO1xuICAgICAgICAgICAgYXJndW1lbnRzQ29weVszXSA9IG1vZGlmaWVkT3B0aW9ucztcbiAgICAgICAgICAgIGFyZ3VtZW50c0NvcHlbNF0gPSBhcGlfMS5jb250ZXh0LmJpbmQoKDAsIHV0aWxzXzEudW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nKShhcGlfMS50cmFjZS5zZXRTcGFuKG1hcmtlZENvbnRleHQsIHNwYW4pKSwgcGF0Y2hlZE9uQ29uZmlybSk7XG4gICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKG1hcmtlZENvbnRleHQsIG9yaWdpbmFsLmJpbmQodGhpcywgLi4uYXJndW1lbnRzQ29weSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRQdWJsaXNoUGF0Y2gobW9kdWxlVmVyc2lvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwdWJsaXNoKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNDb25maXJtQ2hhbm5lbFRyYWNpbmcpKGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gd29yayBhbHJlYWR5IGRvbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3BhbiwgbW9kaWZpZWRPcHRpb25zIH0gPSBzZWxmLmNyZWF0ZVB1Ymxpc2hTcGFuKHNlbGYsIGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjaGFubmVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHB1Ymxpc2hIb29rIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gcHVibGlzaEhvb2soc3Bhbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBtb2RpZmllZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbmZpcm1DaGFubmVsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogcHVibGlzaEhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNhbGxpbmcgbm9ybWFsIGNoYW5uZWwgcHVibGlzaCBmdW5jdGlvbiBpcyBvbmx5IHN0b3JpbmcgdGhlIG1lc3NhZ2UgaW4gcXVldWUuXG4gICAgICAgICAgICAgICAgLy8gaXQgZG9lcyBub3Qgc2VuZCBpdCBhbmQgd2FpdHMgZm9yIGFuIGFjaywgc28gdGhlIHNwYW4gZHVyYXRpb24gaXMgZXhwZWN0ZWQgdG8gYmUgdmVyeSBzaG9ydC5cbiAgICAgICAgICAgICAgICBjb25zdCBhcmd1bWVudHNDb3B5ID0gWy4uLmFyZ3VtZW50c107XG4gICAgICAgICAgICAgICAgYXJndW1lbnRzQ29weVszXSA9IG1vZGlmaWVkT3B0aW9ucztcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFJlcyA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50c0NvcHkpO1xuICAgICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVQdWJsaXNoU3BhbihzZWxmLCBleGNoYW5nZSwgcm91dGluZ0tleSwgY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFeGNoYW5nZSA9ICgwLCB1dGlsc18xLm5vcm1hbGl6ZUV4Y2hhbmdlKShleGNoYW5nZSk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzZWxmLnRyYWNlci5zdGFydFNwYW4oYHB1Ymxpc2ggJHtub3JtYWxpemVkRXhjaGFuZ2V9YCwge1xuICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuUFJPRFVDRVIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYW5uZWwuY29ubmVjdGlvblt1dGlsc18xLkNPTk5FQ1RJT05fQVRUUklCVVRFU10pLCB7IFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19ERVNUSU5BVElPTl06IGV4Y2hhbmdlLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05fS0lORF06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1RPUElDLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVldOiByb3V0aW5nS2V5LCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9JRF06IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlSWQsIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19DT05WRVJTQVRJT05fSURdOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29ycmVsYXRpb25JZCB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICBtb2RpZmllZE9wdGlvbnMuaGVhZGVycyA9IChfYSA9IG1vZGlmaWVkT3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgc3BhbiksIG1vZGlmaWVkT3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHsgc3BhbiwgbW9kaWZpZWRPcHRpb25zIH07XG4gICAgfVxuICAgIGVuZENvbnN1bWVyU3BhbihtZXNzYWdlLCBpc1JlamVjdGVkLCBvcGVyYXRpb24sIHJlcXVldWUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkU3BhbiA9IG1lc3NhZ2VbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXTtcbiAgICAgICAgaWYgKCFzdG9yZWRTcGFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXNSZWplY3RlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0b3JlZFNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcGVyYXRpb24gIT09IHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxDbG9zZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uICE9PSB0eXBlc18xLkVuZE9wZXJhdGlvbi5DaGFubmVsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtvcGVyYXRpb259IGNhbGxlZCBvbiBtZXNzYWdlJHtyZXF1ZXVlID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcgd2l0aCByZXF1ZXVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXF1ZXVlID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJyB3aXRob3V0IHJlcXVldWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJ31gXG4gICAgICAgICAgICAgICAgICAgIDogb3BlcmF0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsQ29uc3VtZUVuZEhvb2soc3RvcmVkU3BhbiwgbWVzc2FnZSwgaXNSZWplY3RlZCwgb3BlcmF0aW9uKTtcbiAgICAgICAgc3RvcmVkU3Bhbi5lbmQoKTtcbiAgICAgICAgbWVzc2FnZVt1dGlsc18xLk1FU1NBR0VfU1RPUkVEX1NQQU5dID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmRBbGxTcGFuc09uQ2hhbm5lbChjaGFubmVsLCBpc1JlamVjdGVkLCBvcGVyYXRpb24sIHJlcXVldWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzcGFuc05vdEVuZGVkID0gKF9hID0gY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIHNwYW5zTm90RW5kZWQuZm9yRWFjaChtc2dEZXRhaWxzID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29uc3VtZXJTcGFuKG1zZ0RldGFpbHMubXNnLCBpc1JlamVjdGVkLCBvcGVyYXRpb24sIHJlcXVldWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSA9IFtdO1xuICAgIH1cbiAgICBjYWxsQ29uc3VtZUVuZEhvb2soc3BhbiwgbXNnLCByZWplY3RlZCwgZW5kT3BlcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgY29uc3VtZUVuZEhvb2sgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmICghY29uc3VtZUVuZEhvb2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25zdW1lRW5kSG9vayhzcGFuLCB7IG1zZywgcmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiB9KSwgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBjb25zdW1lckVuZEhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNoZWNrQ29uc3VtZVRpbWVvdXRPbkNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKDAsIGNvcmVfMS5oclRpbWUpKCk7XG4gICAgICAgIGNvbnN0IHNwYW5zTm90RW5kZWQgPSAoX2EgPSBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IHsgY29uc3VtZVRpbWVvdXRNcyB9ID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYW5zTm90RW5kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJNZXNzYWdlID0gc3BhbnNOb3RFbmRlZFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVGcm9tQ29uc3VtZSA9ICgwLCBjb3JlXzEuaHJUaW1lRHVyYXRpb24pKGN1cnJNZXNzYWdlLnRpbWVPZkNvbnN1bWUsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGlmICgoMCwgY29yZV8xLmhyVGltZVRvTWlsbGlzZWNvbmRzKSh0aW1lRnJvbUNvbnN1bWUpIDwgY29uc3VtZVRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbmRDb25zdW1lclNwYW4oY3Vyck1lc3NhZ2UubXNnLCBudWxsLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5JbnN0cnVtZW50YXRpb25UaW1lb3V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFuc05vdEVuZGVkLnNwbGljZSgwLCBpKTtcbiAgICB9XG59XG5leHBvcnRzLkFtcXBsaWJJbnN0cnVtZW50YXRpb24gPSBBbXFwbGliSW5zdHJ1bWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1xcGxpYi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ (function(__unused_webpack_module, exports, __webpack_require__) {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nvar __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this &amp;&amp; this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" &amp;&amp; !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n__exportStar(__webpack_require__(/*! ./amqplib */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNkxBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLHlMQUFTO0FBQzlCIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hbXFwbGliXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CONFIG = exports.EndOperation = void 0;\nvar EndOperation;\n(function (EndOperation) {\n    EndOperation[\"AutoAck\"] = \"auto ack\";\n    EndOperation[\"Ack\"] = \"ack\";\n    EndOperation[\"AckAll\"] = \"ackAll\";\n    EndOperation[\"Reject\"] = \"reject\";\n    EndOperation[\"Nack\"] = \"nack\";\n    EndOperation[\"NackAll\"] = \"nackAll\";\n    EndOperation[\"ChannelClosed\"] = \"channel closed\";\n    EndOperation[\"ChannelError\"] = \"channel error\";\n    EndOperation[\"InstrumentationTimeout\"] = \"instrumentation timeout\";\n})(EndOperation = exports.EndOperation || (exports.EndOperation = {}));\nexports.DEFAULT_CONFIG = {\n    consumeTimeoutMs: 1000 * 60,\n    useLinksForConsume: false,\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEMsb0JBQW9CLEtBQUs7QUFDcEUsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9DT05GSUcgPSBleHBvcnRzLkVuZE9wZXJhdGlvbiA9IHZvaWQgMDtcbnZhciBFbmRPcGVyYXRpb247XG4oZnVuY3Rpb24gKEVuZE9wZXJhdGlvbikge1xuICAgIEVuZE9wZXJhdGlvbltcIkF1dG9BY2tcIl0gPSBcImF1dG8gYWNrXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQWNrXCJdID0gXCJhY2tcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJBY2tBbGxcIl0gPSBcImFja0FsbFwiO1xuICAgIEVuZE9wZXJhdGlvbltcIlJlamVjdFwiXSA9IFwicmVqZWN0XCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiTmFja1wiXSA9IFwibmFja1wiO1xuICAgIEVuZE9wZXJhdGlvbltcIk5hY2tBbGxcIl0gPSBcIm5hY2tBbGxcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJDaGFubmVsQ2xvc2VkXCJdID0gXCJjaGFubmVsIGNsb3NlZFwiO1xuICAgIEVuZE9wZXJhdGlvbltcIkNoYW5uZWxFcnJvclwiXSA9IFwiY2hhbm5lbCBlcnJvclwiO1xuICAgIEVuZE9wZXJhdGlvbltcIkluc3RydW1lbnRhdGlvblRpbWVvdXRcIl0gPSBcImluc3RydW1lbnRhdGlvbiB0aW1lb3V0XCI7XG59KShFbmRPcGVyYXRpb24gPSBleHBvcnRzLkVuZE9wZXJhdGlvbiB8fCAoZXhwb3J0cy5FbmRPcGVyYXRpb24gPSB7fSkpO1xuZXhwb3J0cy5ERUZBVUxUX0NPTkZJRyA9IHtcbiAgICBjb25zdW1lVGltZW91dE1zOiAxMDAwICogNjAsXG4gICAgdXNlTGlua3NGb3JDb25zdW1lOiBmYWxzZSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isConfirmChannelTracing = exports.unmarkConfirmChannelTracing = exports.markConfirmChannelTracing = exports.getConnectionAttributesFromUrl = exports.getConnectionAttributesFromServer = exports.normalizeExchange = exports.CONNECTION_ATTRIBUTES = exports.CHANNEL_CONSUME_TIMEOUT_TIMER = exports.CHANNEL_SPANS_NOT_ENDED = exports.MESSAGE_STORED_SPAN = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.36.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nexports.MESSAGE_STORED_SPAN = Symbol('opentelemetry.amqplib.message.stored-span');\nexports.CHANNEL_SPANS_NOT_ENDED = Symbol('opentelemetry.amqplib.channel.spans-not-ended');\nexports.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol('opentelemetry.amqplib.channel.consumer-timeout-timer');\nexports.CONNECTION_ATTRIBUTES = Symbol('opentelemetry.amqplib.connection.attributes');\nconst IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)('opentelemetry.amqplib.channel.is-confirm-channel');\nconst normalizeExchange = (exchangeName) =&gt; exchangeName !== '' ? exchangeName : '&lt;default&gt;';\nexports.normalizeExchange = normalizeExchange;\nconst censorPassword = (url) =&gt; {\n    return url.replace(/:[^:@/]*@/, ':***@');\n};\nconst getPort = (portFromUrl, resolvedProtocol) =&gt; {\n    // we are using the resolved protocol which is upper case\n    // this code mimic the behavior of the amqplib which is used to set connection params\n    return portFromUrl || (resolvedProtocol === 'AMQP' ? 5672 : 5671);\n};\nconst getProtocol = (protocolFromUrl) =&gt; {\n    const resolvedProtocol = protocolFromUrl || 'amqp';\n    // the substring removed the ':' part of the protocol ('amqp:' -&gt; 'amqp')\n    const noEndingColon = resolvedProtocol.endsWith(':')\n        ? resolvedProtocol.substring(0, resolvedProtocol.length - 1)\n        : resolvedProtocol;\n    // upper cases to match spec\n    return noEndingColon.toUpperCase();\n};\nconst getHostname = (hostnameFromUrl) =&gt; {\n    // if user supplies empty hostname, it gets forwarded to 'net' package which default it to localhost.\n    // https://nodejs.org/docs/latest-v12.x/api/net.html#net_socket_connect_options_connectlistener\n    return hostnameFromUrl || 'localhost';\n};\nconst extractConnectionAttributeOrLog = (url, attributeKey, attributeValue, nameForLog) =&gt; {\n    if (attributeValue) {\n        return { [attributeKey]: attributeValue };\n    }\n    else {\n        api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {\n            url,\n        });\n        return {};\n    }\n};\nconst getConnectionAttributesFromServer = (conn) =&gt; {\n    var _a, _b;\n    const product = (_b = (_a = conn.serverProperties.product) === null || _a === void 0 ? void 0 : _a.toLowerCase) === null || _b === void 0 ? void 0 : _b.call(_a);\n    if (product) {\n        return {\n            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: product,\n        };\n    }\n    else {\n        return {};\n    }\n};\nexports.getConnectionAttributesFromServer = getConnectionAttributesFromServer;\nconst getConnectionAttributesFromUrl = (url) =&gt; {\n    const attributes = {\n        [semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL_VERSION]: '0.9.1', // this is the only protocol supported by the instrumented library\n    };\n    url = url || 'amqp://localhost';\n    if (typeof url === 'object') {\n        const connectOptions = url;\n        const protocol = getProtocol(connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.protocol);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, 'protocol')));\n        const hostname = getHostname(connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.hostname);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, 'hostname')));\n        const port = getPort(connectOptions.port, protocol);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, 'port')));\n    }\n    else {\n        const censoredUrl = censorPassword(url);\n        attributes[semantic_conventions_1.SEMATTRS_MESSAGING_URL] = censoredUrl;\n        try {\n            const urlParts = new URL(censoredUrl);\n            const protocol = getProtocol(urlParts.protocol);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, 'protocol')));\n            const hostname = getHostname(urlParts.hostname);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, 'hostname')));\n            const port = getPort(urlParts.port ? parseInt(urlParts.port) : undefined, protocol);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, 'port')));\n        }\n        catch (err) {\n            api_1.diag.error('amqplib instrumentation: error while extracting connection details from connection url', {\n                censoredUrl,\n                err,\n            });\n        }\n    }\n    return attributes;\n};\nexports.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;\nconst markConfirmChannelTracing = (context) =&gt; {\n    return context.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);\n};\nexports.markConfirmChannelTracing = markConfirmChannelTracing;\nconst unmarkConfirmChannelTracing = (context) =&gt; {\n    return context.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);\n};\nexports.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;\nconst isConfirmChannelTracing = (context) =&gt; {\n    return context.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;\n};\nexports.isConfirmChannelTracing = isConfirmChannelTracing;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxHQUFHLHNDQUFzQyxHQUFHLHlDQUF5QyxHQUFHLHlCQUF5QixHQUFHLDZCQUE2QixHQUFHLHFDQUFxQyxHQUFHLCtCQUErQixHQUFHLDJCQUEyQjtBQUNsVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsa0lBQW9CO0FBQzFDLCtCQUErQixtQkFBTyxDQUFDLHNMQUFxQztBQUM1RSwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDRGQUE0RixZQUFZO0FBQ3hHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IGV4cG9ydHMudW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gZXhwb3J0cy5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gZXhwb3J0cy5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwgPSBleHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IGV4cG9ydHMubm9ybWFsaXplRXhjaGFuZ2UgPSBleHBvcnRzLkNPTk5FQ1RJT05fQVRUUklCVVRFUyA9IGV4cG9ydHMuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVIgPSBleHBvcnRzLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEID0gZXhwb3J0cy5NRVNTQUdFX1NUT1JFRF9TUEFOID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNcIik7XG5leHBvcnRzLk1FU1NBR0VfU1RPUkVEX1NQQU4gPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5tZXNzYWdlLnN0b3JlZC1zcGFuJyk7XG5leHBvcnRzLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIuY2hhbm5lbC5zcGFucy1ub3QtZW5kZWQnKTtcbmV4cG9ydHMuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVIgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jaGFubmVsLmNvbnN1bWVyLXRpbWVvdXQtdGltZXInKTtcbmV4cG9ydHMuQ09OTkVDVElPTl9BVFRSSUJVVEVTID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIuY29ubmVjdGlvbi5hdHRyaWJ1dGVzJyk7XG5jb25zdCBJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVkgPSAoMCwgYXBpXzEuY3JlYXRlQ29udGV4dEtleSkoJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jaGFubmVsLmlzLWNvbmZpcm0tY2hhbm5lbCcpO1xuY29uc3Qgbm9ybWFsaXplRXhjaGFuZ2UgPSAoZXhjaGFuZ2VOYW1lKSA9PiBleGNoYW5nZU5hbWUgIT09ICcnID8gZXhjaGFuZ2VOYW1lIDogJzxkZWZhdWx0Pic7XG5leHBvcnRzLm5vcm1hbGl6ZUV4Y2hhbmdlID0gbm9ybWFsaXplRXhjaGFuZ2U7XG5jb25zdCBjZW5zb3JQYXNzd29yZCA9ICh1cmwpID0+IHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLzpbXjpAL10qQC8sICc6KioqQCcpO1xufTtcbmNvbnN0IGdldFBvcnQgPSAocG9ydEZyb21VcmwsIHJlc29sdmVkUHJvdG9jb2wpID0+IHtcbiAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlIHJlc29sdmVkIHByb3RvY29sIHdoaWNoIGlzIHVwcGVyIGNhc2VcbiAgICAvLyB0aGlzIGNvZGUgbWltaWMgdGhlIGJlaGF2aW9yIG9mIHRoZSBhbXFwbGliIHdoaWNoIGlzIHVzZWQgdG8gc2V0IGNvbm5lY3Rpb24gcGFyYW1zXG4gICAgcmV0dXJuIHBvcnRGcm9tVXJsIHx8IChyZXNvbHZlZFByb3RvY29sID09PSAnQU1RUCcgPyA1NjcyIDogNTY3MSk7XG59O1xuY29uc3QgZ2V0UHJvdG9jb2wgPSAocHJvdG9jb2xGcm9tVXJsKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRQcm90b2NvbCA9IHByb3RvY29sRnJvbVVybCB8fCAnYW1xcCc7XG4gICAgLy8gdGhlIHN1YnN0cmluZyByZW1vdmVkIHRoZSAnOicgcGFydCBvZiB0aGUgcHJvdG9jb2wgKCdhbXFwOicgLT4gJ2FtcXAnKVxuICAgIGNvbnN0IG5vRW5kaW5nQ29sb24gPSByZXNvbHZlZFByb3RvY29sLmVuZHNXaXRoKCc6JylcbiAgICAgICAgPyByZXNvbHZlZFByb3RvY29sLnN1YnN0cmluZygwLCByZXNvbHZlZFByb3RvY29sLmxlbmd0aCAtIDEpXG4gICAgICAgIDogcmVzb2x2ZWRQcm90b2NvbDtcbiAgICAvLyB1cHBlciBjYXNlcyB0byBtYXRjaCBzcGVjXG4gICAgcmV0dXJuIG5vRW5kaW5nQ29sb24udG9VcHBlckNhc2UoKTtcbn07XG5jb25zdCBnZXRIb3N0bmFtZSA9IChob3N0bmFtZUZyb21VcmwpID0+IHtcbiAgICAvLyBpZiB1c2VyIHN1cHBsaWVzIGVtcHR5IGhvc3RuYW1lLCBpdCBnZXRzIGZvcndhcmRlZCB0byAnbmV0JyBwYWNrYWdlIHdoaWNoIGRlZmF1bHQgaXQgdG8gbG9jYWxob3N0LlxuICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC12MTIueC9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9jb25uZWN0X29wdGlvbnNfY29ubmVjdGxpc3RlbmVyXG4gICAgcmV0dXJuIGhvc3RuYW1lRnJvbVVybCB8fCAnbG9jYWxob3N0Jztcbn07XG5jb25zdCBleHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nID0gKHVybCwgYXR0cmlidXRlS2V5LCBhdHRyaWJ1dGVWYWx1ZSwgbmFtZUZvckxvZykgPT4ge1xuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4geyBbYXR0cmlidXRlS2V5XTogYXR0cmlidXRlVmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoYGFtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBjb3VsZCBub3QgZXh0cmFjdCBjb25uZWN0aW9uIGF0dHJpYnV0ZSAke25hbWVGb3JMb2d9IGZyb20gdXNlciBzdXBwbGllZCB1cmxgLCB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufTtcbmNvbnN0IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IChjb25uKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwcm9kdWN0ID0gKF9iID0gKF9hID0gY29ubi5zZXJ2ZXJQcm9wZXJ0aWVzLnByb2R1Y3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfU1lTVEVNXTogcHJvZHVjdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59O1xuZXhwb3J0cy5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXIgPSBnZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXI7XG5jb25zdCBnZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwgPSAodXJsKSA9PiB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT05dOiAnMC45LjEnLCAvLyB0aGlzIGlzIHRoZSBvbmx5IHByb3RvY29sIHN1cHBvcnRlZCBieSB0aGUgaW5zdHJ1bWVudGVkIGxpYnJhcnlcbiAgICB9O1xuICAgIHVybCA9IHVybCB8fCAnYW1xcDovL2xvY2FsaG9zdCc7XG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RPcHRpb25zID0gdXJsO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGdldFByb3RvY29sKGNvbm5lY3RPcHRpb25zID09PSBudWxsIHx8IGNvbm5lY3RPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0T3B0aW9ucy5wcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MLCBwcm90b2NvbCwgJ3Byb3RvY29sJykpKTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZShjb25uZWN0T3B0aW9ucyA9PT0gbnVsbCB8fCBjb25uZWN0T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdE9wdGlvbnMuaG9zdG5hbWUpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24oe30sIGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2codXJsLCBzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX05BTUUsIGhvc3RuYW1lLCAnaG9zdG5hbWUnKSkpO1xuICAgICAgICBjb25zdCBwb3J0ID0gZ2V0UG9ydChjb25uZWN0T3B0aW9ucy5wb3J0LCBwcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVCwgcG9ydCwgJ3BvcnQnKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY2Vuc29yZWRVcmwgPSBjZW5zb3JQYXNzd29yZCh1cmwpO1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1VSTF0gPSBjZW5zb3JlZFVybDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybFBhcnRzID0gbmV3IFVSTChjZW5zb3JlZFVybCk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IGdldFByb3RvY29sKHVybFBhcnRzLnByb3RvY29sKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyhjZW5zb3JlZFVybCwgc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUFJPVE9DT0wsIHByb3RvY29sLCAncHJvdG9jb2wnKSkpO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZSh1cmxQYXJ0cy5ob3N0bmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24oe30sIGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2coY2Vuc29yZWRVcmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfTkFNRSwgaG9zdG5hbWUsICdob3N0bmFtZScpKSk7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gZ2V0UG9ydCh1cmxQYXJ0cy5wb3J0ID8gcGFyc2VJbnQodXJsUGFydHMucG9ydCkgOiB1bmRlZmluZWQsIHByb3RvY29sKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyhjZW5zb3JlZFVybCwgc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9QT1JULCBwb3J0LCAncG9ydCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGVycm9yIHdoaWxlIGV4dHJhY3RpbmcgY29ubmVjdGlvbiBkZXRhaWxzIGZyb20gY29ubmVjdGlvbiB1cmwnLCB7XG4gICAgICAgICAgICAgICAgY2Vuc29yZWRVcmwsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwgPSBnZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21Vcmw7XG5jb25zdCBtYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gY29udGV4dC5zZXRWYWx1ZShJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVksIHRydWUpO1xufTtcbmV4cG9ydHMubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IG1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmc7XG5jb25zdCB1bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSAoY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBjb250ZXh0LmRlbGV0ZVZhbHVlKElTX0NPTkZJUk1fQ0hBTk5FTF9DT05URVhUX0tFWSk7XG59O1xuZXhwb3J0cy51bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSB1bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmc7XG5jb25zdCBpc0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0VmFsdWUoSVNfQ09ORklSTV9DSEFOTkVMX0NPTlRFWFRfS0VZKSA9PT0gdHJ1ZTtcbn07XG5leHBvcnRzLmlzQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gaXNDb25maXJtQ2hhbm5lbFRyYWNpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js":</span>
<span class="cstat-no" title="statement not covered" >/*!****************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \****************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.46.1';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-amqplib';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsdUJBQXVCO0FBQzlDO0FBQ0EsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjQ2LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9IGV4cG9ydHMuUEFDS0FHRV9WRVJTSU9OID0gdm9pZCAwO1xuLy8gdGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUsIHNlZSBzY3JpcHRzL3ZlcnNpb24tdXBkYXRlLmpzXG5leHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9ICcwLjQ2LjEnO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSAnQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js":</span>
<span class="cstat-no" title="statement not covered" >/*!****************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \****************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.36.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\");\nconst supportedVersions = ['&gt;=0.5.5 &lt;1'];\nclass AmqplibInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config));\n    }\n    setConfig(config = {}) {\n        super.setConfig(Object.assign(Object.assign({}, types_1.DEFAULT_CONFIG), config));\n    }\n    init() {\n        const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/channel_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/callback_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/connect.js', supportedVersions, this.patchConnect.bind(this), this.unpatchConnect.bind(this));\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('amqplib', supportedVersions, undefined, undefined, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);\n        return module;\n    }\n    patchConnect(moduleExports) {\n        moduleExports = this.unpatchConnect(moduleExports);\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._wrap(moduleExports, 'connect', this.getConnectPatch.bind(this));\n        }\n        return moduleExports;\n    }\n    unpatchConnect(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._unwrap(moduleExports, 'connect');\n        }\n        return moduleExports;\n    }\n    patchChannelModel(moduleExports, moduleVersion) {\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._wrap(moduleExports.Channel.prototype, 'publish', this.getPublishPatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._wrap(moduleExports.Channel.prototype, 'consume', this.getConsumePatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._wrap(moduleExports.Channel.prototype, 'ack', this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._wrap(moduleExports.Channel.prototype, 'nack', this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._wrap(moduleExports.Channel.prototype, 'reject', this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'ackAll', this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'nackAll', this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._wrap(moduleExports.Channel.prototype, 'emit', this.getChannelEmitPatch.bind(this));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._wrap(moduleExports.ConfirmChannel.prototype, 'publish', this.getConfirmedPublishPatch.bind(this, moduleVersion));\n        }\n        return moduleExports;\n    }\n    unpatchChannelModel(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._unwrap(moduleExports.Channel.prototype, 'publish');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._unwrap(moduleExports.Channel.prototype, 'consume');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._unwrap(moduleExports.Channel.prototype, 'reject');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._unwrap(moduleExports.Channel.prototype, 'emit');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._unwrap(moduleExports.ConfirmChannel.prototype, 'publish');\n        }\n        return moduleExports;\n    }\n    getConnectPatch(original) {\n        return function patchedConnect(url, socketOptions, openCallback) {\n            return original.call(this, url, socketOptions, function (err, conn) {\n                if (err == null) {\n                    const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url);\n                    // the type of conn in @types/amqplib is amqp.Connection, but in practice the library send the\n                    // `serverProperties` on the `conn` and not in a property `connection`.\n                    // I don't have capacity to debug it currently but it should probably be fixed in @types or\n                    // in the package itself\n                    // currently setting as any to calm typescript\n                    const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);\n                    conn[utils_1.CONNECTION_ATTRIBUTES] = Object.assign(Object.assign({}, urlAttributes), serverAttributes);\n                }\n                openCallback.apply(this, arguments);\n            });\n        };\n    }\n    getChannelEmitPatch(original) {\n        const self = this;\n        return function emit(eventName) {\n            if (eventName === 'close') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, undefined);\n                const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];\n                if (activeTimer) {\n                    clearInterval(activeTimer);\n                }\n                this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = undefined;\n            }\n            else if (eventName === 'error') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, undefined);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getAckAllPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ackAll(requeueOrEmpty) {\n            self.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);\n            return original.apply(this, arguments);\n        };\n    }\n    getAckPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ack(message, allUpToOrRequeue, requeue) {\n            var _a;\n            const channel = this;\n            // we use this patch in reject function as well, but it has different signature\n            const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;\n            const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n            const msgIndex = spansNotEnded.findIndex(msgDetails =&gt; msgDetails.msg === message);\n            if (msgIndex &lt; 0) {\n                // should not happen in happy flow\n                // but possible if user is calling the api function ack twice with same message\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n            }\n            else if (endOperation !== types_1.EndOperation.Reject &amp;&amp; allUpToOrRequeue) {\n                for (let i = 0; i &lt;= msgIndex; i++) {\n                    self.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);\n                }\n                spansNotEnded.splice(0, msgIndex + 1);\n            }\n            else {\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n                spansNotEnded.splice(msgIndex, 1);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getConsumePatch(moduleVersion, original) {\n        const self = this;\n        return function consume(queue, onMessage, options) {\n            const channel = this;\n            if (!Object.prototype.hasOwnProperty.call(channel, utils_1.CHANNEL_SPANS_NOT_ENDED)) {\n                const { consumeTimeoutMs } = self.getConfig();\n                if (consumeTimeoutMs) {\n                    const timer = setInterval(() =&gt; {\n                        self.checkConsumeTimeoutOnChannel(channel);\n                    }, consumeTimeoutMs);\n                    timer.unref();\n                    channel[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;\n                }\n                channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n            }\n            const patchedOnMessage = function (msg) {\n                var _a, _b, _c, _d, _e;\n                // msg is expected to be null for signaling consumer cancel notification\n                // https://www.rabbitmq.com/consumer-cancel.html\n                // in this case, we do not start a span, as this is not a real message.\n                if (!msg) {\n                    return onMessage.call(this, msg);\n                }\n                const headers = (_a = msg.properties.headers) !== null &amp;&amp; _a !== void 0 ? _a : {};\n                let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n                const exchange = (_b = msg.fields) === null || _b === void 0 ? void 0 : _b.exchange;\n                let links;\n                if (self._config.useLinksForConsume) {\n                    const parentSpanContext = parentContext\n                        ? (_c = api_1.trace.getSpan(parentContext)) === null || _c === void 0 ? void 0 : _c.spanContext()\n                        : undefined;\n                    parentContext = undefined;\n                    if (parentSpanContext) {\n                        links = [\n                            {\n                                context: parentSpanContext,\n                            },\n                        ];\n                    }\n                }\n                const span = self.tracer.startSpan(`${queue} process`, {\n                    kind: api_1.SpanKind.CONSUMER,\n                    attributes: Object.assign(Object.assign({}, (_d = channel === null || channel === void 0 ? void 0 : channel.connection) === null || _d === void 0 ? void 0 : _d[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: (_e = msg.fields) === null || _e === void 0 ? void 0 : _e.routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: msg === null || msg === void 0 ? void 0 : msg.properties.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: msg === null || msg === void 0 ? void 0 : msg.properties.correlationId }),\n                    links,\n                }, parentContext);\n                const { consumeHook } = self.getConfig();\n                if (consumeHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; consumeHook(span, { moduleVersion, msg }), e =&gt; {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: consumerHook error', e);\n                        }\n                    }, true);\n                }\n                if (!(options === null || options === void 0 ? void 0 : options.noAck)) {\n                    // store the message on the channel so we can close the span on ackAll etc\n                    channel[utils_1.CHANNEL_SPANS_NOT_ENDED].push({\n                        msg,\n                        timeOfConsume: (0, core_1.hrTime)(),\n                    });\n                    // store the span on the message, so we can end it when user call 'ack' on it\n                    msg[utils_1.MESSAGE_STORED_SPAN] = span;\n                }\n                const setContext = parentContext\n                    ? parentContext\n                    : api_1.ROOT_CONTEXT;\n                api_1.context.with(api_1.trace.setSpan(setContext, span), () =&gt; {\n                    onMessage.call(this, msg);\n                });\n                if (options === null || options === void 0 ? void 0 : options.noAck) {\n                    self.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);\n                    span.end();\n                }\n            };\n            arguments[1] = patchedOnMessage;\n            return original.apply(this, arguments);\n        };\n    }\n    getConfirmedPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function confirmedPublish(exchange, routingKey, content, options, callback) {\n            const channel = this;\n            const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n            const { publishHook } = self.getConfig();\n            if (publishHook) {\n                (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishHook(span, {\n                    moduleVersion,\n                    exchange,\n                    routingKey,\n                    content,\n                    options: modifiedOptions,\n                    isConfirmChannel: true,\n                }), e =&gt; {\n                    if (e) {\n                        api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                    }\n                }, true);\n            }\n            const patchedOnConfirm = function (err, ok) {\n                try {\n                    callback === null || callback === void 0 ? void 0 : callback.call(this, err, ok);\n                }\n                finally {\n                    const { publishConfirmHook } = self.getConfig();\n                    if (publishConfirmHook) {\n                        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishConfirmHook(span, {\n                            moduleVersion,\n                            exchange,\n                            routingKey,\n                            content,\n                            options,\n                            isConfirmChannel: true,\n                            confirmError: err,\n                        }), e =&gt; {\n                            if (e) {\n                                api_1.diag.error('amqplib instrumentation: publishConfirmHook error', e);\n                            }\n                        }, true);\n                    }\n                    if (err) {\n                        span.setStatus({\n                            code: api_1.SpanStatusCode.ERROR,\n                            message: \"message confirmation has been nack'ed\",\n                        });\n                    }\n                    span.end();\n                }\n            };\n            // calling confirm channel publish function is storing the message in queue and registering the callback for broker confirm.\n            // span ends in the patched callback.\n            const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());\n            const argumentsCopy = [...arguments];\n            argumentsCopy[3] = modifiedOptions;\n            argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);\n            return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));\n        };\n    }\n    getPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function publish(exchange, routingKey, content, options) {\n            if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {\n                // work already done\n                return original.apply(this, arguments);\n            }\n            else {\n                const channel = this;\n                const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n                const { publishHook } = self.getConfig();\n                if (publishHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; publishHook(span, {\n                        moduleVersion,\n                        exchange,\n                        routingKey,\n                        content,\n                        options: modifiedOptions,\n                        isConfirmChannel: false,\n                    }), e =&gt; {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                        }\n                    }, true);\n                }\n                // calling normal channel publish function is only storing the message in queue.\n                // it does not send it and waits for an ack, so the span duration is expected to be very short.\n                const argumentsCopy = [...arguments];\n                argumentsCopy[3] = modifiedOptions;\n                const originalRes = original.apply(this, argumentsCopy);\n                span.end();\n                return originalRes;\n            }\n        };\n    }\n    createPublishSpan(self, exchange, routingKey, channel, options) {\n        var _a;\n        const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);\n        const span = self.tracer.startSpan(`publish ${normalizedExchange}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: Object.assign(Object.assign({}, channel.connection[utils_1.CONNECTION_ATTRIBUTES]), { [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange, [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC, [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey, [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: options === null || options === void 0 ? void 0 : options.messageId, [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: options === null || options === void 0 ? void 0 : options.correlationId }),\n        });\n        const modifiedOptions = options !== null &amp;&amp; options !== void 0 ? options : {};\n        modifiedOptions.headers = (_a = modifiedOptions.headers) !== null &amp;&amp; _a !== void 0 ? _a : {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);\n        return { span, modifiedOptions };\n    }\n    endConsumerSpan(message, isRejected, operation, requeue) {\n        const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];\n        if (!storedSpan)\n            return;\n        if (isRejected !== false) {\n            storedSpan.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: operation !== types_1.EndOperation.ChannelClosed &amp;&amp;\n                    operation !== types_1.EndOperation.ChannelError\n                    ? `${operation} called on message${requeue === true\n                        ? ' with requeue'\n                        : requeue === false\n                            ? ' without requeue'\n                            : ''}`\n                    : operation,\n            });\n        }\n        this.callConsumeEndHook(storedSpan, message, isRejected, operation);\n        storedSpan.end();\n        message[utils_1.MESSAGE_STORED_SPAN] = undefined;\n    }\n    endAllSpansOnChannel(channel, isRejected, operation, requeue) {\n        var _a;\n        const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n        spansNotEnded.forEach(msgDetails =&gt; {\n            this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);\n        });\n        channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n    }\n    callConsumeEndHook(span, msg, rejected, endOperation) {\n        const { consumeEndHook } = this.getConfig();\n        if (!consumeEndHook)\n            return;\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; consumeEndHook(span, { msg, rejected, endOperation }), e =&gt; {\n            if (e) {\n                api_1.diag.error('amqplib instrumentation: consumerEndHook error', e);\n            }\n        }, true);\n    }\n    checkConsumeTimeoutOnChannel(channel) {\n        var _a;\n        const currentTime = (0, core_1.hrTime)();\n        const spansNotEnded = (_a = channel[utils_1.CHANNEL_SPANS_NOT_ENDED]) !== null &amp;&amp; _a !== void 0 ? _a : [];\n        let i;\n        const { consumeTimeoutMs } = this.getConfig();\n        for (i = 0; i &lt; spansNotEnded.length; i++) {\n            const currMessage = spansNotEnded[i];\n            const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);\n            if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) &lt; consumeTimeoutMs) {\n                break;\n            }\n            this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);\n        }\n        spansNotEnded.splice(0, i);\n    }\n}\nexports.AmqplibInstrumentation = AmqplibInstrumentation;\n//# sourceMappingURL=amqplib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL2FtcXBsaWIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxrSUFBb0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLCtKQUFxQjtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyxnTUFBZ0M7QUFDbEUsK0JBQStCLG1CQUFPLENBQUMsc0xBQXFDO0FBQzVFLGdCQUFnQixtQkFBTyxDQUFDLHlMQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHlMQUFTO0FBQ2pDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNkxBQVc7QUFDckM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwrRkFBK0Y7QUFDL0Y7QUFDQSx5QkFBeUI7QUFDekIsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0EsOERBQThELHlKQUF5Six1ckJBQXVyQjtBQUM5NEI7QUFDQSxpQkFBaUI7QUFDakIsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQSw0RkFBNEYsb0JBQW9CO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hELHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0Esc0RBQXNELHdEQUF3RCwrZ0JBQStnQjtBQUM3bkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0EsbUZBQW1GLDZCQUE2QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9hbXFwbGliLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbXFwbGliSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuY29uc3QgaW5zdHJ1bWVudGF0aW9uXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uXCIpO1xuY29uc3Qgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKiBAa25pcGlnbm9yZSAqL1xuY29uc3QgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmNvbnN0IHN1cHBvcnRlZFZlcnNpb25zID0gWyc+PTAuNS41IDwxJ107XG5jbGFzcyBBbXFwbGliSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIodmVyc2lvbl8xLlBBQ0tBR0VfTkFNRSwgdmVyc2lvbl8xLlBBQ0tBR0VfVkVSU0lPTiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0eXBlc18xLkRFRkFVTFRfQ09ORklHKSwgY29uZmlnKSk7XG4gICAgfVxuICAgIHNldENvbmZpZyhjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlci5zZXRDb25maWcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0eXBlc18xLkRFRkFVTFRfQ09ORklHKSwgY29uZmlnKSk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxNb2RlbE1vZHVsZUZpbGUgPSBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZUZpbGUoJ2FtcXBsaWIvbGliL2NoYW5uZWxfbW9kZWwuanMnLCBzdXBwb3J0ZWRWZXJzaW9ucywgdGhpcy5wYXRjaENoYW5uZWxNb2RlbC5iaW5kKHRoaXMpLCB0aGlzLnVucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTW9kZWxNb2R1bGVGaWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVGaWxlKCdhbXFwbGliL2xpYi9jYWxsYmFja19tb2RlbC5qcycsIHN1cHBvcnRlZFZlcnNpb25zLCB0aGlzLnBhdGNoQ2hhbm5lbE1vZGVsLmJpbmQodGhpcyksIHRoaXMudW5wYXRjaENoYW5uZWxNb2RlbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3QgY29ubmVjdE1vZHVsZUZpbGUgPSBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZUZpbGUoJ2FtcXBsaWIvbGliL2Nvbm5lY3QuanMnLCBzdXBwb3J0ZWRWZXJzaW9ucywgdGhpcy5wYXRjaENvbm5lY3QuYmluZCh0aGlzKSwgdGhpcy51bnBhdGNoQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKCdhbXFwbGliJywgc3VwcG9ydGVkVmVyc2lvbnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBbY2hhbm5lbE1vZGVsTW9kdWxlRmlsZSwgY29ubmVjdE1vZHVsZUZpbGUsIGNhbGxiYWNrTW9kZWxNb2R1bGVGaWxlXSk7XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICAgIHBhdGNoQ29ubmVjdChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZUV4cG9ydHMgPSB0aGlzLnVucGF0Y2hDb25uZWN0KG1vZHVsZUV4cG9ydHMpO1xuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuY29ubmVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgJ2Nvbm5lY3QnLCB0aGlzLmdldENvbm5lY3RQYXRjaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICB9XG4gICAgdW5wYXRjaENvbm5lY3QobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5jb25uZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsICdjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgfVxuICAgIHBhdGNoQ2hhbm5lbE1vZGVsKG1vZHVsZUV4cG9ydHMsIG1vZHVsZVZlcnNpb24pIHtcbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2gpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdwdWJsaXNoJywgdGhpcy5nZXRQdWJsaXNoUGF0Y2guYmluZCh0aGlzLCBtb2R1bGVWZXJzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmNvbnN1bWUpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdjb25zdW1lJywgdGhpcy5nZXRDb25zdW1lUGF0Y2guYmluZCh0aGlzLCBtb2R1bGVWZXJzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2FjaycsIHRoaXMuZ2V0QWNrUGF0Y2guYmluZCh0aGlzLCBmYWxzZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLm5hY2spKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICduYWNrJywgdGhpcy5nZXRBY2tQYXRjaC5iaW5kKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLk5hY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUucmVqZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncmVqZWN0JywgdGhpcy5nZXRBY2tQYXRjaC5iaW5kKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLlJlamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2tBbGwpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdhY2tBbGwnLCB0aGlzLmdldEFja0FsbFBhdGNoLmJpbmQodGhpcywgZmFsc2UsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkFja0FsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5uYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFja0FsbCcsIHRoaXMuZ2V0QWNrQWxsUGF0Y2guYmluZCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5OYWNrQWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmVtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdlbWl0JywgdGhpcy5nZXRDaGFubmVsRW1pdFBhdGNoLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5Db25maXJtQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5Db25maXJtQ2hhbm5lbC5wcm90b3R5cGUsICdwdWJsaXNoJywgdGhpcy5nZXRDb25maXJtZWRQdWJsaXNoUGF0Y2guYmluZCh0aGlzLCBtb2R1bGVWZXJzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgfVxuICAgIHVucGF0Y2hDaGFubmVsTW9kZWwobW9kdWxlRXhwb3J0cykge1xuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdwdWJsaXNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuY29uc3VtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnY29uc3VtZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnbmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLnJlamVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAncmVqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdhY2tBbGwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5uYWNrQWxsKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICduYWNrQWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuZW1pdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnZW1pdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNvbmZpcm1DaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLCAncHVibGlzaCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICBnZXRDb25uZWN0UGF0Y2gob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoZWRDb25uZWN0KHVybCwgc29ja2V0T3B0aW9ucywgb3BlbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuY2FsbCh0aGlzLCB1cmwsIHNvY2tldE9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGNvbm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsQXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybCkodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHR5cGUgb2YgY29ubiBpbiBAdHlwZXMvYW1xcGxpYiBpcyBhbXFwLkNvbm5lY3Rpb24sIGJ1dCBpbiBwcmFjdGljZSB0aGUgbGlicmFyeSBzZW5kIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBgc2VydmVyUHJvcGVydGllc2Agb24gdGhlIGBjb25uYCBhbmQgbm90IGluIGEgcHJvcGVydHkgYGNvbm5lY3Rpb25gLlxuICAgICAgICAgICAgICAgICAgICAvLyBJIGRvbid0IGhhdmUgY2FwYWNpdHkgdG8gZGVidWcgaXQgY3VycmVudGx5IGJ1dCBpdCBzaG91bGQgcHJvYmFibHkgYmUgZml4ZWQgaW4gQHR5cGVzIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBwYWNrYWdlIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50bHkgc2V0dGluZyBhcyBhbnkgdG8gY2FsbSB0eXBlc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXIpKGNvbm4pO1xuICAgICAgICAgICAgICAgICAgICBjb25uW3V0aWxzXzEuQ09OTkVDVElPTl9BVFRSSUJVVEVTXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXJsQXR0cmlidXRlcyksIHNlcnZlckF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcGVuQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDaGFubmVsRW1pdFBhdGNoKG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZW1pdChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZEFsbFNwYW5zT25DaGFubmVsKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxDbG9zZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVGltZXIgPSB0aGlzW3V0aWxzXzEuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVJdO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGFjdGl2ZVRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1t1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHNlbGYuZW5kQWxsU3BhbnNPbkNoYW5uZWwodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQ2hhbm5lbEVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEFja0FsbFBhdGNoKGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhY2tBbGwocmVxdWV1ZU9yRW1wdHkpIHtcbiAgICAgICAgICAgIHNlbGYuZW5kQWxsU3BhbnNPbkNoYW5uZWwodGhpcywgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlT3JFbXB0eSk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0QWNrUGF0Y2goaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFjayhtZXNzYWdlLCBhbGxVcFRvT3JSZXF1ZXVlLCByZXF1ZXVlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIC8vIHdlIHVzZSB0aGlzIHBhdGNoIGluIHJlamVjdCBmdW5jdGlvbiBhcyB3ZWxsLCBidXQgaXQgaGFzIGRpZmZlcmVudCBzaWduYXR1cmVcbiAgICAgICAgICAgIGNvbnN0IHJlcXVldWVSZXNvbHZlZCA9IGVuZE9wZXJhdGlvbiA9PT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uUmVqZWN0ID8gYWxsVXBUb09yUmVxdWV1ZSA6IHJlcXVldWU7XG4gICAgICAgICAgICBjb25zdCBzcGFuc05vdEVuZGVkID0gKF9hID0gY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICBjb25zdCBtc2dJbmRleCA9IHNwYW5zTm90RW5kZWQuZmluZEluZGV4KG1zZ0RldGFpbHMgPT4gbXNnRGV0YWlscy5tc2cgPT09IG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG1zZ0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuIGluIGhhcHB5IGZsb3dcbiAgICAgICAgICAgICAgICAvLyBidXQgcG9zc2libGUgaWYgdXNlciBpcyBjYWxsaW5nIHRoZSBhcGkgZnVuY3Rpb24gYWNrIHR3aWNlIHdpdGggc2FtZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgc2VsZi5lbmRDb25zdW1lclNwYW4obWVzc2FnZSwgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlUmVzb2x2ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kT3BlcmF0aW9uICE9PSB0eXBlc18xLkVuZE9wZXJhdGlvbi5SZWplY3QgJiYgYWxsVXBUb09yUmVxdWV1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1zZ0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmRDb25zdW1lclNwYW4oc3BhbnNOb3RFbmRlZFtpXS5tc2csIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZVJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BhbnNOb3RFbmRlZC5zcGxpY2UoMCwgbXNnSW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZW5kQ29uc3VtZXJTcGFuKG1lc3NhZ2UsIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZVJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICBzcGFuc05vdEVuZGVkLnNwbGljZShtc2dJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q29uc3VtZVBhdGNoKG1vZHVsZVZlcnNpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uc3VtZShxdWV1ZSwgb25NZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoYW5uZWwsIHV0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25zdW1lVGltZW91dE1zIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lVGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaGVja0NvbnN1bWVUaW1lb3V0T25DaGFubmVsKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICB9LCBjb25zdW1lVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXSA9IHRpbWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaGVkT25NZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgLy8gbXNnIGlzIGV4cGVjdGVkIHRvIGJlIG51bGwgZm9yIHNpZ25hbGluZyBjb25zdW1lciBjYW5jZWwgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmFiYml0bXEuY29tL2NvbnN1bWVyLWNhbmNlbC5odG1sXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlLCB3ZSBkbyBub3Qgc3RhcnQgYSBzcGFuLCBhcyB0aGlzIGlzIG5vdCBhIHJlYWwgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICBpZiAoIW1zZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25NZXNzYWdlLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IChfYSA9IG1zZy5wcm9wZXJ0aWVzLmhlYWRlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRDb250ZXh0ID0gYXBpXzEucHJvcGFnYXRpb24uZXh0cmFjdChhcGlfMS5ST09UX0NPTlRFWFQsIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2hhbmdlID0gKF9iID0gbXNnLmZpZWxkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4Y2hhbmdlO1xuICAgICAgICAgICAgICAgIGxldCBsaW5rcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fY29uZmlnLnVzZUxpbmtzRm9yQ29uc3VtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRTcGFuQ29udGV4dCA9IHBhcmVudENvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9jID0gYXBpXzEudHJhY2UuZ2V0U3BhbihwYXJlbnRDb250ZXh0KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwYW5Db250ZXh0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50U3BhbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogcGFyZW50U3BhbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHNlbGYudHJhY2VyLnN0YXJ0U3BhbihgJHtxdWV1ZX0gcHJvY2Vzc2AsIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuQ09OU1VNRVIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9kID0gY2hhbm5lbCA9PT0gbnVsbCB8fCBjaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVsLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFt1dGlsc18xLkNPTk5FQ1RJT05fQVRUUklCVVRFU10pLCB7IFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19ERVNUSU5BVElPTl06IGV4Y2hhbmdlLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05fS0lORF06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1RPUElDLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVldOiAoX2UgPSBtc2cuZmllbGRzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uucm91dGluZ0tleSwgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX09QRVJBVElPTl06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVTU0FHSU5HT1BFUkFUSU9OVkFMVUVTX1BST0NFU1MsIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19NRVNTQUdFX0lEXTogbXNnID09PSBudWxsIHx8IG1zZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXNnLnByb3BlcnRpZXMubWVzc2FnZUlkLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfQ09OVkVSU0FUSU9OX0lEXTogbXNnID09PSBudWxsIHx8IG1zZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXNnLnByb3BlcnRpZXMuY29ycmVsYXRpb25JZCB9KSxcbiAgICAgICAgICAgICAgICAgICAgbGlua3MsXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50Q29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25zdW1lSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbnN1bWVIb29rKHNwYW4sIHsgbW9kdWxlVmVyc2lvbiwgbXNnIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGNvbnN1bWVySG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vQWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgbWVzc2FnZSBvbiB0aGUgY2hhbm5lbCBzbyB3ZSBjYW4gY2xvc2UgdGhlIHNwYW4gb24gYWNrQWxsIGV0Y1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9mQ29uc3VtZTogKDAsIGNvcmVfMS5oclRpbWUpKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgc3BhbiBvbiB0aGUgbWVzc2FnZSwgc28gd2UgY2FuIGVuZCBpdCB3aGVuIHVzZXIgY2FsbCAnYWNrJyBvbiBpdFxuICAgICAgICAgICAgICAgICAgICBtc2dbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXSA9IHNwYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNldENvbnRleHQgPSBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgID8gcGFyZW50Q29udGV4dFxuICAgICAgICAgICAgICAgICAgICA6IGFwaV8xLlJPT1RfQ09OVEVYVDtcbiAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LndpdGgoYXBpXzEudHJhY2Uuc2V0U3BhbihzZXRDb250ZXh0LCBzcGFuKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2UuY2FsbCh0aGlzLCBtc2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9BY2spIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxsQ29uc3VtZUVuZEhvb2soc3BhbiwgbXNnLCBmYWxzZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQXV0b0Fjayk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFyZ3VtZW50c1sxXSA9IHBhdGNoZWRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q29uZmlybWVkUHVibGlzaFBhdGNoKG1vZHVsZVZlcnNpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uZmlybWVkUHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBzcGFuLCBtb2RpZmllZE9wdGlvbnMgfSA9IHNlbGYuY3JlYXRlUHVibGlzaFNwYW4oc2VsZiwgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNoYW5uZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyBwdWJsaXNoSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgIGlmIChwdWJsaXNoSG9vaykge1xuICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwdWJsaXNoSG9vayhzcGFuLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZVZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICByb3V0aW5nS2V5LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBtb2RpZmllZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGlzQ29uZmlybUNoYW5uZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IHB1Ymxpc2hIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRPbkNvbmZpcm0gPSBmdW5jdGlvbiAoZXJyLCBvaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjay5jYWxsKHRoaXMsIGVyciwgb2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwdWJsaXNoQ29uZmlybUhvb2sgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoQ29uZmlybUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBwdWJsaXNoQ29uZmlybUhvb2soc3Bhbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZVZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25maXJtQ2hhbm5lbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogcHVibGlzaENvbmZpcm1Ib29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZSBjb25maXJtYXRpb24gaGFzIGJlZW4gbmFjaydlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2FsbGluZyBjb25maXJtIGNoYW5uZWwgcHVibGlzaCBmdW5jdGlvbiBpcyBzdG9yaW5nIHRoZSBtZXNzYWdlIGluIHF1ZXVlIGFuZCByZWdpc3RlcmluZyB0aGUgY2FsbGJhY2sgZm9yIGJyb2tlciBjb25maXJtLlxuICAgICAgICAgICAgLy8gc3BhbiBlbmRzIGluIHRoZSBwYXRjaGVkIGNhbGxiYWNrLlxuICAgICAgICAgICAgY29uc3QgbWFya2VkQ29udGV4dCA9ICgwLCB1dGlsc18xLm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcpKGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpO1xuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzQ29weSA9IFsuLi5hcmd1bWVudHNdO1xuICAgICAgICAgICAgYXJndW1lbnRzQ29weVszXSA9IG1vZGlmaWVkT3B0aW9ucztcbiAgICAgICAgICAgIGFyZ3VtZW50c0NvcHlbNF0gPSBhcGlfMS5jb250ZXh0LmJpbmQoKDAsIHV0aWxzXzEudW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nKShhcGlfMS50cmFjZS5zZXRTcGFuKG1hcmtlZENvbnRleHQsIHNwYW4pKSwgcGF0Y2hlZE9uQ29uZmlybSk7XG4gICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKG1hcmtlZENvbnRleHQsIG9yaWdpbmFsLmJpbmQodGhpcywgLi4uYXJndW1lbnRzQ29weSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRQdWJsaXNoUGF0Y2gobW9kdWxlVmVyc2lvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwdWJsaXNoKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNDb25maXJtQ2hhbm5lbFRyYWNpbmcpKGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gd29yayBhbHJlYWR5IGRvbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3BhbiwgbW9kaWZpZWRPcHRpb25zIH0gPSBzZWxmLmNyZWF0ZVB1Ymxpc2hTcGFuKHNlbGYsIGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjaGFubmVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHB1Ymxpc2hIb29rIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gcHVibGlzaEhvb2soc3Bhbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBtb2RpZmllZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbmZpcm1DaGFubmVsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogcHVibGlzaEhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNhbGxpbmcgbm9ybWFsIGNoYW5uZWwgcHVibGlzaCBmdW5jdGlvbiBpcyBvbmx5IHN0b3JpbmcgdGhlIG1lc3NhZ2UgaW4gcXVldWUuXG4gICAgICAgICAgICAgICAgLy8gaXQgZG9lcyBub3Qgc2VuZCBpdCBhbmQgd2FpdHMgZm9yIGFuIGFjaywgc28gdGhlIHNwYW4gZHVyYXRpb24gaXMgZXhwZWN0ZWQgdG8gYmUgdmVyeSBzaG9ydC5cbiAgICAgICAgICAgICAgICBjb25zdCBhcmd1bWVudHNDb3B5ID0gWy4uLmFyZ3VtZW50c107XG4gICAgICAgICAgICAgICAgYXJndW1lbnRzQ29weVszXSA9IG1vZGlmaWVkT3B0aW9ucztcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFJlcyA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50c0NvcHkpO1xuICAgICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVQdWJsaXNoU3BhbihzZWxmLCBleGNoYW5nZSwgcm91dGluZ0tleSwgY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFeGNoYW5nZSA9ICgwLCB1dGlsc18xLm5vcm1hbGl6ZUV4Y2hhbmdlKShleGNoYW5nZSk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzZWxmLnRyYWNlci5zdGFydFNwYW4oYHB1Ymxpc2ggJHtub3JtYWxpemVkRXhjaGFuZ2V9YCwge1xuICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuUFJPRFVDRVIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYW5uZWwuY29ubmVjdGlvblt1dGlsc18xLkNPTk5FQ1RJT05fQVRUUklCVVRFU10pLCB7IFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19ERVNUSU5BVElPTl06IGV4Y2hhbmdlLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05fS0lORF06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1RPUElDLCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUkFCQklUTVFfUk9VVElOR19LRVldOiByb3V0aW5nS2V5LCBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9JRF06IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlSWQsIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19DT05WRVJTQVRJT05fSURdOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29ycmVsYXRpb25JZCB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICBtb2RpZmllZE9wdGlvbnMuaGVhZGVycyA9IChfYSA9IG1vZGlmaWVkT3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KGFwaV8xLnRyYWNlLnNldFNwYW4oYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgc3BhbiksIG1vZGlmaWVkT3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHsgc3BhbiwgbW9kaWZpZWRPcHRpb25zIH07XG4gICAgfVxuICAgIGVuZENvbnN1bWVyU3BhbihtZXNzYWdlLCBpc1JlamVjdGVkLCBvcGVyYXRpb24sIHJlcXVldWUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkU3BhbiA9IG1lc3NhZ2VbdXRpbHNfMS5NRVNTQUdFX1NUT1JFRF9TUEFOXTtcbiAgICAgICAgaWYgKCFzdG9yZWRTcGFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaXNSZWplY3RlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0b3JlZFNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcGVyYXRpb24gIT09IHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxDbG9zZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uICE9PSB0eXBlc18xLkVuZE9wZXJhdGlvbi5DaGFubmVsRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtvcGVyYXRpb259IGNhbGxlZCBvbiBtZXNzYWdlJHtyZXF1ZXVlID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcgd2l0aCByZXF1ZXVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXF1ZXVlID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJyB3aXRob3V0IHJlcXVldWUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJ31gXG4gICAgICAgICAgICAgICAgICAgIDogb3BlcmF0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsQ29uc3VtZUVuZEhvb2soc3RvcmVkU3BhbiwgbWVzc2FnZSwgaXNSZWplY3RlZCwgb3BlcmF0aW9uKTtcbiAgICAgICAgc3RvcmVkU3Bhbi5lbmQoKTtcbiAgICAgICAgbWVzc2FnZVt1dGlsc18xLk1FU1NBR0VfU1RPUkVEX1NQQU5dID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmRBbGxTcGFuc09uQ2hhbm5lbChjaGFubmVsLCBpc1JlamVjdGVkLCBvcGVyYXRpb24sIHJlcXVldWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzcGFuc05vdEVuZGVkID0gKF9hID0gY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIHNwYW5zTm90RW5kZWQuZm9yRWFjaChtc2dEZXRhaWxzID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29uc3VtZXJTcGFuKG1zZ0RldGFpbHMubXNnLCBpc1JlamVjdGVkLCBvcGVyYXRpb24sIHJlcXVldWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSA9IFtdO1xuICAgIH1cbiAgICBjYWxsQ29uc3VtZUVuZEhvb2soc3BhbiwgbXNnLCByZWplY3RlZCwgZW5kT3BlcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgY29uc3VtZUVuZEhvb2sgfSA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIGlmICghY29uc3VtZUVuZEhvb2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25zdW1lRW5kSG9vayhzcGFuLCB7IG1zZywgcmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiB9KSwgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBjb25zdW1lckVuZEhvb2sgZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNoZWNrQ29uc3VtZVRpbWVvdXRPbkNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKDAsIGNvcmVfMS5oclRpbWUpKCk7XG4gICAgICAgIGNvbnN0IHNwYW5zTm90RW5kZWQgPSAoX2EgPSBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IHsgY29uc3VtZVRpbWVvdXRNcyB9ID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYW5zTm90RW5kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJNZXNzYWdlID0gc3BhbnNOb3RFbmRlZFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVGcm9tQ29uc3VtZSA9ICgwLCBjb3JlXzEuaHJUaW1lRHVyYXRpb24pKGN1cnJNZXNzYWdlLnRpbWVPZkNvbnN1bWUsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGlmICgoMCwgY29yZV8xLmhyVGltZVRvTWlsbGlzZWNvbmRzKSh0aW1lRnJvbUNvbnN1bWUpIDwgY29uc3VtZVRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbmRDb25zdW1lclNwYW4oY3Vyck1lc3NhZ2UubXNnLCBudWxsLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5JbnN0cnVtZW50YXRpb25UaW1lb3V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFuc05vdEVuZGVkLnNwbGljZSgwLCBpKTtcbiAgICB9XG59XG5leHBvcnRzLkFtcXBsaWJJbnN0cnVtZW50YXRpb24gPSBBbXFwbGliSW5zdHJ1bWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1xcGxpYi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ (function(__unused_webpack_module, exports, __webpack_require__) {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nvar __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this &amp;&amp; this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" &amp;&amp; !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n__exportStar(__webpack_require__(/*! ./amqplib */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNkxBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLHlMQUFTO0FBQzlCIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hbXFwbGliXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CONFIG = exports.EndOperation = void 0;\nvar EndOperation;\n(function (EndOperation) {\n    EndOperation[\"AutoAck\"] = \"auto ack\";\n    EndOperation[\"Ack\"] = \"ack\";\n    EndOperation[\"AckAll\"] = \"ackAll\";\n    EndOperation[\"Reject\"] = \"reject\";\n    EndOperation[\"Nack\"] = \"nack\";\n    EndOperation[\"NackAll\"] = \"nackAll\";\n    EndOperation[\"ChannelClosed\"] = \"channel closed\";\n    EndOperation[\"ChannelError\"] = \"channel error\";\n    EndOperation[\"InstrumentationTimeout\"] = \"instrumentation timeout\";\n})(EndOperation = exports.EndOperation || (exports.EndOperation = {}));\nexports.DEFAULT_CONFIG = {\n    consumeTimeoutMs: 1000 * 60,\n    useLinksForConsume: false,\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEMsb0JBQW9CLEtBQUs7QUFDcEUsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNDYuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9DT05GSUcgPSBleHBvcnRzLkVuZE9wZXJhdGlvbiA9IHZvaWQgMDtcbnZhciBFbmRPcGVyYXRpb247XG4oZnVuY3Rpb24gKEVuZE9wZXJhdGlvbikge1xuICAgIEVuZE9wZXJhdGlvbltcIkF1dG9BY2tcIl0gPSBcImF1dG8gYWNrXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQWNrXCJdID0gXCJhY2tcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJBY2tBbGxcIl0gPSBcImFja0FsbFwiO1xuICAgIEVuZE9wZXJhdGlvbltcIlJlamVjdFwiXSA9IFwicmVqZWN0XCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiTmFja1wiXSA9IFwibmFja1wiO1xuICAgIEVuZE9wZXJhdGlvbltcIk5hY2tBbGxcIl0gPSBcIm5hY2tBbGxcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJDaGFubmVsQ2xvc2VkXCJdID0gXCJjaGFubmVsIGNsb3NlZFwiO1xuICAgIEVuZE9wZXJhdGlvbltcIkNoYW5uZWxFcnJvclwiXSA9IFwiY2hhbm5lbCBlcnJvclwiO1xuICAgIEVuZE9wZXJhdGlvbltcIkluc3RydW1lbnRhdGlvblRpbWVvdXRcIl0gPSBcImluc3RydW1lbnRhdGlvbiB0aW1lb3V0XCI7XG59KShFbmRPcGVyYXRpb24gPSBleHBvcnRzLkVuZE9wZXJhdGlvbiB8fCAoZXhwb3J0cy5FbmRPcGVyYXRpb24gPSB7fSkpO1xuZXhwb3J0cy5ERUZBVUxUX0NPTkZJRyA9IHtcbiAgICBjb25zdW1lVGltZW91dE1zOiAxMDAwICogNjAsXG4gICAgdXNlTGlua3NGb3JDb25zdW1lOiBmYWxzZSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isConfirmChannelTracing = exports.unmarkConfirmChannelTracing = exports.markConfirmChannelTracing = exports.getConnectionAttributesFromUrl = exports.getConnectionAttributesFromServer = exports.normalizeExchange = exports.CONNECTION_ATTRIBUTES = exports.CHANNEL_CONSUME_TIMEOUT_TIMER = exports.CHANNEL_SPANS_NOT_ENDED = exports.MESSAGE_STORED_SPAN = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.36.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nexports.MESSAGE_STORED_SPAN = Symbol('opentelemetry.amqplib.message.stored-span');\nexports.CHANNEL_SPANS_NOT_ENDED = Symbol('opentelemetry.amqplib.channel.spans-not-ended');\nexports.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol('opentelemetry.amqplib.channel.consumer-timeout-timer');\nexports.CONNECTION_ATTRIBUTES = Symbol('opentelemetry.amqplib.connection.attributes');\nconst IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)('opentelemetry.amqplib.channel.is-confirm-channel');\nconst normalizeExchange = (exchangeName) =&gt; exchangeName !== '' ? exchangeName : '&lt;default&gt;';\nexports.normalizeExchange = normalizeExchange;\nconst censorPassword = (url) =&gt; {\n    return url.replace(/:[^:@/]*@/, ':***@');\n};\nconst getPort = (portFromUrl, resolvedProtocol) =&gt; {\n    // we are using the resolved protocol which is upper case\n    // this code mimic the behavior of the amqplib which is used to set connection params\n    return portFromUrl || (resolvedProtocol === 'AMQP' ? 5672 : 5671);\n};\nconst getProtocol = (protocolFromUrl) =&gt; {\n    const resolvedProtocol = protocolFromUrl || 'amqp';\n    // the substring removed the ':' part of the protocol ('amqp:' -&gt; 'amqp')\n    const noEndingColon = resolvedProtocol.endsWith(':')\n        ? resolvedProtocol.substring(0, resolvedProtocol.length - 1)\n        : resolvedProtocol;\n    // upper cases to match spec\n    return noEndingColon.toUpperCase();\n};\nconst getHostname = (hostnameFromUrl) =&gt; {\n    // if user supplies empty hostname, it gets forwarded to 'net' package which default it to localhost.\n    // https://nodejs.org/docs/latest-v12.x/api/net.html#net_socket_connect_options_connectlistener\n    return hostnameFromUrl || 'localhost';\n};\nconst extractConnectionAttributeOrLog = (url, attributeKey, attributeValue, nameForLog) =&gt; {\n    if (attributeValue) {\n        return { [attributeKey]: attributeValue };\n    }\n    else {\n        api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {\n            url,\n        });\n        return {};\n    }\n};\nconst getConnectionAttributesFromServer = (conn) =&gt; {\n    var _a, _b;\n    const product = (_b = (_a = conn.serverProperties.product) === null || _a === void 0 ? void 0 : _a.toLowerCase) === null || _b === void 0 ? void 0 : _b.call(_a);\n    if (product) {\n        return {\n            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: product,\n        };\n    }\n    else {\n        return {};\n    }\n};\nexports.getConnectionAttributesFromServer = getConnectionAttributesFromServer;\nconst getConnectionAttributesFromUrl = (url) =&gt; {\n    const attributes = {\n        [semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL_VERSION]: '0.9.1', // this is the only protocol supported by the instrumented library\n    };\n    url = url || 'amqp://localhost';\n    if (typeof url === 'object') {\n        const connectOptions = url;\n        const protocol = getProtocol(connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.protocol);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, 'protocol')));\n        const hostname = getHostname(connectOptions === null || connectOptions === void 0 ? void 0 : connectOptions.hostname);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, 'hostname')));\n        const port = getPort(connectOptions.port, protocol);\n        Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, 'port')));\n    }\n    else {\n        const censoredUrl = censorPassword(url);\n        attributes[semantic_conventions_1.SEMATTRS_MESSAGING_URL] = censoredUrl;\n        try {\n            const urlParts = new URL(censoredUrl);\n            const protocol = getProtocol(urlParts.protocol);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, 'protocol')));\n            const hostname = getHostname(urlParts.hostname);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, 'hostname')));\n            const port = getPort(urlParts.port ? parseInt(urlParts.port) : undefined, protocol);\n            Object.assign(attributes, Object.assign({}, extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, 'port')));\n        }\n        catch (err) {\n            api_1.diag.error('amqplib instrumentation: error while extracting connection details from connection url', {\n                censoredUrl,\n                err,\n            });\n        }\n    }\n    return attributes;\n};\nexports.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;\nconst markConfirmChannelTracing = (context) =&gt; {\n    return context.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);\n};\nexports.markConfirmChannelTracing = markConfirmChannelTracing;\nconst unmarkConfirmChannelTracing = (context) =&gt; {\n    return context.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);\n};\nexports.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;\nconst isConfirmChannelTracing = (context) =&gt; {\n    return context.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;\n};\nexports.isConfirmChannelTracing = isConfirmChannelTracing;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxHQUFHLHNDQUFzQyxHQUFHLHlDQUF5QyxHQUFHLHlCQUF5QixHQUFHLDZCQUE2QixHQUFHLHFDQUFxQyxHQUFHLCtCQUErQixHQUFHLDJCQUEyQjtBQUNsVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsa0lBQW9CO0FBQzFDLCtCQUErQixtQkFBTyxDQUFDLHNMQUFxQztBQUM1RSwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDRGQUE0RixZQUFZO0FBQ3hHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IGV4cG9ydHMudW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gZXhwb3J0cy5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gZXhwb3J0cy5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwgPSBleHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IGV4cG9ydHMubm9ybWFsaXplRXhjaGFuZ2UgPSBleHBvcnRzLkNPTk5FQ1RJT05fQVRUUklCVVRFUyA9IGV4cG9ydHMuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVIgPSBleHBvcnRzLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEID0gZXhwb3J0cy5NRVNTQUdFX1NUT1JFRF9TUEFOID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNcIik7XG5leHBvcnRzLk1FU1NBR0VfU1RPUkVEX1NQQU4gPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5tZXNzYWdlLnN0b3JlZC1zcGFuJyk7XG5leHBvcnRzLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIuY2hhbm5lbC5zcGFucy1ub3QtZW5kZWQnKTtcbmV4cG9ydHMuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVIgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jaGFubmVsLmNvbnN1bWVyLXRpbWVvdXQtdGltZXInKTtcbmV4cG9ydHMuQ09OTkVDVElPTl9BVFRSSUJVVEVTID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIuY29ubmVjdGlvbi5hdHRyaWJ1dGVzJyk7XG5jb25zdCBJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVkgPSAoMCwgYXBpXzEuY3JlYXRlQ29udGV4dEtleSkoJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jaGFubmVsLmlzLWNvbmZpcm0tY2hhbm5lbCcpO1xuY29uc3Qgbm9ybWFsaXplRXhjaGFuZ2UgPSAoZXhjaGFuZ2VOYW1lKSA9PiBleGNoYW5nZU5hbWUgIT09ICcnID8gZXhjaGFuZ2VOYW1lIDogJzxkZWZhdWx0Pic7XG5leHBvcnRzLm5vcm1hbGl6ZUV4Y2hhbmdlID0gbm9ybWFsaXplRXhjaGFuZ2U7XG5jb25zdCBjZW5zb3JQYXNzd29yZCA9ICh1cmwpID0+IHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLzpbXjpAL10qQC8sICc6KioqQCcpO1xufTtcbmNvbnN0IGdldFBvcnQgPSAocG9ydEZyb21VcmwsIHJlc29sdmVkUHJvdG9jb2wpID0+IHtcbiAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlIHJlc29sdmVkIHByb3RvY29sIHdoaWNoIGlzIHVwcGVyIGNhc2VcbiAgICAvLyB0aGlzIGNvZGUgbWltaWMgdGhlIGJlaGF2aW9yIG9mIHRoZSBhbXFwbGliIHdoaWNoIGlzIHVzZWQgdG8gc2V0IGNvbm5lY3Rpb24gcGFyYW1zXG4gICAgcmV0dXJuIHBvcnRGcm9tVXJsIHx8IChyZXNvbHZlZFByb3RvY29sID09PSAnQU1RUCcgPyA1NjcyIDogNTY3MSk7XG59O1xuY29uc3QgZ2V0UHJvdG9jb2wgPSAocHJvdG9jb2xGcm9tVXJsKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRQcm90b2NvbCA9IHByb3RvY29sRnJvbVVybCB8fCAnYW1xcCc7XG4gICAgLy8gdGhlIHN1YnN0cmluZyByZW1vdmVkIHRoZSAnOicgcGFydCBvZiB0aGUgcHJvdG9jb2wgKCdhbXFwOicgLT4gJ2FtcXAnKVxuICAgIGNvbnN0IG5vRW5kaW5nQ29sb24gPSByZXNvbHZlZFByb3RvY29sLmVuZHNXaXRoKCc6JylcbiAgICAgICAgPyByZXNvbHZlZFByb3RvY29sLnN1YnN0cmluZygwLCByZXNvbHZlZFByb3RvY29sLmxlbmd0aCAtIDEpXG4gICAgICAgIDogcmVzb2x2ZWRQcm90b2NvbDtcbiAgICAvLyB1cHBlciBjYXNlcyB0byBtYXRjaCBzcGVjXG4gICAgcmV0dXJuIG5vRW5kaW5nQ29sb24udG9VcHBlckNhc2UoKTtcbn07XG5jb25zdCBnZXRIb3N0bmFtZSA9IChob3N0bmFtZUZyb21VcmwpID0+IHtcbiAgICAvLyBpZiB1c2VyIHN1cHBsaWVzIGVtcHR5IGhvc3RuYW1lLCBpdCBnZXRzIGZvcndhcmRlZCB0byAnbmV0JyBwYWNrYWdlIHdoaWNoIGRlZmF1bHQgaXQgdG8gbG9jYWxob3N0LlxuICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC12MTIueC9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9jb25uZWN0X29wdGlvbnNfY29ubmVjdGxpc3RlbmVyXG4gICAgcmV0dXJuIGhvc3RuYW1lRnJvbVVybCB8fCAnbG9jYWxob3N0Jztcbn07XG5jb25zdCBleHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nID0gKHVybCwgYXR0cmlidXRlS2V5LCBhdHRyaWJ1dGVWYWx1ZSwgbmFtZUZvckxvZykgPT4ge1xuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4geyBbYXR0cmlidXRlS2V5XTogYXR0cmlidXRlVmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoYGFtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBjb3VsZCBub3QgZXh0cmFjdCBjb25uZWN0aW9uIGF0dHJpYnV0ZSAke25hbWVGb3JMb2d9IGZyb20gdXNlciBzdXBwbGllZCB1cmxgLCB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufTtcbmNvbnN0IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IChjb25uKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBwcm9kdWN0ID0gKF9iID0gKF9hID0gY29ubi5zZXJ2ZXJQcm9wZXJ0aWVzLnByb2R1Y3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfU1lTVEVNXTogcHJvZHVjdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59O1xuZXhwb3J0cy5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXIgPSBnZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21TZXJ2ZXI7XG5jb25zdCBnZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwgPSAodXJsKSA9PiB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MX1ZFUlNJT05dOiAnMC45LjEnLCAvLyB0aGlzIGlzIHRoZSBvbmx5IHByb3RvY29sIHN1cHBvcnRlZCBieSB0aGUgaW5zdHJ1bWVudGVkIGxpYnJhcnlcbiAgICB9O1xuICAgIHVybCA9IHVybCB8fCAnYW1xcDovL2xvY2FsaG9zdCc7XG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RPcHRpb25zID0gdXJsO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGdldFByb3RvY29sKGNvbm5lY3RPcHRpb25zID09PSBudWxsIHx8IGNvbm5lY3RPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0T3B0aW9ucy5wcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1BST1RPQ09MLCBwcm90b2NvbCwgJ3Byb3RvY29sJykpKTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZShjb25uZWN0T3B0aW9ucyA9PT0gbnVsbCB8fCBjb25uZWN0T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdE9wdGlvbnMuaG9zdG5hbWUpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24oe30sIGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2codXJsLCBzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX05BTUUsIGhvc3RuYW1lLCAnaG9zdG5hbWUnKSkpO1xuICAgICAgICBjb25zdCBwb3J0ID0gZ2V0UG9ydChjb25uZWN0T3B0aW9ucy5wb3J0LCBwcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVCwgcG9ydCwgJ3BvcnQnKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY2Vuc29yZWRVcmwgPSBjZW5zb3JQYXNzd29yZCh1cmwpO1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1VSTF0gPSBjZW5zb3JlZFVybDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybFBhcnRzID0gbmV3IFVSTChjZW5zb3JlZFVybCk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IGdldFByb3RvY29sKHVybFBhcnRzLnByb3RvY29sKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyhjZW5zb3JlZFVybCwgc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUFJPVE9DT0wsIHByb3RvY29sLCAncHJvdG9jb2wnKSkpO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZSh1cmxQYXJ0cy5ob3N0bmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIE9iamVjdC5hc3NpZ24oe30sIGV4dHJhY3RDb25uZWN0aW9uQXR0cmlidXRlT3JMb2coY2Vuc29yZWRVcmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfTkFNRSwgaG9zdG5hbWUsICdob3N0bmFtZScpKSk7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gZ2V0UG9ydCh1cmxQYXJ0cy5wb3J0ID8gcGFyc2VJbnQodXJsUGFydHMucG9ydCkgOiB1bmRlZmluZWQsIHByb3RvY29sKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyhjZW5zb3JlZFVybCwgc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9QT1JULCBwb3J0LCAncG9ydCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGVycm9yIHdoaWxlIGV4dHJhY3RpbmcgY29ubmVjdGlvbiBkZXRhaWxzIGZyb20gY29ubmVjdGlvbiB1cmwnLCB7XG4gICAgICAgICAgICAgICAgY2Vuc29yZWRVcmwsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwgPSBnZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21Vcmw7XG5jb25zdCBtYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gY29udGV4dC5zZXRWYWx1ZShJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVksIHRydWUpO1xufTtcbmV4cG9ydHMubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IG1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmc7XG5jb25zdCB1bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSAoY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBjb250ZXh0LmRlbGV0ZVZhbHVlKElTX0NPTkZJUk1fQ0hBTk5FTF9DT05URVhUX0tFWSk7XG59O1xuZXhwb3J0cy51bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSB1bm1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmc7XG5jb25zdCBpc0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHQuZ2V0VmFsdWUoSVNfQ09ORklSTV9DSEFOTkVMX0NPTlRFWFRfS0VZKSA9PT0gdHJ1ZTtcbn07XG5leHBvcnRzLmlzQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gaXNDb25maXJtQ2hhbm5lbFRyYWNpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js":</span>
<span class="cstat-no" title="statement not covered" >/*!****************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \****************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.46.1';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-amqplib';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC40Ni4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsdUJBQXVCO0FBQzlDO0FBQ0EsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjQ2LjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9IGV4cG9ydHMuUEFDS0FHRV9WRVJTSU9OID0gdm9pZCAwO1xuLy8gdGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUsIHNlZSBzY3JpcHRzL3ZlcnNpb24tdXBkYXRlLmpzXG5leHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9ICcwLjQ2LjEnO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSAnQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.46.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ })</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >};</span>
<span class="cstat-no" title="statement not covered" >;</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-09-12T12:09:10.571Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    