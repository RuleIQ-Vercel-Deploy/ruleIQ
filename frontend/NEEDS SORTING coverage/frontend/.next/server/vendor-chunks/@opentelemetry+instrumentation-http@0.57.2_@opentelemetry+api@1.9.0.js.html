
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for frontend/.next/server/vendor-chunks/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">frontend/.next/server/vendor-chunks</a> @opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/119</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/119</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a>
<a name='L56'></a><a href='#L56'>56</a>
<a name='L57'></a><a href='#L57'>57</a>
<a name='L58'></a><a href='#L58'>58</a>
<a name='L59'></a><a href='#L59'>59</a>
<a name='L60'></a><a href='#L60'>60</a>
<a name='L61'></a><a href='#L61'>61</a>
<a name='L62'></a><a href='#L62'>62</a>
<a name='L63'></a><a href='#L63'>63</a>
<a name='L64'></a><a href='#L64'>64</a>
<a name='L65'></a><a href='#L65'>65</a>
<a name='L66'></a><a href='#L66'>66</a>
<a name='L67'></a><a href='#L67'>67</a>
<a name='L68'></a><a href='#L68'>68</a>
<a name='L69'></a><a href='#L69'>69</a>
<a name='L70'></a><a href='#L70'>70</a>
<a name='L71'></a><a href='#L71'>71</a>
<a name='L72'></a><a href='#L72'>72</a>
<a name='L73'></a><a href='#L73'>73</a>
<a name='L74'></a><a href='#L74'>74</a>
<a name='L75'></a><a href='#L75'>75</a>
<a name='L76'></a><a href='#L76'>76</a>
<a name='L77'></a><a href='#L77'>77</a>
<a name='L78'></a><a href='#L78'>78</a>
<a name='L79'></a><a href='#L79'>79</a>
<a name='L80'></a><a href='#L80'>80</a>
<a name='L81'></a><a href='#L81'>81</a>
<a name='L82'></a><a href='#L82'>82</a>
<a name='L83'></a><a href='#L83'>83</a>
<a name='L84'></a><a href='#L84'>84</a>
<a name='L85'></a><a href='#L85'>85</a>
<a name='L86'></a><a href='#L86'>86</a>
<a name='L87'></a><a href='#L87'>87</a>
<a name='L88'></a><a href='#L88'>88</a>
<a name='L89'></a><a href='#L89'>89</a>
<a name='L90'></a><a href='#L90'>90</a>
<a name='L91'></a><a href='#L91'>91</a>
<a name='L92'></a><a href='#L92'>92</a>
<a name='L93'></a><a href='#L93'>93</a>
<a name='L94'></a><a href='#L94'>94</a>
<a name='L95'></a><a href='#L95'>95</a>
<a name='L96'></a><a href='#L96'>96</a>
<a name='L97'></a><a href='#L97'>97</a>
<a name='L98'></a><a href='#L98'>98</a>
<a name='L99'></a><a href='#L99'>99</a>
<a name='L100'></a><a href='#L100'>100</a>
<a name='L101'></a><a href='#L101'>101</a>
<a name='L102'></a><a href='#L102'>102</a>
<a name='L103'></a><a href='#L103'>103</a>
<a name='L104'></a><a href='#L104'>104</a>
<a name='L105'></a><a href='#L105'>105</a>
<a name='L106'></a><a href='#L106'>106</a>
<a name='L107'></a><a href='#L107'>107</a>
<a name='L108'></a><a href='#L108'>108</a>
<a name='L109'></a><a href='#L109'>109</a>
<a name='L110'></a><a href='#L110'>110</a>
<a name='L111'></a><a href='#L111'>111</a>
<a name='L112'></a><a href='#L112'>112</a>
<a name='L113'></a><a href='#L113'>113</a>
<a name='L114'></a><a href='#L114'>114</a>
<a name='L115'></a><a href='#L115'>115</a>
<a name='L116'></a><a href='#L116'>116</a>
<a name='L117'></a><a href='#L117'>117</a>
<a name='L118'></a><a href='#L118'>118</a>
<a name='L119'></a><a href='#L119'>119</a>
<a name='L120'></a><a href='#L120'>120</a>
<a name='L121'></a><a href='#L121'>121</a>
<a name='L122'></a><a href='#L122'>122</a>
<a name='L123'></a><a href='#L123'>123</a>
<a name='L124'></a><a href='#L124'>124</a>
<a name='L125'></a><a href='#L125'>125</a>
<a name='L126'></a><a href='#L126'>126</a>
<a name='L127'></a><a href='#L127'>127</a>
<a name='L128'></a><a href='#L128'>128</a>
<a name='L129'></a><a href='#L129'>129</a>
<a name='L130'></a><a href='#L130'>130</a>
<a name='L131'></a><a href='#L131'>131</a>
<a name='L132'></a><a href='#L132'>132</a>
<a name='L133'></a><a href='#L133'>133</a>
<a name='L134'></a><a href='#L134'>134</a>
<a name='L135'></a><a href='#L135'>135</a>
<a name='L136'></a><a href='#L136'>136</a>
<a name='L137'></a><a href='#L137'>137</a>
<a name='L138'></a><a href='#L138'>138</a>
<a name='L139'></a><a href='#L139'>139</a>
<a name='L140'></a><a href='#L140'>140</a>
<a name='L141'></a><a href='#L141'>141</a>
<a name='L142'></a><a href='#L142'>142</a>
<a name='L143'></a><a href='#L143'>143</a>
<a name='L144'></a><a href='#L144'>144</a>
<a name='L145'></a><a href='#L145'>145</a>
<a name='L146'></a><a href='#L146'>146</a>
<a name='L147'></a><a href='#L147'>147</a>
<a name='L148'></a><a href='#L148'>148</a>
<a name='L149'></a><a href='#L149'>149</a>
<a name='L150'></a><a href='#L150'>150</a>
<a name='L151'></a><a href='#L151'>151</a>
<a name='L152'></a><a href='#L152'>152</a>
<a name='L153'></a><a href='#L153'>153</a>
<a name='L154'></a><a href='#L154'>154</a>
<a name='L155'></a><a href='#L155'>155</a>
<a name='L156'></a><a href='#L156'>156</a>
<a name='L157'></a><a href='#L157'>157</a>
<a name='L158'></a><a href='#L158'>158</a>
<a name='L159'></a><a href='#L159'>159</a>
<a name='L160'></a><a href='#L160'>160</a>
<a name='L161'></a><a href='#L161'>161</a>
<a name='L162'></a><a href='#L162'>162</a>
<a name='L163'></a><a href='#L163'>163</a>
<a name='L164'></a><a href='#L164'>164</a>
<a name='L165'></a><a href='#L165'>165</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >"use strict";</span></span></span>
<span class="cstat-no" title="statement not covered" >/*</span>
<span class="cstat-no" title="statement not covered" > * ATTENTION: An "eval-source-map" devtool has been used.</span>
<span class="cstat-no" title="statement not covered" > * This devtool is neither made for production nor for readable output files.</span>
<span class="cstat-no" title="statement not covered" > * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.</span>
<span class="cstat-no" title="statement not covered" > * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)</span>
<span class="cstat-no" title="statement not covered" > * or disable the default devtool with "devtool: false".</span>
<span class="cstat-no" title="statement not covered" > * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).</span>
<span class="cstat-no" title="statement not covered" > */</span>
<span class="cstat-no" title="statement not covered" >exports.id = "vendor-chunks/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0";</span>
<span class="cstat-no" title="statement not covered" >exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0"];</span>
<span class="cstat-no" title="statement not covered" >exports.modules = {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js":</span>
<span class="cstat-no" title="statement not covered" >/*!***********************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \***********************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttributeNames = void 0;\n/**\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md\n */\nvar AttributeNames;\n(function (AttributeNames) {\n    AttributeNames[\"HTTP_ERROR_NAME\"] = \"http.error_name\";\n    AttributeNames[\"HTTP_ERROR_MESSAGE\"] = \"http.error_message\";\n    AttributeNames[\"HTTP_STATUS_TEXT\"] = \"http.status_text\";\n})(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));\n//# sourceMappingURL=AttributeNames.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy9lbnVtcy9BdHRyaWJ1dGVOYW1lcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDLHNCQUFzQixLQUFLO0FBQzFFIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy9lbnVtcy9BdHRyaWJ1dGVOYW1lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1zcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vdHJhY2Uvc2VtYW50aWNfY29udmVudGlvbnMvaHR0cC5tZFxuICovXG52YXIgQXR0cmlidXRlTmFtZXM7XG4oZnVuY3Rpb24gKEF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgQXR0cmlidXRlTmFtZXNbXCJIVFRQX0VSUk9SX05BTUVcIl0gPSBcImh0dHAuZXJyb3JfbmFtZVwiO1xuICAgIEF0dHJpYnV0ZU5hbWVzW1wiSFRUUF9FUlJPUl9NRVNTQUdFXCJdID0gXCJodHRwLmVycm9yX21lc3NhZ2VcIjtcbiAgICBBdHRyaWJ1dGVOYW1lc1tcIkhUVFBfU1RBVFVTX1RFWFRcIl0gPSBcImh0dHAuc3RhdHVzX3RleHRcIjtcbn0pKEF0dHJpYnV0ZU5hbWVzID0gZXhwb3J0cy5BdHRyaWJ1dGVOYW1lcyB8fCAoZXhwb3J0cy5BdHRyaWJ1dGVOYW1lcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdHRyaWJ1dGVOYW1lcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js":</span>
<span class="cstat-no" title="statement not covered" >/*!*******************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \*******************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst semver = __webpack_require__(/*! semver */ \"(instrument)/./node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst version_1 = __webpack_require__(/*! ./version */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst core_2 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js\");\n/**\n * `node:http` and `node:https` instrumentation for OpenTelemetry\n */\nclass HttpInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super('@opentelemetry/instrumentation-http', version_1.VERSION, config);\n        /** keep track on spans not ended */\n        this._spanNotEnded = new WeakSet();\n        this._semconvStability = 2 /* OLD */;\n        this._headerCapture = this._createHeaderCapture();\n        for (const entry of (0, core_2.getEnv)().OTEL_SEMCONV_STABILITY_OPT_IN) {\n            if (entry.toLowerCase() === 'http/dup') {\n                // http/dup takes highest precedence. If it is found, there is no need to read the rest of the list\n                this._semconvStability = 3 /* DUPLICATE */;\n                break;\n            }\n            else if (entry.toLowerCase() === 'http') {\n                this._semconvStability = 1 /* STABLE */;\n            }\n        }\n    }\n    _updateMetricInstruments() {\n        this._oldHttpServerDurationHistogram = this.meter.createHistogram('http.server.duration', {\n            description: 'Measures the duration of inbound HTTP requests.',\n            unit: 'ms',\n            valueType: api_1.ValueType.DOUBLE,\n        });\n        this._oldHttpClientDurationHistogram = this.meter.createHistogram('http.client.duration', {\n            description: 'Measures the duration of outbound HTTP requests.',\n            unit: 'ms',\n            valueType: api_1.ValueType.DOUBLE,\n        });\n        this._stableHttpServerDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_SERVER_REQUEST_DURATION, {\n            description: 'Duration of HTTP server requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n        this._stableHttpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {\n            description: 'Duration of HTTP client requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n    }\n    _recordServerDuration(durationMs, oldAttributes, stableAttributes) {\n        if ((this._semconvStability &amp; 2 /* OLD */) ===\n            2 /* OLD */) {\n            // old histogram is counted in MS\n            this._oldHttpServerDurationHistogram.record(durationMs, oldAttributes);\n        }\n        if ((this._semconvStability &amp; 1 /* STABLE */) ===\n            1 /* STABLE */) {\n            // stable histogram is counted in S\n            this._stableHttpServerDurationHistogram.record(durationMs / 1000, stableAttributes);\n        }\n    }\n    _recordClientDuration(durationMs, oldAttributes, stableAttributes) {\n        if ((this._semconvStability &amp; 2 /* OLD */) ===\n            2 /* OLD */) {\n            // old histogram is counted in MS\n            this._oldHttpClientDurationHistogram.record(durationMs, oldAttributes);\n        }\n        if ((this._semconvStability &amp; 1 /* STABLE */) ===\n            1 /* STABLE */) {\n            // stable histogram is counted in S\n            this._stableHttpClientDurationHistogram.record(durationMs / 1000, stableAttributes);\n        }\n    }\n    setConfig(config = {}) {\n        super.setConfig(config);\n        this._headerCapture = this._createHeaderCapture();\n    }\n    init() {\n        return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n    }\n    _getHttpInstrumentation() {\n        return new instrumentation_1.InstrumentationNodeModuleDefinition('http', ['*'], (moduleExports) =&gt; {\n            const isESM = moduleExports[Symbol.toStringTag] === 'Module';\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                const patchedRequest = this._wrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction('http'));\n                const patchedGet = this._wrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n                if (isESM) {\n                    // To handle `import http from 'http'`, which returns the default\n                    // export, we need to set `module.default.*`.\n                    moduleExports.default.request = patchedRequest;\n                    moduleExports.default.get = patchedGet;\n                }\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._wrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction('http'));\n            }\n            return moduleExports;\n        }, (moduleExports) =&gt; {\n            if (moduleExports === undefined)\n                return;\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                this._unwrap(moduleExports, 'request');\n                this._unwrap(moduleExports, 'get');\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._unwrap(moduleExports.Server.prototype, 'emit');\n            }\n        });\n    }\n    _getHttpsInstrumentation() {\n        return new instrumentation_1.InstrumentationNodeModuleDefinition('https', ['*'], (moduleExports) =&gt; {\n            const isESM = moduleExports[Symbol.toStringTag] === 'Module';\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                const patchedRequest = this._wrap(moduleExports, 'request', this._getPatchHttpsOutgoingRequestFunction('https'));\n                const patchedGet = this._wrap(moduleExports, 'get', this._getPatchHttpsOutgoingGetFunction(patchedRequest));\n                if (isESM) {\n                    // To handle `import https from 'https'`, which returns the default\n                    // export, we need to set `module.default.*`.\n                    moduleExports.default.request = patchedRequest;\n                    moduleExports.default.get = patchedGet;\n                }\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._wrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction('https'));\n            }\n            return moduleExports;\n        }, (moduleExports) =&gt; {\n            if (moduleExports === undefined)\n                return;\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                this._unwrap(moduleExports, 'request');\n                this._unwrap(moduleExports, 'get');\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._unwrap(moduleExports.Server.prototype, 'emit');\n            }\n        });\n    }\n    /**\n     * Creates spans for incoming requests, restoring spans' context if applied.\n     */\n    _getPatchIncomingRequestFunction(component) {\n        return (original) =&gt; {\n            return this._incomingRequestFunction(component, original);\n        };\n    }\n    /**\n     * Creates spans for outgoing requests, sending spans' context for distributed\n     * tracing.\n     */\n    _getPatchOutgoingRequestFunction(component) {\n        return (original) =&gt; {\n            return this._outgoingRequestFunction(component, original);\n        };\n    }\n    _getPatchOutgoingGetFunction(clientRequest) {\n        return (_original) =&gt; {\n            // Re-implement http.get. This needs to be done (instead of using\n            // getPatchOutgoingRequestFunction to patch it) because we need to\n            // set the trace context header before the returned http.ClientRequest is\n            // ended. The Node.js docs state that the only differences between\n            // request and get are that (1) get defaults to the HTTP GET method and\n            // (2) the returned request object is ended immediately. The former is\n            // already true (at least in supported Node versions up to v10), so we\n            // simply follow the latter. Ref:\n            // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback\n            // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/instrumentations/instrumentation-http.ts#L198\n            return function outgoingGetRequest(options, ...args) {\n                const req = clientRequest(options, ...args);\n                req.end();\n                return req;\n            };\n        };\n    }\n    /** Patches HTTPS outgoing requests */\n    _getPatchHttpsOutgoingRequestFunction(component) {\n        return (original) =&gt; {\n            const instrumentation = this;\n            return function httpsOutgoingRequest(\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            options, ...args) {\n                var _a;\n                // Makes sure options will have default HTTPS parameters\n                if (component === 'https' &amp;&amp;\n                    typeof options === 'object' &amp;&amp;\n                    ((_a = options === null || options === void 0 ? void 0 : options.constructor) === null || _a === void 0 ? void 0 : _a.name) !== 'URL') {\n                    options = Object.assign({}, options);\n                    instrumentation._setDefaultOptions(options);\n                }\n                return instrumentation._getPatchOutgoingRequestFunction(component)(original)(options, ...args);\n            };\n        };\n    }\n    _setDefaultOptions(options) {\n        options.protocol = options.protocol || 'https:';\n        options.port = options.port || 443;\n    }\n    /** Patches HTTPS outgoing get requests */\n    _getPatchHttpsOutgoingGetFunction(clientRequest) {\n        return (original) =&gt; {\n            const instrumentation = this;\n            return function httpsOutgoingRequest(\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            options, ...args) {\n                return instrumentation._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);\n            };\n        };\n    }\n    /**\n     * Attach event listeners to a client request to end span and add span attributes.\n     *\n     * @param request The original request object.\n     * @param span representing the current operation\n     * @param startTime representing the start time of the request to calculate duration in Metric\n     * @param oldMetricAttributes metric attributes for old semantic conventions\n     * @param stableMetricAttributes metric attributes for new semantic conventions\n     */\n    _traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes) {\n        if (this.getConfig().requestHook) {\n            this._callRequestHook(span, request);\n        }\n        /**\n         * Determines if the request has errored or the response has ended/errored.\n         */\n        let responseFinished = false;\n        /*\n         * User 'response' event listeners can be added before our listener,\n         * force our listener to be the first, so response emitter is bound\n         * before any user listeners are added to it.\n         */\n        request.prependListener('response', (response) =&gt; {\n            this._diag.debug('outgoingRequest on response()');\n            if (request.listenerCount('response') &lt;= 1) {\n                response.resume();\n            }\n            const responseAttributes = (0, utils_1.getOutgoingRequestAttributesOnResponse)(response, this._semconvStability);\n            span.setAttributes(responseAttributes);\n            oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getOutgoingRequestMetricAttributesOnResponse)(responseAttributes));\n            if (this.getConfig().responseHook) {\n                this._callResponseHook(span, response);\n            }\n            this._headerCapture.client.captureRequestHeaders(span, header =&gt; request.getHeader(header));\n            this._headerCapture.client.captureResponseHeaders(span, header =&gt; response.headers[header]);\n            api_1.context.bind(api_1.context.active(), response);\n            const endHandler = () =&gt; {\n                this._diag.debug('outgoingRequest on end()');\n                if (responseFinished) {\n                    return;\n                }\n                responseFinished = true;\n                let status;\n                if (response.aborted &amp;&amp; !response.complete) {\n                    status = { code: api_1.SpanStatusCode.ERROR };\n                }\n                else {\n                    // behaves same for new and old semconv\n                    status = {\n                        code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.CLIENT, response.statusCode),\n                    };\n                }\n                span.setStatus(status);\n                if (this.getConfig().applyCustomAttributesOnSpan) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().applyCustomAttributesOnSpan(span, request, response), () =&gt; { }, true);\n                }\n                this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n            };\n            response.on('end', endHandler);\n            // See https://github.com/open-telemetry/opentelemetry-js/pull/3625#issuecomment-1475673533\n            if (semver.lt(process.version, '16.0.0')) {\n                response.on('close', endHandler);\n            }\n            response.on(events_1.errorMonitor, (error) =&gt; {\n                this._diag.debug('outgoingRequest on error()', error);\n                if (responseFinished) {\n                    return;\n                }\n                responseFinished = true;\n                (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: error.message,\n                });\n                this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n            });\n        });\n        request.on('close', () =&gt; {\n            this._diag.debug('outgoingRequest on request close()');\n            if (request.aborted || responseFinished) {\n                return;\n            }\n            responseFinished = true;\n            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n        });\n        request.on(events_1.errorMonitor, (error) =&gt; {\n            this._diag.debug('outgoingRequest on request error()', error);\n            if (responseFinished) {\n                return;\n            }\n            responseFinished = true;\n            (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n        });\n        this._diag.debug('http.ClientRequest return request');\n        return request;\n    }\n    _incomingRequestFunction(component, original) {\n        const instrumentation = this;\n        return function incomingRequest(event, ...args) {\n            // Only traces request events\n            if (event !== 'request') {\n                return original.apply(this, [event, ...args]);\n            }\n            const request = args[0];\n            const response = args[1];\n            const method = request.method || 'GET';\n            instrumentation._diag.debug(`${component} instrumentation incomingRequest`);\n            if ((0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; { var _a, _b; return (_b = (_a = instrumentation.getConfig()).ignoreIncomingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, request); }, (e) =&gt; {\n                if (e != null) {\n                    instrumentation._diag.error('caught ignoreIncomingRequestHook error: ', e);\n                }\n            }, true)) {\n                return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () =&gt; {\n                    api_1.context.bind(api_1.context.active(), request);\n                    api_1.context.bind(api_1.context.active(), response);\n                    return original.apply(this, [event, ...args]);\n                });\n            }\n            const headers = request.headers;\n            const spanAttributes = (0, utils_1.getIncomingRequestAttributes)(request, {\n                component: component,\n                serverName: instrumentation.getConfig().serverName,\n                hookAttributes: instrumentation._callStartSpanHook(request, instrumentation.getConfig().startIncomingSpanHook),\n                semconvStability: instrumentation._semconvStability,\n            }, instrumentation._diag);\n            const spanOptions = {\n                kind: api_1.SpanKind.SERVER,\n                attributes: spanAttributes,\n            };\n            const startTime = (0, core_1.hrTime)();\n            const oldMetricAttributes = (0, utils_1.getIncomingRequestMetricAttributes)(spanAttributes);\n            // request method and url.scheme are both required span attributes\n            const stableMetricAttributes = {\n                [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: spanAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],\n                [semantic_conventions_1.ATTR_URL_SCHEME]: spanAttributes[semantic_conventions_1.ATTR_URL_SCHEME],\n            };\n            // recommended if and only if one was sent, same as span recommendation\n            if (spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] =\n                    spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];\n            }\n            const ctx = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n            const span = instrumentation._startHttpSpan(method, spanOptions, ctx);\n            const rpcMetadata = {\n                type: core_2.RPCType.HTTP,\n                span,\n            };\n            return api_1.context.with((0, core_2.setRPCMetadata)(api_1.trace.setSpan(ctx, span), rpcMetadata), () =&gt; {\n                api_1.context.bind(api_1.context.active(), request);\n                api_1.context.bind(api_1.context.active(), response);\n                if (instrumentation.getConfig().requestHook) {\n                    instrumentation._callRequestHook(span, request);\n                }\n                if (instrumentation.getConfig().responseHook) {\n                    instrumentation._callResponseHook(span, response);\n                }\n                instrumentation._headerCapture.server.captureRequestHeaders(span, header =&gt; request.headers[header]);\n                // After 'error', no further events other than 'close' should be emitted.\n                let hasError = false;\n                response.on('close', () =&gt; {\n                    if (hasError) {\n                        return;\n                    }\n                    instrumentation._onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime);\n                });\n                response.on(events_1.errorMonitor, (err) =&gt; {\n                    hasError = true;\n                    instrumentation._onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, err);\n                });\n                return (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; original.apply(this, [event, ...args]), error =&gt; {\n                    if (error) {\n                        (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);\n                        instrumentation._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n                        throw error;\n                    }\n                });\n            });\n        };\n    }\n    _outgoingRequestFunction(component, original) {\n        const instrumentation = this;\n        return function outgoingRequest(options, ...args) {\n            if (!(0, utils_1.isValidOptionsType)(options)) {\n                return original.apply(this, [options, ...args]);\n            }\n            const extraOptions = typeof args[0] === 'object' &amp;&amp;\n                (typeof options === 'string' || options instanceof url.URL)\n                ? args.shift()\n                : undefined;\n            const { method, invalidUrl, optionsParsed } = (0, utils_1.getRequestInfo)(instrumentation._diag, options, extraOptions);\n            /**\n             * Node 8's https module directly call the http one so to avoid creating\n             * 2 span for the same request we need to check that the protocol is correct\n             * See: https://github.com/nodejs/node/blob/v8.17.0/lib/https.js#L245\n             */\n            if (component === 'http' &amp;&amp;\n                semver.lt(process.version, '9.0.0') &amp;&amp;\n                optionsParsed.protocol === 'https:') {\n                return original.apply(this, [optionsParsed, ...args]);\n            }\n            if ((0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; {\n                var _a, _b;\n                return (_b = (_a = instrumentation\n                    .getConfig()).ignoreOutgoingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, optionsParsed);\n            }, (e) =&gt; {\n                if (e != null) {\n                    instrumentation._diag.error('caught ignoreOutgoingRequestHook error: ', e);\n                }\n            }, true)) {\n                return original.apply(this, [optionsParsed, ...args]);\n            }\n            const { hostname, port } = (0, utils_1.extractHostnameAndPort)(optionsParsed);\n            const attributes = (0, utils_1.getOutgoingRequestAttributes)(optionsParsed, {\n                component,\n                port,\n                hostname,\n                hookAttributes: instrumentation._callStartSpanHook(optionsParsed, instrumentation.getConfig().startOutgoingSpanHook),\n            }, instrumentation._semconvStability);\n            const startTime = (0, core_1.hrTime)();\n            const oldMetricAttributes = (0, utils_1.getOutgoingRequestMetricAttributes)(attributes);\n            // request method, server address, and server port are both required span attributes\n            const stableMetricAttributes = {\n                [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: attributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],\n                [semantic_conventions_1.ATTR_SERVER_ADDRESS]: attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS],\n                [semantic_conventions_1.ATTR_SERVER_PORT]: attributes[semantic_conventions_1.ATTR_SERVER_PORT],\n            };\n            // required if and only if one was sent, same as span requirement\n            if (attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] =\n                    attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];\n            }\n            // recommended if and only if one was sent, same as span recommendation\n            if (attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] =\n                    attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];\n            }\n            const spanOptions = {\n                kind: api_1.SpanKind.CLIENT,\n                attributes,\n            };\n            const span = instrumentation._startHttpSpan(method, spanOptions);\n            const parentContext = api_1.context.active();\n            const requestContext = api_1.trace.setSpan(parentContext, span);\n            if (!optionsParsed.headers) {\n                optionsParsed.headers = {};\n            }\n            else {\n                // Make a copy of the headers object to avoid mutating an object the\n                // caller might have a reference to.\n                optionsParsed.headers = Object.assign({}, optionsParsed.headers);\n            }\n            api_1.propagation.inject(requestContext, optionsParsed.headers);\n            return api_1.context.with(requestContext, () =&gt; {\n                /*\n                 * The response callback is registered before ClientRequest is bound,\n                 * thus it is needed to bind it before the function call.\n                 */\n                const cb = args[args.length - 1];\n                if (typeof cb === 'function') {\n                    args[args.length - 1] = api_1.context.bind(parentContext, cb);\n                }\n                const request = (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; {\n                    if (invalidUrl) {\n                        // we know that the url is invalid, there's no point in injecting context as it will fail validation.\n                        // Passing in what the user provided will give the user an error that matches what they'd see without\n                        // the instrumentation.\n                        return original.apply(this, [options, ...args]);\n                    }\n                    else {\n                        return original.apply(this, [optionsParsed, ...args]);\n                    }\n                }, error =&gt; {\n                    if (error) {\n                        (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);\n                        instrumentation._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n                        throw error;\n                    }\n                });\n                instrumentation._diag.debug(`${component} instrumentation outgoingRequest`);\n                api_1.context.bind(parentContext, request);\n                return instrumentation._traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes);\n            });\n        };\n    }\n    _onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime) {\n        const attributes = (0, utils_1.getIncomingRequestAttributesOnResponse)(request, response, this._semconvStability);\n        oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getIncomingRequestMetricAttributesOnResponse)(attributes));\n        stableMetricAttributes = Object.assign(stableMetricAttributes, (0, utils_1.getIncomingStableRequestMetricAttributesOnResponse)(attributes));\n        this._headerCapture.server.captureResponseHeaders(span, header =&gt; response.getHeader(header));\n        span.setAttributes(attributes).setStatus({\n            code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.SERVER, response.statusCode),\n        });\n        const route = attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n        if (route) {\n            span.updateName(`${request.method || 'GET'} ${route}`);\n        }\n        if (this.getConfig().applyCustomAttributesOnSpan) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().applyCustomAttributesOnSpan(span, request, response), () =&gt; { }, true);\n        }\n        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n    }\n    _onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, error) {\n        (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n        // TODO get error attributes for metrics\n        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n    }\n    _startHttpSpan(name, options, ctx = api_1.context.active()) {\n        /*\n         * If a parent is required but not present, we use a `NoopSpan` to still\n         * propagate context without recording it.\n         */\n        const requireParent = options.kind === api_1.SpanKind.CLIENT\n            ? this.getConfig().requireParentforOutgoingSpans\n            : this.getConfig().requireParentforIncomingSpans;\n        let span;\n        const currentSpan = api_1.trace.getSpan(ctx);\n        if (requireParent === true &amp;&amp; currentSpan === undefined) {\n            span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);\n        }\n        else if (requireParent === true &amp;&amp; (currentSpan === null || currentSpan === void 0 ? void 0 : currentSpan.spanContext().isRemote)) {\n            span = currentSpan;\n        }\n        else {\n            span = this.tracer.startSpan(name, options, ctx);\n        }\n        this._spanNotEnded.add(span);\n        return span;\n    }\n    _closeHttpSpan(span, spanKind, startTime, oldMetricAttributes, stableMetricAttributes) {\n        if (!this._spanNotEnded.has(span)) {\n            return;\n        }\n        span.end();\n        this._spanNotEnded.delete(span);\n        // Record metrics\n        const duration = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)()));\n        if (spanKind === api_1.SpanKind.SERVER) {\n            this._recordServerDuration(duration, oldMetricAttributes, stableMetricAttributes);\n        }\n        else if (spanKind === api_1.SpanKind.CLIENT) {\n            this._recordClientDuration(duration, oldMetricAttributes, stableMetricAttributes);\n        }\n    }\n    _callResponseHook(span, response) {\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().responseHook(span, response), () =&gt; { }, true);\n    }\n    _callRequestHook(span, request) {\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().requestHook(span, request), () =&gt; { }, true);\n    }\n    _callStartSpanHook(request, hookFunc) {\n        if (typeof hookFunc === 'function') {\n            return (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; hookFunc(request), () =&gt; { }, true);\n        }\n    }\n    _createHeaderCapture() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const config = this.getConfig();\n        return {\n            client: {\n                captureRequestHeaders: (0, utils_1.headerCapture)('request', (_c = (_b = (_a = config.headersToSpanAttributes) === null || _a === void 0 ? void 0 : _a.client) === null || _b === void 0 ? void 0 : _b.requestHeaders) !== null &amp;&amp; _c !== void 0 ? _c : []),\n                captureResponseHeaders: (0, utils_1.headerCapture)('response', (_f = (_e = (_d = config.headersToSpanAttributes) === null || _d === void 0 ? void 0 : _d.client) === null || _e === void 0 ? void 0 : _e.responseHeaders) !== null &amp;&amp; _f !== void 0 ? _f : []),\n            },\n            server: {\n                captureRequestHeaders: (0, utils_1.headerCapture)('request', (_j = (_h = (_g = config.headersToSpanAttributes) === null || _g === void 0 ? void 0 : _g.server) === null || _h === void 0 ? void 0 : _h.requestHeaders) !== null &amp;&amp; _j !== void 0 ? _j : []),\n                captureResponseHeaders: (0, utils_1.headerCapture)('response', (_m = (_l = (_k = config.headersToSpanAttributes) === null || _k === void 0 ? void 0 : _k.server) === null || _l === void 0 ? void 0 : _l.responseHeaders) !== null &amp;&amp; _m !== void 0 ? _m : []),\n            },\n        };\n    }\n}\nexports.HttpInstrumentation = HttpInstrumentation;\n//# sourceMappingURL=http.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy9odHRwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMseUlBQW9CO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxzS0FBcUI7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLDJGQUFRO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixrQkFBa0IsbUJBQU8sQ0FBQyw4TEFBVztBQUNyQywwQkFBMEIsbUJBQU8sQ0FBQyx1TUFBZ0M7QUFDbEUsZUFBZSxtQkFBTyxDQUFDLHNLQUFxQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQywrQkFBK0IsbUJBQU8sQ0FBQyw2TEFBcUM7QUFDNUUsZ0JBQWdCLG1CQUFPLENBQUMsMExBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjJfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvaHR0cC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cEluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29yZVwiKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmNvbnN0IGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiKTtcbmNvbnN0IGNvcmVfMiA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3Qgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogYG5vZGU6aHR0cGAgYW5kIGBub2RlOmh0dHBzYCBpbnN0cnVtZW50YXRpb24gZm9yIE9wZW5UZWxlbWV0cnlcbiAqL1xuY2xhc3MgSHR0cEluc3RydW1lbnRhdGlvbiBleHRlbmRzIGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCdAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cCcsIHZlcnNpb25fMS5WRVJTSU9OLCBjb25maWcpO1xuICAgICAgICAvKioga2VlcCB0cmFjayBvbiBzcGFucyBub3QgZW5kZWQgKi9cbiAgICAgICAgdGhpcy5fc3Bhbk5vdEVuZGVkID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgdGhpcy5fc2VtY29udlN0YWJpbGl0eSA9IDIgLyogT0xEICovO1xuICAgICAgICB0aGlzLl9oZWFkZXJDYXB0dXJlID0gdGhpcy5fY3JlYXRlSGVhZGVyQ2FwdHVyZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mICgwLCBjb3JlXzIuZ2V0RW52KSgpLk9URUxfU0VNQ09OVl9TVEFCSUxJVFlfT1BUX0lOKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkudG9Mb3dlckNhc2UoKSA9PT0gJ2h0dHAvZHVwJykge1xuICAgICAgICAgICAgICAgIC8vIGh0dHAvZHVwIHRha2VzIGhpZ2hlc3QgcHJlY2VkZW5jZS4gSWYgaXQgaXMgZm91bmQsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVhZCB0aGUgcmVzdCBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgPSAzIC8qIERVUExJQ0FURSAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5LnRvTG93ZXJDYXNlKCkgPT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgPSAxIC8qIFNUQUJMRSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfdXBkYXRlTWV0cmljSW5zdHJ1bWVudHMoKSB7XG4gICAgICAgIHRoaXMuX29sZEh0dHBTZXJ2ZXJEdXJhdGlvbkhpc3RvZ3JhbSA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKCdodHRwLnNlcnZlci5kdXJhdGlvbicsIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWVhc3VyZXMgdGhlIGR1cmF0aW9uIG9mIGluYm91bmQgSFRUUCByZXF1ZXN0cy4nLFxuICAgICAgICAgICAgdW5pdDogJ21zJyxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogYXBpXzEuVmFsdWVUeXBlLkRPVUJMRSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29sZEh0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbSA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKCdodHRwLmNsaWVudC5kdXJhdGlvbicsIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWVhc3VyZXMgdGhlIGR1cmF0aW9uIG9mIG91dGJvdW5kIEhUVFAgcmVxdWVzdHMuJyxcbiAgICAgICAgICAgIHVuaXQ6ICdtcycsXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGFwaV8xLlZhbHVlVHlwZS5ET1VCTEUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdGFibGVIdHRwU2VydmVyRHVyYXRpb25IaXN0b2dyYW0gPSB0aGlzLm1ldGVyLmNyZWF0ZUhpc3RvZ3JhbShzZW1hbnRpY19jb252ZW50aW9uc18xLk1FVFJJQ19IVFRQX1NFUlZFUl9SRVFVRVNUX0RVUkFUSU9OLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0R1cmF0aW9uIG9mIEhUVFAgc2VydmVyIHJlcXVlc3RzLicsXG4gICAgICAgICAgICB1bml0OiAncycsXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGFwaV8xLlZhbHVlVHlwZS5ET1VCTEUsXG4gICAgICAgICAgICBhZHZpY2U6IHtcbiAgICAgICAgICAgICAgICBleHBsaWNpdEJ1Y2tldEJvdW5kYXJpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgMC4wMDUsIDAuMDEsIDAuMDI1LCAwLjA1LCAwLjA3NSwgMC4xLCAwLjI1LCAwLjUsIDAuNzUsIDEsIDIuNSwgNSxcbiAgICAgICAgICAgICAgICAgICAgNy41LCAxMCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N0YWJsZUh0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbSA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVUUklDX0hUVFBfQ0xJRU5UX1JFUVVFU1RfRFVSQVRJT04sIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRHVyYXRpb24gb2YgSFRUUCBjbGllbnQgcmVxdWVzdHMuJyxcbiAgICAgICAgICAgIHVuaXQ6ICdzJyxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogYXBpXzEuVmFsdWVUeXBlLkRPVUJMRSxcbiAgICAgICAgICAgIGFkdmljZToge1xuICAgICAgICAgICAgICAgIGV4cGxpY2l0QnVja2V0Qm91bmRhcmllczogW1xuICAgICAgICAgICAgICAgICAgICAwLjAwNSwgMC4wMSwgMC4wMjUsIDAuMDUsIDAuMDc1LCAwLjEsIDAuMjUsIDAuNSwgMC43NSwgMSwgMi41LCA1LFxuICAgICAgICAgICAgICAgICAgICA3LjUsIDEwLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlY29yZFNlcnZlckR1cmF0aW9uKGR1cmF0aW9uTXMsIG9sZEF0dHJpYnV0ZXMsIHN0YWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCh0aGlzLl9zZW1jb252U3RhYmlsaXR5ICYgMiAvKiBPTEQgKi8pID09PVxuICAgICAgICAgICAgMiAvKiBPTEQgKi8pIHtcbiAgICAgICAgICAgIC8vIG9sZCBoaXN0b2dyYW0gaXMgY291bnRlZCBpbiBNU1xuICAgICAgICAgICAgdGhpcy5fb2xkSHR0cFNlcnZlckR1cmF0aW9uSGlzdG9ncmFtLnJlY29yZChkdXJhdGlvbk1zLCBvbGRBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgJiAxIC8qIFNUQUJMRSAqLykgPT09XG4gICAgICAgICAgICAxIC8qIFNUQUJMRSAqLykge1xuICAgICAgICAgICAgLy8gc3RhYmxlIGhpc3RvZ3JhbSBpcyBjb3VudGVkIGluIFNcbiAgICAgICAgICAgIHRoaXMuX3N0YWJsZUh0dHBTZXJ2ZXJEdXJhdGlvbkhpc3RvZ3JhbS5yZWNvcmQoZHVyYXRpb25NcyAvIDEwMDAsIHN0YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZWNvcmRDbGllbnREdXJhdGlvbihkdXJhdGlvbk1zLCBvbGRBdHRyaWJ1dGVzLCBzdGFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICgodGhpcy5fc2VtY29udlN0YWJpbGl0eSAmIDIgLyogT0xEICovKSA9PT1cbiAgICAgICAgICAgIDIgLyogT0xEICovKSB7XG4gICAgICAgICAgICAvLyBvbGQgaGlzdG9ncmFtIGlzIGNvdW50ZWQgaW4gTVNcbiAgICAgICAgICAgIHRoaXMuX29sZEh0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbS5yZWNvcmQoZHVyYXRpb25Ncywgb2xkQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0aGlzLl9zZW1jb252U3RhYmlsaXR5ICYgMSAvKiBTVEFCTEUgKi8pID09PVxuICAgICAgICAgICAgMSAvKiBTVEFCTEUgKi8pIHtcbiAgICAgICAgICAgIC8vIHN0YWJsZSBoaXN0b2dyYW0gaXMgY291bnRlZCBpbiBTXG4gICAgICAgICAgICB0aGlzLl9zdGFibGVIdHRwQ2xpZW50RHVyYXRpb25IaXN0b2dyYW0ucmVjb3JkKGR1cmF0aW9uTXMgLyAxMDAwLCBzdGFibGVBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDb25maWcoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIuc2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2hlYWRlckNhcHR1cmUgPSB0aGlzLl9jcmVhdGVIZWFkZXJDYXB0dXJlKCk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fZ2V0SHR0cHNJbnN0cnVtZW50YXRpb24oKSwgdGhpcy5fZ2V0SHR0cEluc3RydW1lbnRhdGlvbigpXTtcbiAgICB9XG4gICAgX2dldEh0dHBJbnN0cnVtZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZURlZmluaXRpb24oJ2h0dHAnLCBbJyonXSwgKG1vZHVsZUV4cG9ydHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzRVNNID0gbW9kdWxlRXhwb3J0c1tTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJztcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlT3V0Z29pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZFJlcXVlc3QgPSB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMsICdyZXF1ZXN0JywgdGhpcy5fZ2V0UGF0Y2hPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbignaHR0cCcpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkR2V0ID0gdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLCAnZ2V0JywgdGhpcy5fZ2V0UGF0Y2hPdXRnb2luZ0dldEZ1bmN0aW9uKHBhdGNoZWRSZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRVNNKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGhhbmRsZSBgaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCdgLCB3aGljaCByZXR1cm5zIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9ydCwgd2UgbmVlZCB0byBzZXQgYG1vZHVsZS5kZWZhdWx0LipgLlxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVFeHBvcnRzLmRlZmF1bHQucmVxdWVzdCA9IHBhdGNoZWRSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVFeHBvcnRzLmRlZmF1bHQuZ2V0ID0gcGF0Y2hlZEdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZUluY29taW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5TZXJ2ZXIucHJvdG90eXBlLCAnZW1pdCcsIHRoaXMuX2dldFBhdGNoSW5jb21pbmdSZXF1ZXN0RnVuY3Rpb24oJ2h0dHAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICAgICAgfSwgKG1vZHVsZUV4cG9ydHMpID0+IHtcbiAgICAgICAgICAgIGlmIChtb2R1bGVFeHBvcnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVPdXRnb2luZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgJ3JlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgJ2dldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVJbmNvbWluZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5TZXJ2ZXIucHJvdG90eXBlLCAnZW1pdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEh0dHBzSW5zdHJ1bWVudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGluc3RydW1lbnRhdGlvbl8xLkluc3RydW1lbnRhdGlvbk5vZGVNb2R1bGVEZWZpbml0aW9uKCdodHRwcycsIFsnKiddLCAobW9kdWxlRXhwb3J0cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNFU00gPSBtb2R1bGVFeHBvcnRzW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVPdXRnb2luZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkUmVxdWVzdCA9IHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgJ3JlcXVlc3QnLCB0aGlzLl9nZXRQYXRjaEh0dHBzT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oJ2h0dHBzJykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRHZXQgPSB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMsICdnZXQnLCB0aGlzLl9nZXRQYXRjaEh0dHBzT3V0Z29pbmdHZXRGdW5jdGlvbihwYXRjaGVkUmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VTTSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUbyBoYW5kbGUgYGltcG9ydCBodHRwcyBmcm9tICdodHRwcydgLCB3aGljaCByZXR1cm5zIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9ydCwgd2UgbmVlZCB0byBzZXQgYG1vZHVsZS5kZWZhdWx0LipgLlxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVFeHBvcnRzLmRlZmF1bHQucmVxdWVzdCA9IHBhdGNoZWRSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVFeHBvcnRzLmRlZmF1bHQuZ2V0ID0gcGF0Y2hlZEdldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZUluY29taW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5TZXJ2ZXIucHJvdG90eXBlLCAnZW1pdCcsIHRoaXMuX2dldFBhdGNoSW5jb21pbmdSZXF1ZXN0RnVuY3Rpb24oJ2h0dHBzJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgICAgIH0sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBpZiAobW9kdWxlRXhwb3J0cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlT3V0Z29pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsICdyZXF1ZXN0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMsICdnZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlSW5jb21pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuU2VydmVyLnByb3RvdHlwZSwgJ2VtaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgc3BhbnMgZm9yIGluY29taW5nIHJlcXVlc3RzLCByZXN0b3Jpbmcgc3BhbnMnIGNvbnRleHQgaWYgYXBwbGllZC5cbiAgICAgKi9cbiAgICBfZ2V0UGF0Y2hJbmNvbWluZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luY29taW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCwgb3JpZ2luYWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHNwYW5zIGZvciBvdXRnb2luZyByZXF1ZXN0cywgc2VuZGluZyBzcGFucycgY29udGV4dCBmb3IgZGlzdHJpYnV0ZWRcbiAgICAgKiB0cmFjaW5nLlxuICAgICAqL1xuICAgIF9nZXRQYXRjaE91dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50LCBvcmlnaW5hbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9nZXRQYXRjaE91dGdvaW5nR2V0RnVuY3Rpb24oY2xpZW50UmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gKF9vcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgLy8gUmUtaW1wbGVtZW50IGh0dHAuZ2V0LiBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgKGluc3RlYWQgb2YgdXNpbmdcbiAgICAgICAgICAgIC8vIGdldFBhdGNoT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24gdG8gcGF0Y2ggaXQpIGJlY2F1c2Ugd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gc2V0IHRoZSB0cmFjZSBjb250ZXh0IGhlYWRlciBiZWZvcmUgdGhlIHJldHVybmVkIGh0dHAuQ2xpZW50UmVxdWVzdCBpc1xuICAgICAgICAgICAgLy8gZW5kZWQuIFRoZSBOb2RlLmpzIGRvY3Mgc3RhdGUgdGhhdCB0aGUgb25seSBkaWZmZXJlbmNlcyBiZXR3ZWVuXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGFuZCBnZXQgYXJlIHRoYXQgKDEpIGdldCBkZWZhdWx0cyB0byB0aGUgSFRUUCBHRVQgbWV0aG9kIGFuZFxuICAgICAgICAgICAgLy8gKDIpIHRoZSByZXR1cm5lZCByZXF1ZXN0IG9iamVjdCBpcyBlbmRlZCBpbW1lZGlhdGVseS4gVGhlIGZvcm1lciBpc1xuICAgICAgICAgICAgLy8gYWxyZWFkeSB0cnVlIChhdCBsZWFzdCBpbiBzdXBwb3J0ZWQgTm9kZSB2ZXJzaW9ucyB1cCB0byB2MTApLCBzbyB3ZVxuICAgICAgICAgICAgLy8gc2ltcGx5IGZvbGxvdyB0aGUgbGF0dGVyLiBSZWY6XG4gICAgICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvaHR0cC5odG1sI2h0dHBfaHR0cF9nZXRfb3B0aW9uc19jYWxsYmFja1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvY2xvdWQtdHJhY2Utbm9kZWpzL2Jsb2IvbWFzdGVyL3NyYy9pbnN0cnVtZW50YXRpb25zL2luc3RydW1lbnRhdGlvbi1odHRwLnRzI0wxOThcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBvdXRnb2luZ0dldFJlcXVlc3Qob3B0aW9ucywgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcSA9IGNsaWVudFJlcXVlc3Qob3B0aW9ucywgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgcmVxLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogUGF0Y2hlcyBIVFRQUyBvdXRnb2luZyByZXF1ZXN0cyAqL1xuICAgIF9nZXRQYXRjaEh0dHBzT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gaHR0cHNPdXRnb2luZ1JlcXVlc3QoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICBvcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIE1ha2VzIHN1cmUgb3B0aW9ucyB3aWxsIGhhdmUgZGVmYXVsdCBIVFRQUyBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJ2h0dHBzJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpICE9PSAnVVJMJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fc2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX2dldFBhdGNoT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50KShvcmlnaW5hbCkob3B0aW9ucywgLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfc2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLnByb3RvY29sID0gb3B0aW9ucy5wcm90b2NvbCB8fCAnaHR0cHM6JztcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IDQ0MztcbiAgICB9XG4gICAgLyoqIFBhdGNoZXMgSFRUUFMgb3V0Z29pbmcgZ2V0IHJlcXVlc3RzICovXG4gICAgX2dldFBhdGNoSHR0cHNPdXRnb2luZ0dldEZ1bmN0aW9uKGNsaWVudFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBodHRwc091dGdvaW5nUmVxdWVzdChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgIG9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl9nZXRQYXRjaE91dGdvaW5nR2V0RnVuY3Rpb24oY2xpZW50UmVxdWVzdCkob3JpZ2luYWwpKG9wdGlvbnMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0byBhIGNsaWVudCByZXF1ZXN0IHRvIGVuZCBzcGFuIGFuZCBhZGQgc3BhbiBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBzcGFuIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIHJlcHJlc2VudGluZyB0aGUgc3RhcnQgdGltZSBvZiB0aGUgcmVxdWVzdCB0byBjYWxjdWxhdGUgZHVyYXRpb24gaW4gTWV0cmljXG4gICAgICogQHBhcmFtIG9sZE1ldHJpY0F0dHJpYnV0ZXMgbWV0cmljIGF0dHJpYnV0ZXMgZm9yIG9sZCBzZW1hbnRpYyBjb252ZW50aW9uc1xuICAgICAqIEBwYXJhbSBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzIG1ldHJpYyBhdHRyaWJ1dGVzIGZvciBuZXcgc2VtYW50aWMgY29udmVudGlvbnNcbiAgICAgKi9cbiAgICBfdHJhY2VDbGllbnRSZXF1ZXN0KHJlcXVlc3QsIHNwYW4sIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcykge1xuICAgICAgICBpZiAodGhpcy5nZXRDb25maWcoKS5yZXF1ZXN0SG9vaykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbFJlcXVlc3RIb29rKHNwYW4sIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSByZXF1ZXN0IGhhcyBlcnJvcmVkIG9yIHRoZSByZXNwb25zZSBoYXMgZW5kZWQvZXJyb3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCByZXNwb25zZUZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFVzZXIgJ3Jlc3BvbnNlJyBldmVudCBsaXN0ZW5lcnMgY2FuIGJlIGFkZGVkIGJlZm9yZSBvdXIgbGlzdGVuZXIsXG4gICAgICAgICAqIGZvcmNlIG91ciBsaXN0ZW5lciB0byBiZSB0aGUgZmlyc3QsIHNvIHJlc3BvbnNlIGVtaXR0ZXIgaXMgYm91bmRcbiAgICAgICAgICogYmVmb3JlIGFueSB1c2VyIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuXG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0LnByZXBlbmRMaXN0ZW5lcigncmVzcG9uc2UnLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RpYWcuZGVidWcoJ291dGdvaW5nUmVxdWVzdCBvbiByZXNwb25zZSgpJyk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5saXN0ZW5lckNvdW50KCdyZXNwb25zZScpIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlKShyZXNwb25zZSwgdGhpcy5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMocmVzcG9uc2VBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIG9sZE1ldHJpY0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKG9sZE1ldHJpY0F0dHJpYnV0ZXMsICgwLCB1dGlsc18xLmdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlKShyZXNwb25zZUF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldENvbmZpZygpLnJlc3BvbnNlSG9vaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxSZXNwb25zZUhvb2soc3BhbiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZS5jbGllbnQuY2FwdHVyZVJlcXVlc3RIZWFkZXJzKHNwYW4sIGhlYWRlciA9PiByZXF1ZXN0LmdldEhlYWRlcihoZWFkZXIpKTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlckNhcHR1cmUuY2xpZW50LmNhcHR1cmVSZXNwb25zZUhlYWRlcnMoc3BhbiwgaGVhZGVyID0+IHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICBhcGlfMS5jb250ZXh0LmJpbmQoYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgY29uc3QgZW5kSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWFnLmRlYnVnKCdvdXRnb2luZ1JlcXVlc3Qgb24gZW5kKCknKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBzdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQgJiYgIXJlc3BvbnNlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHsgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlaGF2ZXMgc2FtZSBmb3IgbmV3IGFuZCBvbGQgc2VtY29udlxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAoMCwgdXRpbHNfMS5wYXJzZVJlc3BvbnNlU3RhdHVzKShhcGlfMS5TcGFuS2luZC5DTElFTlQsIHJlc3BvbnNlLnN0YXR1c0NvZGUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuLnNldFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldENvbmZpZygpLmFwcGx5Q3VzdG9tQXR0cmlidXRlc09uU3Bhbikge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gdGhpcy5nZXRDb25maWcoKS5hcHBseUN1c3RvbUF0dHJpYnV0ZXNPblNwYW4oc3BhbiwgcmVxdWVzdCwgcmVzcG9uc2UpLCAoKSA9PiB7IH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNwb25zZS5vbignZW5kJywgZW5kSGFuZGxlcik7XG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L29wZW50ZWxlbWV0cnktanMvcHVsbC8zNjI1I2lzc3VlY29tbWVudC0xNDc1NjczNTMzXG4gICAgICAgICAgICBpZiAoc2VtdmVyLmx0KHByb2Nlc3MudmVyc2lvbiwgJzE2LjAuMCcpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Nsb3NlJywgZW5kSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZS5vbihldmVudHNfMS5lcnJvck1vbml0b3IsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpYWcuZGVidWcoJ291dGdvaW5nUmVxdWVzdCBvbiBlcnJvcigpJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuc2V0U3BhbldpdGhFcnJvcikoc3BhbiwgZXJyb3IsIHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5DTElFTlQsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Qub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGlhZy5kZWJ1Zygnb3V0Z29pbmdSZXF1ZXN0IG9uIHJlcXVlc3QgY2xvc2UoKScpO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYWJvcnRlZCB8fCByZXNwb25zZUZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2VGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Qub24oZXZlbnRzXzEuZXJyb3JNb25pdG9yLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RpYWcuZGVidWcoJ291dGdvaW5nUmVxdWVzdCBvbiByZXF1ZXN0IGVycm9yKCknLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuc2V0U3BhbldpdGhFcnJvcikoc3BhbiwgZXJyb3IsIHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5DTElFTlQsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kaWFnLmRlYnVnKCdodHRwLkNsaWVudFJlcXVlc3QgcmV0dXJuIHJlcXVlc3QnKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIF9pbmNvbWluZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQsIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBpbmNvbWluZ1JlcXVlc3QoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJhY2VzIHJlcXVlc3QgZXZlbnRzXG4gICAgICAgICAgICBpZiAoZXZlbnQgIT09ICdyZXF1ZXN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbZXZlbnQsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhcmdzWzFdO1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2QgfHwgJ0dFVCc7XG4gICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2RpYWcuZGVidWcoYCR7Y29tcG9uZW50fSBpbnN0cnVtZW50YXRpb24gaW5jb21pbmdSZXF1ZXN0YCk7XG4gICAgICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKSkuaWdub3JlSW5jb21pbmdSZXF1ZXN0SG9vaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHJlcXVlc3QpOyB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9kaWFnLmVycm9yKCdjYXVnaHQgaWdub3JlSW5jb21pbmdSZXF1ZXN0SG9vayBlcnJvcjogJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKCgwLCBjb3JlXzEuc3VwcHJlc3NUcmFjaW5nKShhcGlfMS5jb250ZXh0LmFjdGl2ZSgpKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LmJpbmQoYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbZXZlbnQsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnM7XG4gICAgICAgICAgICBjb25zdCBzcGFuQXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXMpKHJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJOYW1lOiBpbnN0cnVtZW50YXRpb24uZ2V0Q29uZmlnKCkuc2VydmVyTmFtZSxcbiAgICAgICAgICAgICAgICBob29rQXR0cmlidXRlczogaW5zdHJ1bWVudGF0aW9uLl9jYWxsU3RhcnRTcGFuSG9vayhyZXF1ZXN0LCBpbnN0cnVtZW50YXRpb24uZ2V0Q29uZmlnKCkuc3RhcnRJbmNvbWluZ1NwYW5Ib29rKSxcbiAgICAgICAgICAgICAgICBzZW1jb252U3RhYmlsaXR5OiBpbnN0cnVtZW50YXRpb24uX3NlbWNvbnZTdGFiaWxpdHksXG4gICAgICAgICAgICB9LCBpbnN0cnVtZW50YXRpb24uX2RpYWcpO1xuICAgICAgICAgICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNwYW5BdHRyaWJ1dGVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9ICgwLCBjb3JlXzEuaHJUaW1lKSgpO1xuICAgICAgICAgICAgY29uc3Qgb2xkTWV0cmljQXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMpKHNwYW5BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgbWV0aG9kIGFuZCB1cmwuc2NoZW1lIGFyZSBib3RoIHJlcXVpcmVkIHNwYW4gYXR0cmlidXRlc1xuICAgICAgICAgICAgY29uc3Qgc3RhYmxlTWV0cmljQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdOiBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF0sXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfU0NIRU1FXTogc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9TQ0hFTUVdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJlY29tbWVuZGVkIGlmIGFuZCBvbmx5IGlmIG9uZSB3YXMgc2VudCwgc2FtZSBhcyBzcGFuIHJlY29tbWVuZGF0aW9uXG4gICAgICAgICAgICBpZiAoc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl0pIHtcbiAgICAgICAgICAgICAgICBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dID1cbiAgICAgICAgICAgICAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdHggPSBhcGlfMS5wcm9wYWdhdGlvbi5leHRyYWN0KGFwaV8xLlJPT1RfQ09OVEVYVCwgaGVhZGVycyk7XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gaW5zdHJ1bWVudGF0aW9uLl9zdGFydEh0dHBTcGFuKG1ldGhvZCwgc3Bhbk9wdGlvbnMsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBycGNNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBjb3JlXzIuUlBDVHlwZS5IVFRQLFxuICAgICAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aCgoMCwgY29yZV8yLnNldFJQQ01ldGFkYXRhKShhcGlfMS50cmFjZS5zZXRTcGFuKGN0eCwgc3BhbiksIHJwY01ldGFkYXRhKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBhcGlfMS5jb250ZXh0LmJpbmQoYXBpXzEuY29udGV4dC5hY3RpdmUoKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVtZW50YXRpb24uZ2V0Q29uZmlnKCkucmVxdWVzdEhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9jYWxsUmVxdWVzdEhvb2soc3BhbiwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVtZW50YXRpb24uZ2V0Q29uZmlnKCkucmVzcG9uc2VIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fY2FsbFJlc3BvbnNlSG9vayhzcGFuLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5faGVhZGVyQ2FwdHVyZS5zZXJ2ZXIuY2FwdHVyZVJlcXVlc3RIZWFkZXJzKHNwYW4sIGhlYWRlciA9PiByZXF1ZXN0LmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICAgICAgLy8gQWZ0ZXIgJ2Vycm9yJywgbm8gZnVydGhlciBldmVudHMgb3RoZXIgdGhhbiAnY2xvc2UnIHNob3VsZCBiZSBlbWl0dGVkLlxuICAgICAgICAgICAgICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9vblNlcnZlclJlc3BvbnNlRmluaXNoKHJlcXVlc3QsIHJlc3BvbnNlLCBzcGFuLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKGV2ZW50c18xLmVycm9yTW9uaXRvciwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fb25TZXJ2ZXJSZXNwb25zZUVycm9yKHNwYW4sIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMsIHN0YXJ0VGltZSwgZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtldmVudCwgLi4uYXJnc10pLCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuc2V0U3BhbldpdGhFcnJvcikoc3BhbiwgZXJyb3IsIGluc3RydW1lbnRhdGlvbi5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuU0VSVkVSLCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfb3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50LCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gb3V0Z29pbmdSZXF1ZXN0KG9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNWYWxpZE9wdGlvbnNUeXBlKShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbb3B0aW9ucywgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXh0cmFPcHRpb25zID0gdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyB8fCBvcHRpb25zIGluc3RhbmNlb2YgdXJsLlVSTClcbiAgICAgICAgICAgICAgICA/IGFyZ3Muc2hpZnQoKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgeyBtZXRob2QsIGludmFsaWRVcmwsIG9wdGlvbnNQYXJzZWQgfSA9ICgwLCB1dGlsc18xLmdldFJlcXVlc3RJbmZvKShpbnN0cnVtZW50YXRpb24uX2RpYWcsIG9wdGlvbnMsIGV4dHJhT3B0aW9ucyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vZGUgOCdzIGh0dHBzIG1vZHVsZSBkaXJlY3RseSBjYWxsIHRoZSBodHRwIG9uZSBzbyB0byBhdm9pZCBjcmVhdGluZ1xuICAgICAgICAgICAgICogMiBzcGFuIGZvciB0aGUgc2FtZSByZXF1ZXN0IHdlIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGUgcHJvdG9jb2wgaXMgY29ycmVjdFxuICAgICAgICAgICAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92OC4xNy4wL2xpYi9odHRwcy5qcyNMMjQ1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgPT09ICdodHRwJyAmJlxuICAgICAgICAgICAgICAgIHNlbXZlci5sdChwcm9jZXNzLnZlcnNpb24sICc5LjAuMCcpICYmXG4gICAgICAgICAgICAgICAgb3B0aW9uc1BhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW29wdGlvbnNQYXJzZWQsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGluc3RydW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAuZ2V0Q29uZmlnKCkpLmlnbm9yZU91dGdvaW5nUmVxdWVzdEhvb2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBvcHRpb25zUGFyc2VkKTtcbiAgICAgICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2RpYWcuZXJyb3IoJ2NhdWdodCBpZ25vcmVPdXRnb2luZ1JlcXVlc3RIb29rIGVycm9yOiAnLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbb3B0aW9uc1BhcnNlZCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBob3N0bmFtZSwgcG9ydCB9ID0gKDAsIHV0aWxzXzEuZXh0cmFjdEhvc3RuYW1lQW5kUG9ydCkob3B0aW9uc1BhcnNlZCk7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlcykob3B0aW9uc1BhcnNlZCwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgICAgICAgIGhvb2tBdHRyaWJ1dGVzOiBpbnN0cnVtZW50YXRpb24uX2NhbGxTdGFydFNwYW5Ib29rKG9wdGlvbnNQYXJzZWQsIGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5zdGFydE91dGdvaW5nU3Bhbkhvb2spLFxuICAgICAgICAgICAgfSwgaW5zdHJ1bWVudGF0aW9uLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9ICgwLCBjb3JlXzEuaHJUaW1lKSgpO1xuICAgICAgICAgICAgY29uc3Qgb2xkTWV0cmljQXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMpKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgLy8gcmVxdWVzdCBtZXRob2QsIHNlcnZlciBhZGRyZXNzLCBhbmQgc2VydmVyIHBvcnQgYXJlIGJvdGggcmVxdWlyZWQgc3BhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjb25zdCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF06IGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdLFxuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX0FERFJFU1NdOiBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU10sXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfUE9SVF06IGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyByZXF1aXJlZCBpZiBhbmQgb25seSBpZiBvbmUgd2FzIHNlbnQsIHNhbWUgYXMgc3BhbiByZXF1aXJlbWVudFxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdKSB7XG4gICAgICAgICAgICAgICAgc3RhYmxlTWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV0gPVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY29tbWVuZGVkIGlmIGFuZCBvbmx5IGlmIG9uZSB3YXMgc2VudCwgc2FtZSBhcyBzcGFuIHJlY29tbWVuZGF0aW9uXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXSkge1xuICAgICAgICAgICAgICAgIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl0gPVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuQ0xJRU5ULFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3BhbiA9IGluc3RydW1lbnRhdGlvbi5fc3RhcnRIdHRwU3BhbihtZXRob2QsIHNwYW5PcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudENvbnRleHQgPSBhcGlfMS5jb250ZXh0LmFjdGl2ZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdENvbnRleHQgPSBhcGlfMS50cmFjZS5zZXRTcGFuKHBhcmVudENvbnRleHQsIHNwYW4pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zUGFyc2VkLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zUGFyc2VkLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBoZWFkZXJzIG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyBhbiBvYmplY3QgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVyIG1pZ2h0IGhhdmUgYSByZWZlcmVuY2UgdG8uXG4gICAgICAgICAgICAgICAgb3B0aW9uc1BhcnNlZC5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uc1BhcnNlZC5oZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwaV8xLnByb3BhZ2F0aW9uLmluamVjdChyZXF1ZXN0Q29udGV4dCwgb3B0aW9uc1BhcnNlZC5oZWFkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiBhcGlfMS5jb250ZXh0LndpdGgocmVxdWVzdENvbnRleHQsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFRoZSByZXNwb25zZSBjYWxsYmFjayBpcyByZWdpc3RlcmVkIGJlZm9yZSBDbGllbnRSZXF1ZXN0IGlzIGJvdW5kLFxuICAgICAgICAgICAgICAgICAqIHRodXMgaXQgaXMgbmVlZGVkIHRvIGJpbmQgaXQgYmVmb3JlIHRoZSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdID0gYXBpXzEuY29udGV4dC5iaW5kKHBhcmVudENvbnRleHQsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9ICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIHVybCBpcyBpbnZhbGlkLCB0aGVyZSdzIG5vIHBvaW50IGluIGluamVjdGluZyBjb250ZXh0IGFzIGl0IHdpbGwgZmFpbCB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzc2luZyBpbiB3aGF0IHRoZSB1c2VyIHByb3ZpZGVkIHdpbGwgZ2l2ZSB0aGUgdXNlciBhbiBlcnJvciB0aGF0IG1hdGNoZXMgd2hhdCB0aGV5J2Qgc2VlIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpbnN0cnVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW29wdGlvbnMsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbb3B0aW9uc1BhcnNlZCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnNldFNwYW5XaXRoRXJyb3IpKHNwYW4sIGVycm9yLCBpbnN0cnVtZW50YXRpb24uX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9kaWFnLmRlYnVnKGAke2NvbXBvbmVudH0gaW5zdHJ1bWVudGF0aW9uIG91dGdvaW5nUmVxdWVzdGApO1xuICAgICAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChwYXJlbnRDb250ZXh0LCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGF0aW9uLl90cmFjZUNsaWVudFJlcXVlc3QocmVxdWVzdCwgc3Bhbiwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfb25TZXJ2ZXJSZXNwb25zZUZpbmlzaChyZXF1ZXN0LCByZXNwb25zZSwgc3Bhbiwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcywgc3RhcnRUaW1lKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSkocmVxdWVzdCwgcmVzcG9uc2UsIHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICBvbGRNZXRyaWNBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihvbGRNZXRyaWNBdHRyaWJ1dGVzLCAoMCwgdXRpbHNfMS5nZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSkoYXR0cmlidXRlcykpO1xuICAgICAgICBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihzdGFibGVNZXRyaWNBdHRyaWJ1dGVzLCAoMCwgdXRpbHNfMS5nZXRJbmNvbWluZ1N0YWJsZVJlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSkoYXR0cmlidXRlcykpO1xuICAgICAgICB0aGlzLl9oZWFkZXJDYXB0dXJlLnNlcnZlci5jYXB0dXJlUmVzcG9uc2VIZWFkZXJzKHNwYW4sIGhlYWRlciA9PiByZXNwb25zZS5nZXRIZWFkZXIoaGVhZGVyKSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKS5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogKDAsIHV0aWxzXzEucGFyc2VSZXNwb25zZVN0YXR1cykoYXBpXzEuU3BhbktpbmQuU0VSVkVSLCByZXNwb25zZS5zdGF0dXNDb2RlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvdXRlID0gYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUk9VVEVdO1xuICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShgJHtyZXF1ZXN0Lm1ldGhvZCB8fCAnR0VUJ30gJHtyb3V0ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRDb25maWcoKS5hcHBseUN1c3RvbUF0dHJpYnV0ZXNPblNwYW4pIHtcbiAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB0aGlzLmdldENvbmZpZygpLmFwcGx5Q3VzdG9tQXR0cmlidXRlc09uU3BhbihzcGFuLCByZXF1ZXN0LCByZXNwb25zZSksICgpID0+IHsgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5TRVJWRVIsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIF9vblNlcnZlclJlc3BvbnNlRXJyb3Ioc3Bhbiwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcywgc3RhcnRUaW1lLCBlcnJvcikge1xuICAgICAgICAoMCwgdXRpbHNfMS5zZXRTcGFuV2l0aEVycm9yKShzcGFuLCBlcnJvciwgdGhpcy5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgIC8vIFRPRE8gZ2V0IGVycm9yIGF0dHJpYnV0ZXMgZm9yIG1ldHJpY3NcbiAgICAgICAgdGhpcy5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5TRVJWRVIsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIF9zdGFydEh0dHBTcGFuKG5hbWUsIG9wdGlvbnMsIGN0eCA9IGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgYSBwYXJlbnQgaXMgcmVxdWlyZWQgYnV0IG5vdCBwcmVzZW50LCB3ZSB1c2UgYSBgTm9vcFNwYW5gIHRvIHN0aWxsXG4gICAgICAgICAqIHByb3BhZ2F0ZSBjb250ZXh0IHdpdGhvdXQgcmVjb3JkaW5nIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVxdWlyZVBhcmVudCA9IG9wdGlvbnMua2luZCA9PT0gYXBpXzEuU3BhbktpbmQuQ0xJRU5UXG4gICAgICAgICAgICA/IHRoaXMuZ2V0Q29uZmlnKCkucmVxdWlyZVBhcmVudGZvck91dGdvaW5nU3BhbnNcbiAgICAgICAgICAgIDogdGhpcy5nZXRDb25maWcoKS5yZXF1aXJlUGFyZW50Zm9ySW5jb21pbmdTcGFucztcbiAgICAgICAgbGV0IHNwYW47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTcGFuID0gYXBpXzEudHJhY2UuZ2V0U3BhbihjdHgpO1xuICAgICAgICBpZiAocmVxdWlyZVBhcmVudCA9PT0gdHJ1ZSAmJiBjdXJyZW50U3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuID0gYXBpXzEudHJhY2Uud3JhcFNwYW5Db250ZXh0KGFwaV8xLklOVkFMSURfU1BBTl9DT05URVhUKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXF1aXJlUGFyZW50ID09PSB0cnVlICYmIChjdXJyZW50U3BhbiA9PT0gbnVsbCB8fCBjdXJyZW50U3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFNwYW4uc3BhbkNvbnRleHQoKS5pc1JlbW90ZSkpIHtcbiAgICAgICAgICAgIHNwYW4gPSBjdXJyZW50U3BhbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLnRyYWNlci5zdGFydFNwYW4obmFtZSwgb3B0aW9ucywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zcGFuTm90RW5kZWQuYWRkKHNwYW4pO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgX2Nsb3NlSHR0cFNwYW4oc3Bhbiwgc3BhbktpbmQsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3NwYW5Ob3RFbmRlZC5oYXMoc3BhbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICB0aGlzLl9zcGFuTm90RW5kZWQuZGVsZXRlKHNwYW4pO1xuICAgICAgICAvLyBSZWNvcmQgbWV0cmljc1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9ICgwLCBjb3JlXzEuaHJUaW1lVG9NaWxsaXNlY29uZHMpKCgwLCBjb3JlXzEuaHJUaW1lRHVyYXRpb24pKHN0YXJ0VGltZSwgKDAsIGNvcmVfMS5oclRpbWUpKCkpKTtcbiAgICAgICAgaWYgKHNwYW5LaW5kID09PSBhcGlfMS5TcGFuS2luZC5TRVJWRVIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZFNlcnZlckR1cmF0aW9uKGR1cmF0aW9uLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcGFuS2luZCA9PT0gYXBpXzEuU3BhbktpbmQuQ0xJRU5UKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNvcmRDbGllbnREdXJhdGlvbihkdXJhdGlvbiwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NhbGxSZXNwb25zZUhvb2soc3BhbiwgcmVzcG9uc2UpIHtcbiAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHRoaXMuZ2V0Q29uZmlnKCkucmVzcG9uc2VIb29rKHNwYW4sIHJlc3BvbnNlKSwgKCkgPT4geyB9LCB0cnVlKTtcbiAgICB9XG4gICAgX2NhbGxSZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0KSB7XG4gICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB0aGlzLmdldENvbmZpZygpLnJlcXVlc3RIb29rKHNwYW4sIHJlcXVlc3QpLCAoKSA9PiB7IH0sIHRydWUpO1xuICAgIH1cbiAgICBfY2FsbFN0YXJ0U3Bhbkhvb2socmVxdWVzdCwgaG9va0Z1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBob29rRnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBob29rRnVuYyhyZXF1ZXN0KSwgKCkgPT4geyB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY3JlYXRlSGVhZGVyQ2FwdHVyZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnQ6IHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlUmVxdWVzdEhlYWRlcnM6ICgwLCB1dGlsc18xLmhlYWRlckNhcHR1cmUpKCdyZXF1ZXN0JywgKF9jID0gKF9iID0gKF9hID0gY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVxdWVzdEhlYWRlcnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSxcbiAgICAgICAgICAgICAgICBjYXB0dXJlUmVzcG9uc2VIZWFkZXJzOiAoMCwgdXRpbHNfMS5oZWFkZXJDYXB0dXJlKSgncmVzcG9uc2UnLCAoX2YgPSAoX2UgPSAoX2QgPSBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jbGllbnQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZXNwb25zZUhlYWRlcnMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IFtdKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJ2ZXI6IHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlUmVxdWVzdEhlYWRlcnM6ICgwLCB1dGlsc18xLmhlYWRlckNhcHR1cmUpKCdyZXF1ZXN0JywgKF9qID0gKF9oID0gKF9nID0gY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuc2VydmVyKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gucmVxdWVzdEhlYWRlcnMpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IFtdKSxcbiAgICAgICAgICAgICAgICBjYXB0dXJlUmVzcG9uc2VIZWFkZXJzOiAoMCwgdXRpbHNfMS5oZWFkZXJDYXB0dXJlKSgncmVzcG9uc2UnLCAoX20gPSAoX2wgPSAoX2sgPSBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5zZXJ2ZXIpID09PSBudWxsIHx8IF9sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbC5yZXNwb25zZUhlYWRlcnMpICE9PSBudWxsICYmIF9tICE9PSB2b2lkIDAgPyBfbSA6IFtdKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwSW5zdHJ1bWVudGF0aW9uID0gSHR0cEluc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js":</span>
<span class="cstat-no" title="statement not covered" >/*!********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpInstrumentation = void 0;\nvar http_1 = __webpack_require__(/*! ./http */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js\");\nObject.defineProperty(exports, \"HttpInstrumentation\", ({ enumerable: true, get: function () { return http_1.HttpInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLHdMQUFRO0FBQzdCLHVEQUFzRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNwSSIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjJfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xudmFyIGh0dHBfMSA9IHJlcXVpcmUoXCIuL2h0dHBcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdHRwSW5zdHJ1bWVudGF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwXzEuSHR0cEluc3RydW1lbnRhdGlvbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js":</span>
<span class="cstat-no" title="statement not covered" >/*!********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.headerCapture = exports.getIncomingStableRequestMetricAttributesOnResponse = exports.getIncomingRequestMetricAttributesOnResponse = exports.getIncomingRequestAttributesOnResponse = exports.getIncomingRequestMetricAttributes = exports.getIncomingRequestAttributes = exports.getRemoteClientAddress = exports.getOutgoingRequestMetricAttributesOnResponse = exports.getOutgoingRequestAttributesOnResponse = exports.setAttributesFromHttpKind = exports.getOutgoingRequestMetricAttributes = exports.getOutgoingRequestAttributes = exports.extractHostnameAndPort = exports.isValidOptionsType = exports.getRequestInfo = exports.isCompressed = exports.setResponseContentLengthAttribute = exports.setRequestContentLengthAttribute = exports.setSpanWithError = exports.satisfiesPattern = exports.parseResponseStatus = exports.getAbsoluteUrl = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst AttributeNames_1 = __webpack_require__(/*! ./enums/AttributeNames */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js\");\nconst forwardedParse = __webpack_require__(/*! forwarded-parse */ \"(instrument)/./node_modules/.pnpm/forwarded-parse@2.1.2/node_modules/forwarded-parse/index.js\");\n/**\n * Get an absolute url\n */\nconst getAbsoluteUrl = (requestUrl, headers, fallbackProtocol = 'http:') =&gt; {\n    const reqUrlObject = requestUrl || {};\n    const protocol = reqUrlObject.protocol || fallbackProtocol;\n    const port = (reqUrlObject.port || '').toString();\n    const path = reqUrlObject.path || '/';\n    let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || 'localhost';\n    // if there is no port in host and there is a port\n    // it should be displayed if it's not 80 and 443 (default ports)\n    if (host.indexOf(':') === -1 &amp;&amp;\n        port &amp;&amp;\n        port !== '80' &amp;&amp;\n        port !== '443') {\n        host += `:${port}`;\n    }\n    return `${protocol}//${host}${path}`;\n};\nexports.getAbsoluteUrl = getAbsoluteUrl;\n/**\n * Parse status code from HTTP response. [More details](https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-http.md#status)\n */\nconst parseResponseStatus = (kind, statusCode) =&gt; {\n    const upperBound = kind === api_1.SpanKind.CLIENT ? 400 : 500;\n    // 1xx, 2xx, 3xx are OK on client and server\n    // 4xx is OK on server\n    if (statusCode &amp;&amp; statusCode &gt;= 100 &amp;&amp; statusCode &lt; upperBound) {\n        return api_1.SpanStatusCode.UNSET;\n    }\n    // All other codes are error\n    return api_1.SpanStatusCode.ERROR;\n};\nexports.parseResponseStatus = parseResponseStatus;\n/**\n * Check whether the given obj match pattern\n * @param constant e.g URL of request\n * @param pattern Match pattern\n */\nconst satisfiesPattern = (constant, pattern) =&gt; {\n    if (typeof pattern === 'string') {\n        return pattern === constant;\n    }\n    else if (pattern instanceof RegExp) {\n        return pattern.test(constant);\n    }\n    else if (typeof pattern === 'function') {\n        return pattern(constant);\n    }\n    else {\n        throw new TypeError('Pattern is in unsupported datatype');\n    }\n};\nexports.satisfiesPattern = satisfiesPattern;\n/**\n * Sets the span with the error passed in params\n * @param {Span} span the span that need to be set\n * @param {Error} error error that will be set to span\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst setSpanWithError = (span, error, semconvStability) =&gt; {\n    const message = error.message;\n    if ((semconvStability &amp; 2 /* OLD */) === 2 /* OLD */) {\n        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_NAME, error.name);\n        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_MESSAGE, message);\n    }\n    if ((semconvStability &amp; 1 /* STABLE */) ===\n        1 /* STABLE */) {\n        span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, error.name);\n    }\n    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });\n    span.recordException(error);\n};\nexports.setSpanWithError = setSpanWithError;\n/**\n * Adds attributes for request content-length and content-encoding HTTP headers\n * @param { IncomingMessage } Request object whose headers will be analyzed\n * @param { Attributes } Attributes object to be modified\n */\nconst setRequestContentLengthAttribute = (request, attributes) =&gt; {\n    const length = getContentLength(request.headers);\n    if (length === null)\n        return;\n    if ((0, exports.isCompressed)(request.headers)) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH] = length;\n    }\n    else {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;\n    }\n};\nexports.setRequestContentLengthAttribute = setRequestContentLengthAttribute;\n/**\n * Adds attributes for response content-length and content-encoding HTTP headers\n * @param { IncomingMessage } Response object whose headers will be analyzed\n * @param { Attributes } Attributes object to be modified\n *\n * @deprecated this is for an older version of semconv. It is retained for compatibility using OTEL_SEMCONV_STABILITY_OPT_IN\n */\nconst setResponseContentLengthAttribute = (response, attributes) =&gt; {\n    const length = getContentLength(response.headers);\n    if (length === null)\n        return;\n    if ((0, exports.isCompressed)(response.headers)) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH] = length;\n    }\n    else {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;\n    }\n};\nexports.setResponseContentLengthAttribute = setResponseContentLengthAttribute;\nfunction getContentLength(headers) {\n    const contentLengthHeader = headers['content-length'];\n    if (contentLengthHeader === undefined)\n        return null;\n    const contentLength = parseInt(contentLengthHeader, 10);\n    if (isNaN(contentLength))\n        return null;\n    return contentLength;\n}\nconst isCompressed = (headers) =&gt; {\n    const encoding = headers['content-encoding'];\n    return !!encoding &amp;&amp; encoding !== 'identity';\n};\nexports.isCompressed = isCompressed;\n/**\n * Mimics Node.js conversion of URL strings to RequestOptions expected by\n * `http.request` and `https.request` APIs.\n *\n * See https://github.com/nodejs/node/blob/2505e217bba05fc581b572c685c5cf280a16c5a3/lib/internal/url.js#L1415-L1437\n *\n * @param stringUrl\n * @throws TypeError if the URL is not valid.\n */\nfunction stringUrlToHttpOptions(stringUrl) {\n    // This is heavily inspired by Node.js handling of the same situation, trying\n    // to follow it as closely as possible while keeping in mind that we only\n    // deal with string URLs, not URL objects.\n    const { hostname, pathname, port, username, password, search, protocol, hash, href, origin, host, } = new URL(stringUrl);\n    const options = {\n        protocol: protocol,\n        hostname: hostname &amp;&amp; hostname[0] === '[' ? hostname.slice(1, -1) : hostname,\n        hash: hash,\n        search: search,\n        pathname: pathname,\n        path: `${pathname || ''}${search || ''}`,\n        href: href,\n        origin: origin,\n        host: host,\n    };\n    if (port !== '') {\n        options.port = Number(port);\n    }\n    if (username || password) {\n        options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;\n    }\n    return options;\n}\n/**\n * Makes sure options is an url object\n * return an object with default value and parsed options\n * @param logger component logger\n * @param options original options for the request\n * @param [extraOptions] additional options for the request\n */\nconst getRequestInfo = (logger, options, extraOptions) =&gt; {\n    let pathname;\n    let origin;\n    let optionsParsed;\n    let invalidUrl = false;\n    if (typeof options === 'string') {\n        try {\n            const convertedOptions = stringUrlToHttpOptions(options);\n            optionsParsed = convertedOptions;\n            pathname = convertedOptions.pathname || '/';\n        }\n        catch (e) {\n            invalidUrl = true;\n            logger.verbose('Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:', e);\n            // for backward compatibility with how url.parse() behaved.\n            optionsParsed = {\n                path: options,\n            };\n            pathname = optionsParsed.path || '/';\n        }\n        origin = `${optionsParsed.protocol || 'http:'}//${optionsParsed.host}`;\n        if (extraOptions !== undefined) {\n            Object.assign(optionsParsed, extraOptions);\n        }\n    }\n    else if (options instanceof url.URL) {\n        optionsParsed = {\n            protocol: options.protocol,\n            hostname: typeof options.hostname === 'string' &amp;&amp; options.hostname.startsWith('[')\n                ? options.hostname.slice(1, -1)\n                : options.hostname,\n            path: `${options.pathname || ''}${options.search || ''}`,\n        };\n        if (options.port !== '') {\n            optionsParsed.port = Number(options.port);\n        }\n        if (options.username || options.password) {\n            optionsParsed.auth = `${options.username}:${options.password}`;\n        }\n        pathname = options.pathname;\n        origin = options.origin;\n        if (extraOptions !== undefined) {\n            Object.assign(optionsParsed, extraOptions);\n        }\n    }\n    else {\n        optionsParsed = Object.assign({ protocol: options.host ? 'http:' : undefined }, options);\n        const hostname = optionsParsed.host ||\n            (optionsParsed.port != null\n                ? `${optionsParsed.hostname}${optionsParsed.port}`\n                : optionsParsed.hostname);\n        origin = `${optionsParsed.protocol || 'http:'}//${hostname}`;\n        pathname = options.pathname;\n        if (!pathname &amp;&amp; optionsParsed.path) {\n            try {\n                const parsedUrl = new URL(optionsParsed.path, origin);\n                pathname = parsedUrl.pathname || '/';\n            }\n            catch (e) {\n                pathname = '/';\n            }\n        }\n    }\n    // some packages return method in lowercase..\n    // ensure upperCase for consistency\n    const method = optionsParsed.method\n        ? optionsParsed.method.toUpperCase()\n        : 'GET';\n    return { origin, pathname, method, optionsParsed, invalidUrl };\n};\nexports.getRequestInfo = getRequestInfo;\n/**\n * Makes sure options is of type string or object\n * @param options for the request\n */\nconst isValidOptionsType = (options) =&gt; {\n    if (!options) {\n        return false;\n    }\n    const type = typeof options;\n    return type === 'string' || (type === 'object' &amp;&amp; !Array.isArray(options));\n};\nexports.isValidOptionsType = isValidOptionsType;\nconst extractHostnameAndPort = (requestOptions) =&gt; {\n    var _a;\n    if (requestOptions.hostname &amp;&amp; requestOptions.port) {\n        return { hostname: requestOptions.hostname, port: requestOptions.port };\n    }\n    const matches = ((_a = requestOptions.host) === null || _a === void 0 ? void 0 : _a.match(/^([^:/ ]+)(:\\d{1,5})?/)) || null;\n    const hostname = requestOptions.hostname || (matches === null ? 'localhost' : matches[1]);\n    let port = requestOptions.port;\n    if (!port) {\n        if (matches &amp;&amp; matches[2]) {\n            // remove the leading \":\". The extracted port would be something like \":8080\"\n            port = matches[2].substring(1);\n        }\n        else {\n            port = requestOptions.protocol === 'https:' ? '443' : '80';\n        }\n    }\n    return { hostname, port };\n};\nexports.extractHostnameAndPort = extractHostnameAndPort;\n/**\n * Returns outgoing request attributes scoped to the options passed to the request\n * @param {ParsedRequestOptions} requestOptions the same options used to make the request\n * @param {{ component: string, hostname: string, hookAttributes?: Attributes }} options used to pass data needed to create attributes\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getOutgoingRequestAttributes = (requestOptions, options, semconvStability) =&gt; {\n    var _a, _b;\n    const hostname = options.hostname;\n    const port = options.port;\n    const method = (_a = requestOptions.method) !== null &amp;&amp; _a !== void 0 ? _a : 'GET';\n    const normalizedMethod = normalizeMethod(method);\n    const headers = requestOptions.headers || {};\n    const userAgent = headers['user-agent'];\n    const urlFull = (0, exports.getAbsoluteUrl)(requestOptions, headers, `${options.component}:`);\n    const oldAttributes = {\n        [semantic_conventions_1.SEMATTRS_HTTP_URL]: urlFull,\n        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,\n        [semantic_conventions_1.SEMATTRS_HTTP_TARGET]: requestOptions.path || '/',\n        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: hostname,\n        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: (_b = headers.host) !== null &amp;&amp; _b !== void 0 ? _b : `${hostname}:${port}`,\n    };\n    const newAttributes = {\n        // Required attributes\n        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,\n        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: hostname,\n        [semantic_conventions_1.ATTR_SERVER_PORT]: Number(port),\n        [semantic_conventions_1.ATTR_URL_FULL]: urlFull,\n        // leaving out protocol version, it is not yet negotiated\n        // leaving out protocol name, it is only required when protocol version is set\n        // retries and redirects not supported\n        // Opt-in attributes left off for now\n    };\n    // conditionally required if request method required case normalization\n    if (method !== normalizedMethod) {\n        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;\n    }\n    if (userAgent !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;\n    }\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return Object.assign(newAttributes, options.hookAttributes);\n        case 2 /* OLD */:\n            return Object.assign(oldAttributes, options.hookAttributes);\n    }\n    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);\n};\nexports.getOutgoingRequestAttributes = getOutgoingRequestAttributes;\n/**\n * Returns outgoing request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getOutgoingRequestMetricAttributes = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME];\n    //TODO: http.url attribute, it should substitute any parameters to avoid high cardinality.\n    return metricAttributes;\n};\nexports.getOutgoingRequestMetricAttributes = getOutgoingRequestMetricAttributes;\n/**\n * Returns attributes related to the kind of HTTP protocol used\n * @param {string} [kind] Kind of HTTP protocol used: \"1.0\", \"1.1\", \"2\", \"SPDY\" or \"QUIC\".\n */\nconst setAttributesFromHttpKind = (kind, attributes) =&gt; {\n    if (kind) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = kind;\n        if (kind.toUpperCase() !== 'QUIC') {\n            attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_TCP;\n        }\n        else {\n            attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_UDP;\n        }\n    }\n};\nexports.setAttributesFromHttpKind = setAttributesFromHttpKind;\n/**\n * Returns outgoing request attributes scoped to the response data\n * @param {IncomingMessage} response the response object\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getOutgoingRequestAttributesOnResponse = (response, semconvStability) =&gt; {\n    const { statusCode, statusMessage, httpVersion, socket } = response;\n    const oldAttributes = {};\n    const stableAttributes = {};\n    if (statusCode != null) {\n        stableAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = statusCode;\n    }\n    if (socket) {\n        const { remoteAddress, remotePort } = socket;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;\n        // Recommended\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS] = remoteAddress;\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_PORT] = remotePort;\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = response.httpVersion;\n    }\n    (0, exports.setResponseContentLengthAttribute)(response, oldAttributes);\n    if (statusCode) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n        oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || '').toUpperCase();\n    }\n    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return stableAttributes;\n        case 2 /* OLD */:\n            return oldAttributes;\n    }\n    return Object.assign(oldAttributes, stableAttributes);\n};\nexports.getOutgoingRequestAttributesOnResponse = getOutgoingRequestAttributesOnResponse;\n/**\n * Returns outgoing request Metric attributes scoped to the response data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];\n    return metricAttributes;\n};\nexports.getOutgoingRequestMetricAttributesOnResponse = getOutgoingRequestMetricAttributesOnResponse;\nfunction parseHostHeader(hostHeader, proto) {\n    const parts = hostHeader.split(':');\n    // no semicolon implies ipv4 dotted syntax or host name without port\n    // x.x.x.x\n    // example.com\n    if (parts.length === 1) {\n        if (proto === 'http') {\n            return { host: parts[0], port: '80' };\n        }\n        if (proto === 'https') {\n            return { host: parts[0], port: '443' };\n        }\n        return { host: parts[0] };\n    }\n    // single semicolon implies ipv4 dotted syntax or host name with port\n    // x.x.x.x:yyyy\n    // example.com:yyyy\n    if (parts.length === 2) {\n        return {\n            host: parts[0],\n            port: parts[1],\n        };\n    }\n    // more than 2 parts implies ipv6 syntax with multiple colons\n    // [x:x:x:x:x:x:x:x]\n    // [x:x:x:x:x:x:x:x]:yyyy\n    if (parts[0].startsWith('[')) {\n        if (parts[parts.length - 1].endsWith(']')) {\n            if (proto === 'http') {\n                return { host: hostHeader, port: '80' };\n            }\n            if (proto === 'https') {\n                return { host: hostHeader, port: '443' };\n            }\n        }\n        else if (parts[parts.length - 2].endsWith(']')) {\n            return {\n                host: parts.slice(0, -1).join(':'),\n                port: parts[parts.length - 1],\n            };\n        }\n    }\n    // if nothing above matches just return the host header\n    return { host: hostHeader };\n}\n/**\n * Get server.address and port according to http semconv 1.27\n * https://github.com/open-telemetry/semantic-conventions/blob/bf0a2c1134f206f034408b201dbec37960ed60ec/docs/http/http-spans.md#setting-serveraddress-and-serverport-attributes\n */\nfunction getServerAddress(request, component) {\n    const forwardedHeader = request.headers['forwarded'];\n    if (forwardedHeader) {\n        for (const entry of parseForwardedHeader(forwardedHeader)) {\n            if (entry.host) {\n                return parseHostHeader(entry.host, entry.proto);\n            }\n        }\n    }\n    const xForwardedHost = request.headers['x-forwarded-host'];\n    if (typeof xForwardedHost === 'string') {\n        if (typeof request.headers['x-forwarded-proto'] === 'string') {\n            return parseHostHeader(xForwardedHost, request.headers['x-forwarded-proto']);\n        }\n        if (Array.isArray(request.headers['x-forwarded-proto'])) {\n            return parseHostHeader(xForwardedHost, request.headers['x-forwarded-proto'][0]);\n        }\n        return parseHostHeader(xForwardedHost);\n    }\n    else if (Array.isArray(xForwardedHost) &amp;&amp;\n        typeof xForwardedHost[0] === 'string' &amp;&amp;\n        xForwardedHost[0].length &gt; 0) {\n        if (typeof request.headers['x-forwarded-proto'] === 'string') {\n            return parseHostHeader(xForwardedHost[0], request.headers['x-forwarded-proto']);\n        }\n        if (Array.isArray(request.headers['x-forwarded-proto'])) {\n            return parseHostHeader(xForwardedHost[0], request.headers['x-forwarded-proto'][0]);\n        }\n        return parseHostHeader(xForwardedHost[0]);\n    }\n    const host = request.headers['host'];\n    if (typeof host === 'string' &amp;&amp; host.length &gt; 0) {\n        return parseHostHeader(host, component);\n    }\n    return null;\n}\n/**\n * Get server.address and port according to http semconv 1.27\n * https://github.com/open-telemetry/semantic-conventions/blob/bf0a2c1134f206f034408b201dbec37960ed60ec/docs/http/http-spans.md#setting-serveraddress-and-serverport-attributes\n */\nfunction getRemoteClientAddress(request) {\n    const forwardedHeader = request.headers['forwarded'];\n    if (forwardedHeader) {\n        for (const entry of parseForwardedHeader(forwardedHeader)) {\n            if (entry.for) {\n                return entry.for;\n            }\n        }\n    }\n    const xForwardedFor = request.headers['x-forwarded-for'];\n    if (typeof xForwardedFor === 'string') {\n        return xForwardedFor;\n    }\n    else if (Array.isArray(xForwardedFor)) {\n        return xForwardedFor[0];\n    }\n    const remote = request.socket.remoteAddress;\n    if (remote) {\n        return remote;\n    }\n    return null;\n}\nexports.getRemoteClientAddress = getRemoteClientAddress;\nfunction getInfoFromIncomingMessage(component, request, logger) {\n    var _a, _b;\n    try {\n        if (request.headers.host) {\n            return new URL((_a = request.url) !== null &amp;&amp; _a !== void 0 ? _a : '/', `${component}://${request.headers.host}`);\n        }\n        else {\n            const unsafeParsedUrl = new URL((_b = request.url) !== null &amp;&amp; _b !== void 0 ? _b : '/', \n            // using localhost as a workaround to still use the URL constructor for parsing\n            `${component}://localhost`);\n            // since we use localhost as a workaround, ensure we hide the rest of the properties to avoid\n            // our workaround leaking though.\n            return {\n                pathname: unsafeParsedUrl.pathname,\n                search: unsafeParsedUrl.search,\n                toString: function () {\n                    // we cannot use the result of unsafeParsedUrl.toString as it's potentially wrong.\n                    return unsafeParsedUrl.pathname + unsafeParsedUrl.search;\n                },\n            };\n        }\n    }\n    catch (e) {\n        // something is wrong, use undefined - this *should* never happen, logging\n        // for troubleshooting in case it does happen.\n        logger.verbose('Unable to get URL from request', e);\n        return {};\n    }\n}\n/**\n * Returns incoming request attributes scoped to the request data\n * @param {IncomingMessage} request the request object\n * @param {{ component: string, serverName?: string, hookAttributes?: Attributes }} options used to pass data needed to create attributes\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getIncomingRequestAttributes = (request, options, logger) =&gt; {\n    const headers = request.headers;\n    const userAgent = headers['user-agent'];\n    const ips = headers['x-forwarded-for'];\n    const httpVersion = request.httpVersion;\n    const host = headers.host;\n    const hostname = (host === null || host === void 0 ? void 0 : host.replace(/^(.*)(:[0-9]{1,5})/, '$1')) || 'localhost';\n    const method = request.method;\n    const normalizedMethod = normalizeMethod(method);\n    const serverAddress = getServerAddress(request, options.component);\n    const serverName = options.serverName;\n    const remoteClientAddress = getRemoteClientAddress(request);\n    const newAttributes = {\n        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,\n        [semantic_conventions_1.ATTR_URL_SCHEME]: options.component,\n        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.host,\n        [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: request.socket.remoteAddress,\n        [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: request.socket.remotePort,\n        [semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]: request.httpVersion,\n        [semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL]: userAgent,\n    };\n    const parsedUrl = getInfoFromIncomingMessage(options.component, request, logger);\n    if ((parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) != null) {\n        newAttributes[semantic_conventions_1.ATTR_URL_PATH] = parsedUrl.pathname;\n    }\n    if (remoteClientAddress != null) {\n        newAttributes[semantic_conventions_1.ATTR_CLIENT_ADDRESS] = remoteClientAddress;\n    }\n    if ((serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.port) != null) {\n        newAttributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverAddress.port);\n    }\n    // conditionally required if request method required case normalization\n    if (method !== normalizedMethod) {\n        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;\n    }\n    const oldAttributes = {\n        [semantic_conventions_1.SEMATTRS_HTTP_URL]: parsedUrl.toString(),\n        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: host,\n        [semantic_conventions_1.SEMATTRS_NET_HOST_NAME]: hostname,\n        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,\n        [semantic_conventions_1.SEMATTRS_HTTP_SCHEME]: options.component,\n    };\n    if (typeof ips === 'string') {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_CLIENT_IP] = ips.split(',')[0];\n    }\n    if (typeof serverName === 'string') {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_SERVER_NAME] = serverName;\n    }\n    if (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_TARGET] =\n            (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) + (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.search) || '/';\n    }\n    if (userAgent !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;\n    }\n    (0, exports.setRequestContentLengthAttribute)(request, oldAttributes);\n    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);\n    switch (options.semconvStability) {\n        case 1 /* STABLE */:\n            return Object.assign(newAttributes, options.hookAttributes);\n        case 2 /* OLD */:\n            return Object.assign(oldAttributes, options.hookAttributes);\n    }\n    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);\n};\nexports.getIncomingRequestAttributes = getIncomingRequestAttributes;\n/**\n * Returns incoming request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n * @param {{ component: string }} options used to pass data needed to create attributes\n */\nconst getIncomingRequestMetricAttributes = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];\n    //TODO: http.target attribute, it should substitute any parameters to avoid high cardinality.\n    return metricAttributes;\n};\nexports.getIncomingRequestMetricAttributes = getIncomingRequestMetricAttributes;\n/**\n * Returns incoming request attributes scoped to the response data\n * @param {(ServerResponse &amp; { socket: Socket; })} response the response object\n */\nconst getIncomingRequestAttributesOnResponse = (request, response, semconvStability) =&gt; {\n    // take socket from the request,\n    // since it may be detached from the response object in keep-alive mode\n    const { socket } = request;\n    const { statusCode, statusMessage } = response;\n    const newAttributes = {\n        [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: statusCode,\n    };\n    const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());\n    const oldAttributes = {};\n    if (socket) {\n        const { localAddress, localPort, remoteAddress, remotePort } = socket;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_IP] = localAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = localPort;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;\n    }\n    oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n    oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || '').toUpperCase();\n    if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP &amp;&amp; rpcMetadata.route !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = rpcMetadata.route;\n        newAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = rpcMetadata.route;\n    }\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return newAttributes;\n        case 2 /* OLD */:\n            return oldAttributes;\n    }\n    return Object.assign(oldAttributes, newAttributes);\n};\nexports.getIncomingRequestAttributesOnResponse = getIncomingRequestAttributesOnResponse;\n/**\n * Returns incoming request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getIncomingRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT];\n    if (spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] !== undefined) {\n        metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n    }\n    return metricAttributes;\n};\nexports.getIncomingRequestMetricAttributesOnResponse = getIncomingRequestMetricAttributesOnResponse;\nconst getIncomingStableRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] !== undefined) {\n        metricAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n    }\n    // required if and only if one was sent, same as span requirement\n    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {\n        metricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] =\n            spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];\n    }\n    return metricAttributes;\n};\nexports.getIncomingStableRequestMetricAttributesOnResponse = getIncomingStableRequestMetricAttributesOnResponse;\nfunction headerCapture(type, headers) {\n    const normalizedHeaders = new Map();\n    for (let i = 0, len = headers.length; i &lt; len; i++) {\n        const capturedHeader = headers[i].toLowerCase();\n        normalizedHeaders.set(capturedHeader, capturedHeader.replace(/-/g, '_'));\n    }\n    return (span, getHeader) =&gt; {\n        for (const capturedHeader of normalizedHeaders.keys()) {\n            const value = getHeader(capturedHeader);\n            if (value === undefined) {\n                continue;\n            }\n            const normalizedHeader = normalizedHeaders.get(capturedHeader);\n            const key = `http.${type}.header.${normalizedHeader}`;\n            if (typeof value === 'string') {\n                span.setAttribute(key, [value]);\n            }\n            else if (Array.isArray(value)) {\n                span.setAttribute(key, value);\n            }\n            else {\n                span.setAttribute(key, [value]);\n            }\n        }\n    };\n}\nexports.headerCapture = headerCapture;\nconst KNOWN_METHODS = new Set([\n    // methods from https://www.rfc-editor.org/rfc/rfc9110.html#name-methods\n    'GET',\n    'HEAD',\n    'POST',\n    'PUT',\n    'DELETE',\n    'CONNECT',\n    'OPTIONS',\n    'TRACE',\n    // PATCH from https://www.rfc-editor.org/rfc/rfc5789.html\n    'PATCH',\n]);\nfunction normalizeMethod(method) {\n    if (method == null) {\n        return 'GET';\n    }\n    const upper = method.toUpperCase();\n    if (KNOWN_METHODS.has(upper)) {\n        return upper;\n    }\n    return '_OTHER';\n}\nfunction parseForwardedHeader(header) {\n    try {\n        return forwardedParse(header);\n    }\n    catch (_a) {\n        return [];\n    }\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRywwREFBMEQsR0FBRyxvREFBb0QsR0FBRyw4Q0FBOEMsR0FBRywwQ0FBMEMsR0FBRyxvQ0FBb0MsR0FBRyw4QkFBOEIsR0FBRyxvREFBb0QsR0FBRyw4Q0FBOEMsR0FBRyxpQ0FBaUMsR0FBRywwQ0FBMEMsR0FBRyxvQ0FBb0MsR0FBRyw4QkFBOEIsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyx5Q0FBeUMsR0FBRyx3Q0FBd0MsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0I7QUFDajBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyx5SUFBb0I7QUFDMUMsK0JBQStCLG1CQUFPLENBQUMsNkxBQXFDO0FBQzVFLGVBQWUsbUJBQU8sQ0FBQyxzS0FBcUI7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLHlCQUF5QixtQkFBTyxDQUFDLHdOQUF3QjtBQUN6RCx1QkFBdUIsbUJBQU8sQ0FBQyxzSEFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQSxjQUFjLFNBQVMsSUFBSSxLQUFLLEVBQUUsS0FBSztBQUN2QztBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oZWFkZXJDYXB0dXJlID0gZXhwb3J0cy5nZXRJbmNvbWluZ1N0YWJsZVJlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSBleHBvcnRzLmdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlID0gZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzID0gZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzID0gZXhwb3J0cy5nZXRSZW1vdGVDbGllbnRBZGRyZXNzID0gZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSBleHBvcnRzLnNldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQgPSBleHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMgPSBleHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSBleHBvcnRzLmV4dHJhY3RIb3N0bmFtZUFuZFBvcnQgPSBleHBvcnRzLmlzVmFsaWRPcHRpb25zVHlwZSA9IGV4cG9ydHMuZ2V0UmVxdWVzdEluZm8gPSBleHBvcnRzLmlzQ29tcHJlc3NlZCA9IGV4cG9ydHMuc2V0UmVzcG9uc2VDb250ZW50TGVuZ3RoQXR0cmlidXRlID0gZXhwb3J0cy5zZXRSZXF1ZXN0Q29udGVudExlbmd0aEF0dHJpYnV0ZSA9IGV4cG9ydHMuc2V0U3BhbldpdGhFcnJvciA9IGV4cG9ydHMuc2F0aXNmaWVzUGF0dGVybiA9IGV4cG9ydHMucGFyc2VSZXNwb25zZVN0YXR1cyA9IGV4cG9ydHMuZ2V0QWJzb2x1dGVVcmwgPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuY29uc3Qgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IEF0dHJpYnV0ZU5hbWVzXzEgPSByZXF1aXJlKFwiLi9lbnVtcy9BdHRyaWJ1dGVOYW1lc1wiKTtcbmNvbnN0IGZvcndhcmRlZFBhcnNlID0gcmVxdWlyZShcImZvcndhcmRlZC1wYXJzZVwiKTtcbi8qKlxuICogR2V0IGFuIGFic29sdXRlIHVybFxuICovXG5jb25zdCBnZXRBYnNvbHV0ZVVybCA9IChyZXF1ZXN0VXJsLCBoZWFkZXJzLCBmYWxsYmFja1Byb3RvY29sID0gJ2h0dHA6JykgPT4ge1xuICAgIGNvbnN0IHJlcVVybE9iamVjdCA9IHJlcXVlc3RVcmwgfHwge307XG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXFVcmxPYmplY3QucHJvdG9jb2wgfHwgZmFsbGJhY2tQcm90b2NvbDtcbiAgICBjb25zdCBwb3J0ID0gKHJlcVVybE9iamVjdC5wb3J0IHx8ICcnKS50b1N0cmluZygpO1xuICAgIGNvbnN0IHBhdGggPSByZXFVcmxPYmplY3QucGF0aCB8fCAnLyc7XG4gICAgbGV0IGhvc3QgPSByZXFVcmxPYmplY3QuaG9zdCB8fCByZXFVcmxPYmplY3QuaG9zdG5hbWUgfHwgaGVhZGVycy5ob3N0IHx8ICdsb2NhbGhvc3QnO1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIHBvcnQgaW4gaG9zdCBhbmQgdGhlcmUgaXMgYSBwb3J0XG4gICAgLy8gaXQgc2hvdWxkIGJlIGRpc3BsYXllZCBpZiBpdCdzIG5vdCA4MCBhbmQgNDQzIChkZWZhdWx0IHBvcnRzKVxuICAgIGlmIChob3N0LmluZGV4T2YoJzonKSA9PT0gLTEgJiZcbiAgICAgICAgcG9ydCAmJlxuICAgICAgICBwb3J0ICE9PSAnODAnICYmXG4gICAgICAgIHBvcnQgIT09ICc0NDMnKSB7XG4gICAgICAgIGhvc3QgKz0gYDoke3BvcnR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0fSR7cGF0aH1gO1xufTtcbmV4cG9ydHMuZ2V0QWJzb2x1dGVVcmwgPSBnZXRBYnNvbHV0ZVVybDtcbi8qKlxuICogUGFyc2Ugc3RhdHVzIGNvZGUgZnJvbSBIVFRQIHJlc3BvbnNlLiBbTW9yZSBkZXRhaWxzXShodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1zcGVjaWZpY2F0aW9uL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vZGF0YS1odHRwLm1kI3N0YXR1cylcbiAqL1xuY29uc3QgcGFyc2VSZXNwb25zZVN0YXR1cyA9IChraW5kLCBzdGF0dXNDb2RlKSA9PiB7XG4gICAgY29uc3QgdXBwZXJCb3VuZCA9IGtpbmQgPT09IGFwaV8xLlNwYW5LaW5kLkNMSUVOVCA/IDQwMCA6IDUwMDtcbiAgICAvLyAxeHgsIDJ4eCwgM3h4IGFyZSBPSyBvbiBjbGllbnQgYW5kIHNlcnZlclxuICAgIC8vIDR4eCBpcyBPSyBvbiBzZXJ2ZXJcbiAgICBpZiAoc3RhdHVzQ29kZSAmJiBzdGF0dXNDb2RlID49IDEwMCAmJiBzdGF0dXNDb2RlIDwgdXBwZXJCb3VuZCkge1xuICAgICAgICByZXR1cm4gYXBpXzEuU3BhblN0YXR1c0NvZGUuVU5TRVQ7XG4gICAgfVxuICAgIC8vIEFsbCBvdGhlciBjb2RlcyBhcmUgZXJyb3JcbiAgICByZXR1cm4gYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1I7XG59O1xuZXhwb3J0cy5wYXJzZVJlc3BvbnNlU3RhdHVzID0gcGFyc2VSZXNwb25zZVN0YXR1cztcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gb2JqIG1hdGNoIHBhdHRlcm5cbiAqIEBwYXJhbSBjb25zdGFudCBlLmcgVVJMIG9mIHJlcXVlc3RcbiAqIEBwYXJhbSBwYXR0ZXJuIE1hdGNoIHBhdHRlcm5cbiAqL1xuY29uc3Qgc2F0aXNmaWVzUGF0dGVybiA9IChjb25zdGFudCwgcGF0dGVybikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4gPT09IGNvbnN0YW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoY29uc3RhbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcGF0dGVybihjb25zdGFudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXR0ZXJuIGlzIGluIHVuc3VwcG9ydGVkIGRhdGF0eXBlJyk7XG4gICAgfVxufTtcbmV4cG9ydHMuc2F0aXNmaWVzUGF0dGVybiA9IHNhdGlzZmllc1BhdHRlcm47XG4vKipcbiAqIFNldHMgdGhlIHNwYW4gd2l0aCB0aGUgZXJyb3IgcGFzc2VkIGluIHBhcmFtc1xuICogQHBhcmFtIHtTcGFufSBzcGFuIHRoZSBzcGFuIHRoYXQgbmVlZCB0byBiZSBzZXRcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIGVycm9yIHRoYXQgd2lsbCBiZSBzZXQgdG8gc3BhblxuICogQHBhcmFtIHtTZW1jb252U3RhYmlsaXR5fSBzZW1jb252U3RhYmlsaXR5IGRldGVybWluZXMgd2hpY2ggc2VtY29udiB2ZXJzaW9uIHRvIHVzZVxuICovXG5jb25zdCBzZXRTcGFuV2l0aEVycm9yID0gKHNwYW4sIGVycm9yLCBzZW1jb252U3RhYmlsaXR5KSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgaWYgKChzZW1jb252U3RhYmlsaXR5ICYgMiAvKiBPTEQgKi8pID09PSAyIC8qIE9MRCAqLykge1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShBdHRyaWJ1dGVOYW1lc18xLkF0dHJpYnV0ZU5hbWVzLkhUVFBfRVJST1JfTkFNRSwgZXJyb3IubmFtZSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKEF0dHJpYnV0ZU5hbWVzXzEuQXR0cmlidXRlTmFtZXMuSFRUUF9FUlJPUl9NRVNTQUdFLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKChzZW1jb252U3RhYmlsaXR5ICYgMSAvKiBTVEFCTEUgKi8pID09PVxuICAgICAgICAxIC8qIFNUQUJMRSAqLykge1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfRVJST1JfVFlQRSwgZXJyb3IubmFtZSk7XG4gICAgfVxuICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsIG1lc3NhZ2UgfSk7XG4gICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyb3IpO1xufTtcbmV4cG9ydHMuc2V0U3BhbldpdGhFcnJvciA9IHNldFNwYW5XaXRoRXJyb3I7XG4vKipcbiAqIEFkZHMgYXR0cmlidXRlcyBmb3IgcmVxdWVzdCBjb250ZW50LWxlbmd0aCBhbmQgY29udGVudC1lbmNvZGluZyBIVFRQIGhlYWRlcnNcbiAqIEBwYXJhbSB7IEluY29taW5nTWVzc2FnZSB9IFJlcXVlc3Qgb2JqZWN0IHdob3NlIGhlYWRlcnMgd2lsbCBiZSBhbmFseXplZFxuICogQHBhcmFtIHsgQXR0cmlidXRlcyB9IEF0dHJpYnV0ZXMgb2JqZWN0IHRvIGJlIG1vZGlmaWVkXG4gKi9cbmNvbnN0IHNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlID0gKHJlcXVlc3QsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRDb250ZW50TGVuZ3RoKHJlcXVlc3QuaGVhZGVycyk7XG4gICAgaWYgKGxlbmd0aCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICgoMCwgZXhwb3J0cy5pc0NvbXByZXNzZWQpKHJlcXVlc3QuaGVhZGVycykpIHtcbiAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUkVRVUVTVF9DT05URU5UX0xFTkdUSF0gPSBsZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIX1VOQ09NUFJFU1NFRF0gPSBsZW5ndGg7XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0UmVxdWVzdENvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSBzZXRSZXF1ZXN0Q29udGVudExlbmd0aEF0dHJpYnV0ZTtcbi8qKlxuICogQWRkcyBhdHRyaWJ1dGVzIGZvciByZXNwb25zZSBjb250ZW50LWxlbmd0aCBhbmQgY29udGVudC1lbmNvZGluZyBIVFRQIGhlYWRlcnNcbiAqIEBwYXJhbSB7IEluY29taW5nTWVzc2FnZSB9IFJlc3BvbnNlIG9iamVjdCB3aG9zZSBoZWFkZXJzIHdpbGwgYmUgYW5hbHl6ZWRcbiAqIEBwYXJhbSB7IEF0dHJpYnV0ZXMgfSBBdHRyaWJ1dGVzIG9iamVjdCB0byBiZSBtb2RpZmllZFxuICpcbiAqIEBkZXByZWNhdGVkIHRoaXMgaXMgZm9yIGFuIG9sZGVyIHZlcnNpb24gb2Ygc2VtY29udi4gSXQgaXMgcmV0YWluZWQgZm9yIGNvbXBhdGliaWxpdHkgdXNpbmcgT1RFTF9TRU1DT05WX1NUQUJJTElUWV9PUFRfSU5cbiAqL1xuY29uc3Qgc2V0UmVzcG9uc2VDb250ZW50TGVuZ3RoQXR0cmlidXRlID0gKHJlc3BvbnNlLCBhdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0Q29udGVudExlbmd0aChyZXNwb25zZS5oZWFkZXJzKTtcbiAgICBpZiAobGVuZ3RoID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCgwLCBleHBvcnRzLmlzQ29tcHJlc3NlZCkocmVzcG9uc2UuaGVhZGVycykpIHtcbiAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUkVTUE9OU0VfQ09OVEVOVF9MRU5HVEhdID0gbGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUkVTUE9OU0VfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VEXSA9IGxlbmd0aDtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSBzZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGU7XG5mdW5jdGlvbiBnZXRDb250ZW50TGVuZ3RoKGhlYWRlcnMpIHtcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoSGVhZGVyID0gaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICBpZiAoY29udGVudExlbmd0aEhlYWRlciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcGFyc2VJbnQoY29udGVudExlbmd0aEhlYWRlciwgMTApO1xuICAgIGlmIChpc05hTihjb250ZW50TGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGNvbnRlbnRMZW5ndGg7XG59XG5jb25zdCBpc0NvbXByZXNzZWQgPSAoaGVhZGVycykgPT4ge1xuICAgIGNvbnN0IGVuY29kaW5nID0gaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgIHJldHVybiAhIWVuY29kaW5nICYmIGVuY29kaW5nICE9PSAnaWRlbnRpdHknO1xufTtcbmV4cG9ydHMuaXNDb21wcmVzc2VkID0gaXNDb21wcmVzc2VkO1xuLyoqXG4gKiBNaW1pY3MgTm9kZS5qcyBjb252ZXJzaW9uIG9mIFVSTCBzdHJpbmdzIHRvIFJlcXVlc3RPcHRpb25zIGV4cGVjdGVkIGJ5XG4gKiBgaHR0cC5yZXF1ZXN0YCBhbmQgYGh0dHBzLnJlcXVlc3RgIEFQSXMuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzI1MDVlMjE3YmJhMDVmYzU4MWI1NzJjNjg1YzVjZjI4MGExNmM1YTMvbGliL2ludGVybmFsL3VybC5qcyNMMTQxNS1MMTQzN1xuICpcbiAqIEBwYXJhbSBzdHJpbmdVcmxcbiAqIEB0aHJvd3MgVHlwZUVycm9yIGlmIHRoZSBVUkwgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBzdHJpbmdVcmxUb0h0dHBPcHRpb25zKHN0cmluZ1VybCkge1xuICAgIC8vIFRoaXMgaXMgaGVhdmlseSBpbnNwaXJlZCBieSBOb2RlLmpzIGhhbmRsaW5nIG9mIHRoZSBzYW1lIHNpdHVhdGlvbiwgdHJ5aW5nXG4gICAgLy8gdG8gZm9sbG93IGl0IGFzIGNsb3NlbHkgYXMgcG9zc2libGUgd2hpbGUga2VlcGluZyBpbiBtaW5kIHRoYXQgd2Ugb25seVxuICAgIC8vIGRlYWwgd2l0aCBzdHJpbmcgVVJMcywgbm90IFVSTCBvYmplY3RzLlxuICAgIGNvbnN0IHsgaG9zdG5hbWUsIHBhdGhuYW1lLCBwb3J0LCB1c2VybmFtZSwgcGFzc3dvcmQsIHNlYXJjaCwgcHJvdG9jb2wsIGhhc2gsIGhyZWYsIG9yaWdpbiwgaG9zdCwgfSA9IG5ldyBVUkwoc3RyaW5nVXJsKTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgICAgIGhvc3RuYW1lOiBob3N0bmFtZSAmJiBob3N0bmFtZVswXSA9PT0gJ1snID8gaG9zdG5hbWUuc2xpY2UoMSwgLTEpIDogaG9zdG5hbWUsXG4gICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgIHNlYXJjaDogc2VhcmNoLFxuICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICAgIHBhdGg6IGAke3BhdGhuYW1lIHx8ICcnfSR7c2VhcmNoIHx8ICcnfWAsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgICAgICBob3N0OiBob3N0LFxuICAgIH07XG4gICAgaWYgKHBvcnQgIT09ICcnKSB7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IE51bWJlcihwb3J0KTtcbiAgICB9XG4gICAgaWYgKHVzZXJuYW1lIHx8IHBhc3N3b3JkKSB7XG4gICAgICAgIG9wdGlvbnMuYXV0aCA9IGAke2RlY29kZVVSSUNvbXBvbmVudCh1c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KHBhc3N3b3JkKX1gO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbi8qKlxuICogTWFrZXMgc3VyZSBvcHRpb25zIGlzIGFuIHVybCBvYmplY3RcbiAqIHJldHVybiBhbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlIGFuZCBwYXJzZWQgb3B0aW9uc1xuICogQHBhcmFtIGxvZ2dlciBjb21wb25lbnQgbG9nZ2VyXG4gKiBAcGFyYW0gb3B0aW9ucyBvcmlnaW5hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdFxuICogQHBhcmFtIFtleHRyYU9wdGlvbnNdIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3RcbiAqL1xuY29uc3QgZ2V0UmVxdWVzdEluZm8gPSAobG9nZ2VyLCBvcHRpb25zLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgICBsZXQgcGF0aG5hbWU7XG4gICAgbGV0IG9yaWdpbjtcbiAgICBsZXQgb3B0aW9uc1BhcnNlZDtcbiAgICBsZXQgaW52YWxpZFVybCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZE9wdGlvbnMgPSBzdHJpbmdVcmxUb0h0dHBPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgb3B0aW9uc1BhcnNlZCA9IGNvbnZlcnRlZE9wdGlvbnM7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGNvbnZlcnRlZE9wdGlvbnMucGF0aG5hbWUgfHwgJy8nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpbnZhbGlkVXJsID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZ2dlci52ZXJib3NlKCdVbmFibGUgdG8gcGFyc2UgVVJMIHByb3ZpZGVkIHRvIEhUVFAgcmVxdWVzdCwgdXNpbmcgZmFsbGJhY2sgdG8gZGV0ZXJtaW5lIHBhdGguIE9yaWdpbmFsIGVycm9yOicsIGUpO1xuICAgICAgICAgICAgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBob3cgdXJsLnBhcnNlKCkgYmVoYXZlZC5cbiAgICAgICAgICAgIG9wdGlvbnNQYXJzZWQgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogb3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXRobmFtZSA9IG9wdGlvbnNQYXJzZWQucGF0aCB8fCAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ2luID0gYCR7b3B0aW9uc1BhcnNlZC5wcm90b2NvbCB8fCAnaHR0cDonfS8vJHtvcHRpb25zUGFyc2VkLmhvc3R9YDtcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnNQYXJzZWQsIGV4dHJhT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIHVybC5VUkwpIHtcbiAgICAgICAgb3B0aW9uc1BhcnNlZCA9IHtcbiAgICAgICAgICAgIHByb3RvY29sOiBvcHRpb25zLnByb3RvY29sLFxuICAgICAgICAgICAgaG9zdG5hbWU6IHR5cGVvZiBvcHRpb25zLmhvc3RuYW1lID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuaG9zdG5hbWUsXG4gICAgICAgICAgICBwYXRoOiBgJHtvcHRpb25zLnBhdGhuYW1lIHx8ICcnfSR7b3B0aW9ucy5zZWFyY2ggfHwgJyd9YCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9ydCAhPT0gJycpIHtcbiAgICAgICAgICAgIG9wdGlvbnNQYXJzZWQucG9ydCA9IE51bWJlcihvcHRpb25zLnBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnVzZXJuYW1lIHx8IG9wdGlvbnMucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIG9wdGlvbnNQYXJzZWQuYXV0aCA9IGAke29wdGlvbnMudXNlcm5hbWV9OiR7b3B0aW9ucy5wYXNzd29yZH1gO1xuICAgICAgICB9XG4gICAgICAgIHBhdGhuYW1lID0gb3B0aW9ucy5wYXRobmFtZTtcbiAgICAgICAgb3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XG4gICAgICAgIGlmIChleHRyYU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zUGFyc2VkLCBleHRyYU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zUGFyc2VkID0gT2JqZWN0LmFzc2lnbih7IHByb3RvY29sOiBvcHRpb25zLmhvc3QgPyAnaHR0cDonIDogdW5kZWZpbmVkIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBob3N0bmFtZSA9IG9wdGlvbnNQYXJzZWQuaG9zdCB8fFxuICAgICAgICAgICAgKG9wdGlvbnNQYXJzZWQucG9ydCAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyBgJHtvcHRpb25zUGFyc2VkLmhvc3RuYW1lfSR7b3B0aW9uc1BhcnNlZC5wb3J0fWBcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnNQYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgICBvcmlnaW4gPSBgJHtvcHRpb25zUGFyc2VkLnByb3RvY29sIHx8ICdodHRwOid9Ly8ke2hvc3RuYW1lfWA7XG4gICAgICAgIHBhdGhuYW1lID0gb3B0aW9ucy5wYXRobmFtZTtcbiAgICAgICAgaWYgKCFwYXRobmFtZSAmJiBvcHRpb25zUGFyc2VkLnBhdGgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChvcHRpb25zUGFyc2VkLnBhdGgsIG9yaWdpbik7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWUgfHwgJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzb21lIHBhY2thZ2VzIHJldHVybiBtZXRob2QgaW4gbG93ZXJjYXNlLi5cbiAgICAvLyBlbnN1cmUgdXBwZXJDYXNlIGZvciBjb25zaXN0ZW5jeVxuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnNQYXJzZWQubWV0aG9kXG4gICAgICAgID8gb3B0aW9uc1BhcnNlZC5tZXRob2QudG9VcHBlckNhc2UoKVxuICAgICAgICA6ICdHRVQnO1xuICAgIHJldHVybiB7IG9yaWdpbiwgcGF0aG5hbWUsIG1ldGhvZCwgb3B0aW9uc1BhcnNlZCwgaW52YWxpZFVybCB9O1xufTtcbmV4cG9ydHMuZ2V0UmVxdWVzdEluZm8gPSBnZXRSZXF1ZXN0SW5mbztcbi8qKlxuICogTWFrZXMgc3VyZSBvcHRpb25zIGlzIG9mIHR5cGUgc3RyaW5nIG9yIG9iamVjdFxuICogQHBhcmFtIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0XG4gKi9cbmNvbnN0IGlzVmFsaWRPcHRpb25zVHlwZSA9IChvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvcHRpb25zO1xuICAgIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCAodHlwZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucykpO1xufTtcbmV4cG9ydHMuaXNWYWxpZE9wdGlvbnNUeXBlID0gaXNWYWxpZE9wdGlvbnNUeXBlO1xuY29uc3QgZXh0cmFjdEhvc3RuYW1lQW5kUG9ydCA9IChyZXF1ZXN0T3B0aW9ucykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVxdWVzdE9wdGlvbnMuaG9zdG5hbWUgJiYgcmVxdWVzdE9wdGlvbnMucG9ydCkge1xuICAgICAgICByZXR1cm4geyBob3N0bmFtZTogcmVxdWVzdE9wdGlvbnMuaG9zdG5hbWUsIHBvcnQ6IHJlcXVlc3RPcHRpb25zLnBvcnQgfTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hlcyA9ICgoX2EgPSByZXF1ZXN0T3B0aW9ucy5ob3N0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF0Y2goL14oW146LyBdKykoOlxcZHsxLDV9KT8vKSkgfHwgbnVsbDtcbiAgICBjb25zdCBob3N0bmFtZSA9IHJlcXVlc3RPcHRpb25zLmhvc3RuYW1lIHx8IChtYXRjaGVzID09PSBudWxsID8gJ2xvY2FsaG9zdCcgOiBtYXRjaGVzWzFdKTtcbiAgICBsZXQgcG9ydCA9IHJlcXVlc3RPcHRpb25zLnBvcnQ7XG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXNbMl0pIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgbGVhZGluZyBcIjpcIi4gVGhlIGV4dHJhY3RlZCBwb3J0IHdvdWxkIGJlIHNvbWV0aGluZyBsaWtlIFwiOjgwODBcIlxuICAgICAgICAgICAgcG9ydCA9IG1hdGNoZXNbMl0uc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9ydCA9IHJlcXVlc3RPcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICc0NDMnIDogJzgwJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBob3N0bmFtZSwgcG9ydCB9O1xufTtcbmV4cG9ydHMuZXh0cmFjdEhvc3RuYW1lQW5kUG9ydCA9IGV4dHJhY3RIb3N0bmFtZUFuZFBvcnQ7XG4vKipcbiAqIFJldHVybnMgb3V0Z29pbmcgcmVxdWVzdCBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB7UGFyc2VkUmVxdWVzdE9wdGlvbnN9IHJlcXVlc3RPcHRpb25zIHRoZSBzYW1lIG9wdGlvbnMgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge3sgY29tcG9uZW50OiBzdHJpbmcsIGhvc3RuYW1lOiBzdHJpbmcsIGhvb2tBdHRyaWJ1dGVzPzogQXR0cmlidXRlcyB9fSBvcHRpb25zIHVzZWQgdG8gcGFzcyBkYXRhIG5lZWRlZCB0byBjcmVhdGUgYXR0cmlidXRlc1xuICogQHBhcmFtIHtTZW1jb252U3RhYmlsaXR5fSBzZW1jb252U3RhYmlsaXR5IGRldGVybWluZXMgd2hpY2ggc2VtY29udiB2ZXJzaW9uIHRvIHVzZVxuICovXG5jb25zdCBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzID0gKHJlcXVlc3RPcHRpb25zLCBvcHRpb25zLCBzZW1jb252U3RhYmlsaXR5KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBob3N0bmFtZSA9IG9wdGlvbnMuaG9zdG5hbWU7XG4gICAgY29uc3QgcG9ydCA9IG9wdGlvbnMucG9ydDtcbiAgICBjb25zdCBtZXRob2QgPSAoX2EgPSByZXF1ZXN0T3B0aW9ucy5tZXRob2QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdHRVQnO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRNZXRob2QgPSBub3JtYWxpemVNZXRob2QobWV0aG9kKTtcbiAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdE9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBoZWFkZXJzWyd1c2VyLWFnZW50J107XG4gICAgY29uc3QgdXJsRnVsbCA9ICgwLCBleHBvcnRzLmdldEFic29sdXRlVXJsKShyZXF1ZXN0T3B0aW9ucywgaGVhZGVycywgYCR7b3B0aW9ucy5jb21wb25lbnR9OmApO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfVVJMXTogdXJsRnVsbCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9NRVRIT0RdOiBtZXRob2QsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfVEFSR0VUXTogcmVxdWVzdE9wdGlvbnMucGF0aCB8fCAnLycsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX05BTUVdOiBob3N0bmFtZSxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9IT1NUXTogKF9iID0gaGVhZGVycy5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBgJHtob3N0bmFtZX06JHtwb3J0fWAsXG4gICAgfTtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgICAvLyBSZXF1aXJlZCBhdHRyaWJ1dGVzXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF06IG5vcm1hbGl6ZWRNZXRob2QsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX0FERFJFU1NdOiBob3N0bmFtZSxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfUE9SVF06IE51bWJlcihwb3J0KSxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfRlVMTF06IHVybEZ1bGwsXG4gICAgICAgIC8vIGxlYXZpbmcgb3V0IHByb3RvY29sIHZlcnNpb24sIGl0IGlzIG5vdCB5ZXQgbmVnb3RpYXRlZFxuICAgICAgICAvLyBsZWF2aW5nIG91dCBwcm90b2NvbCBuYW1lLCBpdCBpcyBvbmx5IHJlcXVpcmVkIHdoZW4gcHJvdG9jb2wgdmVyc2lvbiBpcyBzZXRcbiAgICAgICAgLy8gcmV0cmllcyBhbmQgcmVkaXJlY3RzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgLy8gT3B0LWluIGF0dHJpYnV0ZXMgbGVmdCBvZmYgZm9yIG5vd1xuICAgIH07XG4gICAgLy8gY29uZGl0aW9uYWxseSByZXF1aXJlZCBpZiByZXF1ZXN0IG1ldGhvZCByZXF1aXJlZCBjYXNlIG5vcm1hbGl6YXRpb25cbiAgICBpZiAobWV0aG9kICE9PSBub3JtYWxpemVkTWV0aG9kKSB7XG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RfT1JJR0lOQUxdID0gbWV0aG9kO1xuICAgIH1cbiAgICBpZiAodXNlckFnZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfVVNFUl9BR0VOVF0gPSB1c2VyQWdlbnQ7XG4gICAgfVxuICAgIHN3aXRjaCAoc2VtY29udlN0YWJpbGl0eSkge1xuICAgICAgICBjYXNlIDEgLyogU1RBQkxFICovOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgb3B0aW9ucy5ob29rQXR0cmlidXRlcyk7XG4gICAgICAgIGNhc2UgMiAvKiBPTEQgKi86XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvbGRBdHRyaWJ1dGVzLCBvcHRpb25zLmhvb2tBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2xkQXR0cmlidXRlcywgbmV3QXR0cmlidXRlcywgb3B0aW9ucy5ob29rQXR0cmlidXRlcyk7XG59O1xuZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzID0gZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlcztcbi8qKlxuICogUmV0dXJucyBvdXRnb2luZyByZXF1ZXN0IE1ldHJpYyBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge0F0dHJpYnV0ZXN9IHNwYW5BdHRyaWJ1dGVzIHRoZSBzcGFuIGF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IChzcGFuQXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IG1ldHJpY0F0dHJpYnV0ZXMgPSB7fTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9NRVRIT0RdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX01FVEhPRF07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX05BTUVdID1cbiAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9OQU1FXTtcbiAgICAvL1RPRE86IGh0dHAudXJsIGF0dHJpYnV0ZSwgaXQgc2hvdWxkIHN1YnN0aXR1dGUgYW55IHBhcmFtZXRlcnMgdG8gYXZvaWQgaGlnaCBjYXJkaW5hbGl0eS5cbiAgICByZXR1cm4gbWV0cmljQXR0cmlidXRlcztcbn07XG5leHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMgPSBnZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzO1xuLyoqXG4gKiBSZXR1cm5zIGF0dHJpYnV0ZXMgcmVsYXRlZCB0byB0aGUga2luZCBvZiBIVFRQIHByb3RvY29sIHVzZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBba2luZF0gS2luZCBvZiBIVFRQIHByb3RvY29sIHVzZWQ6IFwiMS4wXCIsIFwiMS4xXCIsIFwiMlwiLCBcIlNQRFlcIiBvciBcIlFVSUNcIi5cbiAqL1xuY29uc3Qgc2V0QXR0cmlidXRlc0Zyb21IdHRwS2luZCA9IChraW5kLCBhdHRyaWJ1dGVzKSA9PiB7XG4gICAgaWYgKGtpbmQpIHtcbiAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfRkxBVk9SXSA9IGtpbmQ7XG4gICAgICAgIGlmIChraW5kLnRvVXBwZXJDYXNlKCkgIT09ICdRVUlDJykge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9UUkFOU1BPUlRdID0gc2VtYW50aWNfY29udmVudGlvbnNfMS5ORVRUUkFOU1BPUlRWQUxVRVNfSVBfVENQO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9UUkFOU1BPUlRdID0gc2VtYW50aWNfY29udmVudGlvbnNfMS5ORVRUUkFOU1BPUlRWQUxVRVNfSVBfVURQO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0QXR0cmlidXRlc0Zyb21IdHRwS2luZCA9IHNldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQ7XG4vKipcbiAqIFJldHVybnMgb3V0Z29pbmcgcmVxdWVzdCBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVzcG9uc2UgZGF0YVxuICogQHBhcmFtIHtJbmNvbWluZ01lc3NhZ2V9IHJlc3BvbnNlIHRoZSByZXNwb25zZSBvYmplY3RcbiAqIEBwYXJhbSB7U2VtY29udlN0YWJpbGl0eX0gc2VtY29udlN0YWJpbGl0eSBkZXRlcm1pbmVzIHdoaWNoIHNlbWNvbnYgdmVyc2lvbiB0byB1c2VcbiAqL1xuY29uc3QgZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSAocmVzcG9uc2UsIHNlbWNvbnZTdGFiaWxpdHkpID0+IHtcbiAgICBjb25zdCB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGh0dHBWZXJzaW9uLCBzb2NrZXQgfSA9IHJlc3BvbnNlO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBjb25zdCBzdGFibGVBdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKHN0YXR1c0NvZGUgIT0gbnVsbCkge1xuICAgICAgICBzdGFibGVBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXSA9IHN0YXR1c0NvZGU7XG4gICAgfVxuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgY29uc3QgeyByZW1vdGVBZGRyZXNzLCByZW1vdGVQb3J0IH0gPSBzb2NrZXQ7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9JUF0gPSByZW1vdGVBZGRyZXNzO1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVF0gPSByZW1vdGVQb3J0O1xuICAgICAgICAvLyBSZWNvbW1lbmRlZFxuICAgICAgICBzdGFibGVBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BFRVJfQUREUkVTU10gPSByZW1vdGVBZGRyZXNzO1xuICAgICAgICBzdGFibGVBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BFRVJfUE9SVF0gPSByZW1vdGVQb3J0O1xuICAgICAgICBzdGFibGVBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dID0gcmVzcG9uc2UuaHR0cFZlcnNpb247XG4gICAgfVxuICAgICgwLCBleHBvcnRzLnNldFJlc3BvbnNlQ29udGVudExlbmd0aEF0dHJpYnV0ZSkocmVzcG9uc2UsIG9sZEF0dHJpYnV0ZXMpO1xuICAgIGlmIChzdGF0dXNDb2RlKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbQXR0cmlidXRlTmFtZXNfMS5BdHRyaWJ1dGVOYW1lcy5IVFRQX1NUQVRVU19URVhUXSA9IChzdGF0dXNNZXNzYWdlIHx8ICcnKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICAoMCwgZXhwb3J0cy5zZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kKShodHRwVmVyc2lvbiwgb2xkQXR0cmlidXRlcyk7XG4gICAgc3dpdGNoIChzZW1jb252U3RhYmlsaXR5KSB7XG4gICAgICAgIGNhc2UgMSAvKiBTVEFCTEUgKi86XG4gICAgICAgICAgICByZXR1cm4gc3RhYmxlQXR0cmlidXRlcztcbiAgICAgICAgY2FzZSAyIC8qIE9MRCAqLzpcbiAgICAgICAgICAgIHJldHVybiBvbGRBdHRyaWJ1dGVzO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvbGRBdHRyaWJ1dGVzLCBzdGFibGVBdHRyaWJ1dGVzKTtcbn07XG5leHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlID0gZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2U7XG4vKipcbiAqIFJldHVybnMgb3V0Z29pbmcgcmVxdWVzdCBNZXRyaWMgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlc3BvbnNlIGRhdGFcbiAqIEBwYXJhbSB7QXR0cmlidXRlc30gc3BhbkF0dHJpYnV0ZXMgdGhlIHNwYW4gYXR0cmlidXRlc1xuICovXG5jb25zdCBnZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChzcGFuQXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IG1ldHJpY0F0dHJpYnV0ZXMgPSB7fTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVF0gPVxuICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX1BPUlRdO1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXSA9XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfRkxBVk9SXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9GTEFWT1JdO1xuICAgIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSBnZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZTtcbmZ1bmN0aW9uIHBhcnNlSG9zdEhlYWRlcihob3N0SGVhZGVyLCBwcm90bykge1xuICAgIGNvbnN0IHBhcnRzID0gaG9zdEhlYWRlci5zcGxpdCgnOicpO1xuICAgIC8vIG5vIHNlbWljb2xvbiBpbXBsaWVzIGlwdjQgZG90dGVkIHN5bnRheCBvciBob3N0IG5hbWUgd2l0aG91dCBwb3J0XG4gICAgLy8geC54LngueFxuICAgIC8vIGV4YW1wbGUuY29tXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAocHJvdG8gPT09ICdodHRwJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogcGFydHNbMF0sIHBvcnQ6ICc4MCcgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdG8gPT09ICdodHRwcycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IHBhcnRzWzBdLCBwb3J0OiAnNDQzJyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhvc3Q6IHBhcnRzWzBdIH07XG4gICAgfVxuICAgIC8vIHNpbmdsZSBzZW1pY29sb24gaW1wbGllcyBpcHY0IGRvdHRlZCBzeW50YXggb3IgaG9zdCBuYW1lIHdpdGggcG9ydFxuICAgIC8vIHgueC54Lng6eXl5eVxuICAgIC8vIGV4YW1wbGUuY29tOnl5eXlcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3N0OiBwYXJ0c1swXSxcbiAgICAgICAgICAgIHBvcnQ6IHBhcnRzWzFdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBtb3JlIHRoYW4gMiBwYXJ0cyBpbXBsaWVzIGlwdjYgc3ludGF4IHdpdGggbXVsdGlwbGUgY29sb25zXG4gICAgLy8gW3g6eDp4Ong6eDp4Ong6eF1cbiAgICAvLyBbeDp4Ong6eDp4Ong6eDp4XTp5eXl5XG4gICAgaWYgKHBhcnRzWzBdLnN0YXJ0c1dpdGgoJ1snKSkge1xuICAgICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0uZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgaWYgKHByb3RvID09PSAnaHR0cCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBob3N0OiBob3N0SGVhZGVyLCBwb3J0OiAnODAnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvdG8gPT09ICdodHRwcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBob3N0OiBob3N0SGVhZGVyLCBwb3J0OiAnNDQzJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaG9zdDogcGFydHMuc2xpY2UoMCwgLTEpLmpvaW4oJzonKSxcbiAgICAgICAgICAgICAgICBwb3J0OiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm90aGluZyBhYm92ZSBtYXRjaGVzIGp1c3QgcmV0dXJuIHRoZSBob3N0IGhlYWRlclxuICAgIHJldHVybiB7IGhvc3Q6IGhvc3RIZWFkZXIgfTtcbn1cbi8qKlxuICogR2V0IHNlcnZlci5hZGRyZXNzIGFuZCBwb3J0IGFjY29yZGluZyB0byBodHRwIHNlbWNvbnYgMS4yN1xuICogaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zL2Jsb2IvYmYwYTJjMTEzNGYyMDZmMDM0NDA4YjIwMWRiZWMzNzk2MGVkNjBlYy9kb2NzL2h0dHAvaHR0cC1zcGFucy5tZCNzZXR0aW5nLXNlcnZlcmFkZHJlc3MtYW5kLXNlcnZlcnBvcnQtYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBnZXRTZXJ2ZXJBZGRyZXNzKHJlcXVlc3QsIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGZvcndhcmRlZEhlYWRlciA9IHJlcXVlc3QuaGVhZGVyc1snZm9yd2FyZGVkJ107XG4gICAgaWYgKGZvcndhcmRlZEhlYWRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHBhcnNlRm9yd2FyZGVkSGVhZGVyKGZvcndhcmRlZEhlYWRlcikpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5ob3N0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcihlbnRyeS5ob3N0LCBlbnRyeS5wcm90byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeEZvcndhcmRlZEhvc3QgPSByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWhvc3QnXTtcbiAgICBpZiAodHlwZW9mIHhGb3J3YXJkZWRIb3N0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoeEZvcndhcmRlZEhvc3QsIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcih4Rm9yd2FyZGVkSG9zdCwgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKHhGb3J3YXJkZWRIb3N0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh4Rm9yd2FyZGVkSG9zdCkgJiZcbiAgICAgICAgdHlwZW9mIHhGb3J3YXJkZWRIb3N0WzBdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICB4Rm9yd2FyZGVkSG9zdFswXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcih4Rm9yd2FyZGVkSG9zdFswXSwgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKHhGb3J3YXJkZWRIb3N0WzBdLCByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ11bMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoeEZvcndhcmRlZEhvc3RbMF0pO1xuICAgIH1cbiAgICBjb25zdCBob3N0ID0gcmVxdWVzdC5oZWFkZXJzWydob3N0J107XG4gICAgaWYgKHR5cGVvZiBob3N0ID09PSAnc3RyaW5nJyAmJiBob3N0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcihob3N0LCBjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2V0IHNlcnZlci5hZGRyZXNzIGFuZCBwb3J0IGFjY29yZGluZyB0byBodHRwIHNlbWNvbnYgMS4yN1xuICogaHR0cHM6Ly9naXRodWIuY29tL29wZW4tdGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zL2Jsb2IvYmYwYTJjMTEzNGYyMDZmMDM0NDA4YjIwMWRiZWMzNzk2MGVkNjBlYy9kb2NzL2h0dHAvaHR0cC1zcGFucy5tZCNzZXR0aW5nLXNlcnZlcmFkZHJlc3MtYW5kLXNlcnZlcnBvcnQtYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBnZXRSZW1vdGVDbGllbnRBZGRyZXNzKHJlcXVlc3QpIHtcbiAgICBjb25zdCBmb3J3YXJkZWRIZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnNbJ2ZvcndhcmRlZCddO1xuICAgIGlmIChmb3J3YXJkZWRIZWFkZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBwYXJzZUZvcndhcmRlZEhlYWRlcihmb3J3YXJkZWRIZWFkZXIpKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuZm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmZvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4Rm9yd2FyZGVkRm9yID0gcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1mb3InXTtcbiAgICBpZiAodHlwZW9mIHhGb3J3YXJkZWRGb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB4Rm9yd2FyZGVkRm9yO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHhGb3J3YXJkZWRGb3IpKSB7XG4gICAgICAgIHJldHVybiB4Rm9yd2FyZGVkRm9yWzBdO1xuICAgIH1cbiAgICBjb25zdCByZW1vdGUgPSByZXF1ZXN0LnNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmdldFJlbW90ZUNsaWVudEFkZHJlc3MgPSBnZXRSZW1vdGVDbGllbnRBZGRyZXNzO1xuZnVuY3Rpb24gZ2V0SW5mb0Zyb21JbmNvbWluZ01lc3NhZ2UoY29tcG9uZW50LCByZXF1ZXN0LCBsb2dnZXIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnMuaG9zdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoKF9hID0gcmVxdWVzdC51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcvJywgYCR7Y29tcG9uZW50fTovLyR7cmVxdWVzdC5oZWFkZXJzLmhvc3R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1bnNhZmVQYXJzZWRVcmwgPSBuZXcgVVJMKChfYiA9IHJlcXVlc3QudXJsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnLycsIFxuICAgICAgICAgICAgLy8gdXNpbmcgbG9jYWxob3N0IGFzIGEgd29ya2Fyb3VuZCB0byBzdGlsbCB1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBmb3IgcGFyc2luZ1xuICAgICAgICAgICAgYCR7Y29tcG9uZW50fTovL2xvY2FsaG9zdGApO1xuICAgICAgICAgICAgLy8gc2luY2Ugd2UgdXNlIGxvY2FsaG9zdCBhcyBhIHdvcmthcm91bmQsIGVuc3VyZSB3ZSBoaWRlIHRoZSByZXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBvdXIgd29ya2Fyb3VuZCBsZWFraW5nIHRob3VnaC5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IHVuc2FmZVBhcnNlZFVybC5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHVuc2FmZVBhcnNlZFVybC5zZWFyY2gsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHVzZSB0aGUgcmVzdWx0IG9mIHVuc2FmZVBhcnNlZFVybC50b1N0cmluZyBhcyBpdCdzIHBvdGVudGlhbGx5IHdyb25nLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5zYWZlUGFyc2VkVXJsLnBhdGhuYW1lICsgdW5zYWZlUGFyc2VkVXJsLnNlYXJjaDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBzb21ldGhpbmcgaXMgd3JvbmcsIHVzZSB1bmRlZmluZWQgLSB0aGlzICpzaG91bGQqIG5ldmVyIGhhcHBlbiwgbG9nZ2luZ1xuICAgICAgICAvLyBmb3IgdHJvdWJsZXNob290aW5nIGluIGNhc2UgaXQgZG9lcyBoYXBwZW4uXG4gICAgICAgIGxvZ2dlci52ZXJib3NlKCdVbmFibGUgdG8gZ2V0IFVSTCBmcm9tIHJlcXVlc3QnLCBlKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBpbmNvbWluZyByZXF1ZXN0IGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7SW5jb21pbmdNZXNzYWdlfSByZXF1ZXN0IHRoZSByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIHt7IGNvbXBvbmVudDogc3RyaW5nLCBzZXJ2ZXJOYW1lPzogc3RyaW5nLCBob29rQXR0cmlidXRlcz86IEF0dHJpYnV0ZXMgfX0gb3B0aW9ucyB1c2VkIHRvIHBhc3MgZGF0YSBuZWVkZWQgdG8gY3JlYXRlIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7U2VtY29udlN0YWJpbGl0eX0gc2VtY29udlN0YWJpbGl0eSBkZXRlcm1pbmVzIHdoaWNoIHNlbWNvbnYgdmVyc2lvbiB0byB1c2VcbiAqL1xuY29uc3QgZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlcyA9IChyZXF1ZXN0LCBvcHRpb25zLCBsb2dnZXIpID0+IHtcbiAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IGhlYWRlcnNbJ3VzZXItYWdlbnQnXTtcbiAgICBjb25zdCBpcHMgPSBoZWFkZXJzWyd4LWZvcndhcmRlZC1mb3InXTtcbiAgICBjb25zdCBodHRwVmVyc2lvbiA9IHJlcXVlc3QuaHR0cFZlcnNpb247XG4gICAgY29uc3QgaG9zdCA9IGhlYWRlcnMuaG9zdDtcbiAgICBjb25zdCBob3N0bmFtZSA9IChob3N0ID09PSBudWxsIHx8IGhvc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3QucmVwbGFjZSgvXiguKikoOlswLTldezEsNX0pLywgJyQxJykpIHx8ICdsb2NhbGhvc3QnO1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRNZXRob2QgPSBub3JtYWxpemVNZXRob2QobWV0aG9kKTtcbiAgICBjb25zdCBzZXJ2ZXJBZGRyZXNzID0gZ2V0U2VydmVyQWRkcmVzcyhyZXF1ZXN0LCBvcHRpb25zLmNvbXBvbmVudCk7XG4gICAgY29uc3Qgc2VydmVyTmFtZSA9IG9wdGlvbnMuc2VydmVyTmFtZTtcbiAgICBjb25zdCByZW1vdGVDbGllbnRBZGRyZXNzID0gZ2V0UmVtb3RlQ2xpZW50QWRkcmVzcyhyZXF1ZXN0KTtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RdOiBub3JtYWxpemVkTWV0aG9kLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9TQ0hFTUVdOiBvcHRpb25zLmNvbXBvbmVudCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IHNlcnZlckFkZHJlc3MgPT09IG51bGwgfHwgc2VydmVyQWRkcmVzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VydmVyQWRkcmVzcy5ob3N0LFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9BRERSRVNTXTogcmVxdWVzdC5zb2NrZXQucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BFRVJfUE9SVF06IHJlcXVlc3Quc29ja2V0LnJlbW90ZVBvcnQsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXTogcmVxdWVzdC5odHRwVmVyc2lvbixcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VU0VSX0FHRU5UX09SSUdJTkFMXTogdXNlckFnZW50LFxuICAgIH07XG4gICAgY29uc3QgcGFyc2VkVXJsID0gZ2V0SW5mb0Zyb21JbmNvbWluZ01lc3NhZ2Uob3B0aW9ucy5jb21wb25lbnQsIHJlcXVlc3QsIGxvZ2dlcik7XG4gICAgaWYgKChwYXJzZWRVcmwgPT09IG51bGwgfHwgcGFyc2VkVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZWRVcmwucGF0aG5hbWUpICE9IG51bGwpIHtcbiAgICAgICAgbmV3QXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1BBVEhdID0gcGFyc2VkVXJsLnBhdGhuYW1lO1xuICAgIH1cbiAgICBpZiAocmVtb3RlQ2xpZW50QWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0NMSUVOVF9BRERSRVNTXSA9IHJlbW90ZUNsaWVudEFkZHJlc3M7XG4gICAgfVxuICAgIGlmICgoc2VydmVyQWRkcmVzcyA9PT0gbnVsbCB8fCBzZXJ2ZXJBZGRyZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2ZXJBZGRyZXNzLnBvcnQpICE9IG51bGwpIHtcbiAgICAgICAgbmV3QXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlRdID0gTnVtYmVyKHNlcnZlckFkZHJlc3MucG9ydCk7XG4gICAgfVxuICAgIC8vIGNvbmRpdGlvbmFsbHkgcmVxdWlyZWQgaWYgcmVxdWVzdCBtZXRob2QgcmVxdWlyZWQgY2FzZSBub3JtYWxpemF0aW9uXG4gICAgaWYgKG1ldGhvZCAhPT0gbm9ybWFsaXplZE1ldGhvZCkge1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EX09SSUdJTkFMXSA9IG1ldGhvZDtcbiAgICB9XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHtcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9VUkxdOiBwYXJzZWRVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9IT1NUXTogaG9zdCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfTkFNRV06IGhvc3RuYW1lLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX01FVEhPRF06IG1ldGhvZCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TQ0hFTUVdOiBvcHRpb25zLmNvbXBvbmVudCxcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgaXBzID09PSAnc3RyaW5nJykge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9DTElFTlRfSVBdID0gaXBzLnNwbGl0KCcsJylbMF07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VydmVyTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU0VSVkVSX05BTUVdID0gc2VydmVyTmFtZTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZFVybCA9PT0gbnVsbCB8fCBwYXJzZWRVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9UQVJHRVRdID1cbiAgICAgICAgICAgIChwYXJzZWRVcmwgPT09IG51bGwgfHwgcGFyc2VkVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZWRVcmwucGF0aG5hbWUpICsgKHBhcnNlZFVybCA9PT0gbnVsbCB8fCBwYXJzZWRVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlZFVybC5zZWFyY2gpIHx8ICcvJztcbiAgICB9XG4gICAgaWYgKHVzZXJBZ2VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1VTRVJfQUdFTlRdID0gdXNlckFnZW50O1xuICAgIH1cbiAgICAoMCwgZXhwb3J0cy5zZXRSZXF1ZXN0Q29udGVudExlbmd0aEF0dHJpYnV0ZSkocmVxdWVzdCwgb2xkQXR0cmlidXRlcyk7XG4gICAgKDAsIGV4cG9ydHMuc2V0QXR0cmlidXRlc0Zyb21IdHRwS2luZCkoaHR0cFZlcnNpb24sIG9sZEF0dHJpYnV0ZXMpO1xuICAgIHN3aXRjaCAob3B0aW9ucy5zZW1jb252U3RhYmlsaXR5KSB7XG4gICAgICAgIGNhc2UgMSAvKiBTVEFCTEUgKi86XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCBvcHRpb25zLmhvb2tBdHRyaWJ1dGVzKTtcbiAgICAgICAgY2FzZSAyIC8qIE9MRCAqLzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvbGRBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzLCBvcHRpb25zLmhvb2tBdHRyaWJ1dGVzKTtcbn07XG5leHBvcnRzLmdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzO1xuLyoqXG4gKiBSZXR1cm5zIGluY29taW5nIHJlcXVlc3QgTWV0cmljIGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7QXR0cmlidXRlc30gc3BhbkF0dHJpYnV0ZXMgdGhlIHNwYW4gYXR0cmlidXRlc1xuICogQHBhcmFtIHt7IGNvbXBvbmVudDogc3RyaW5nIH19IG9wdGlvbnMgdXNlZCB0byBwYXNzIGRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IGdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0ge307XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU0NIRU1FXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TQ0hFTUVdO1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX01FVEhPRF0gPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfTkFNRV0gPVxuICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX05BTUVdO1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0ZMQVZPUl0gPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfRkxBVk9SXTtcbiAgICAvL1RPRE86IGh0dHAudGFyZ2V0IGF0dHJpYnV0ZSwgaXQgc2hvdWxkIHN1YnN0aXR1dGUgYW55IHBhcmFtZXRlcnMgdG8gYXZvaWQgaGlnaCBjYXJkaW5hbGl0eS5cbiAgICByZXR1cm4gbWV0cmljQXR0cmlidXRlcztcbn07XG5leHBvcnRzLmdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMgPSBnZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzO1xuLyoqXG4gKiBSZXR1cm5zIGluY29taW5nIHJlcXVlc3QgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlc3BvbnNlIGRhdGFcbiAqIEBwYXJhbSB7KFNlcnZlclJlc3BvbnNlICYgeyBzb2NrZXQ6IFNvY2tldDsgfSl9IHJlc3BvbnNlIHRoZSByZXNwb25zZSBvYmplY3RcbiAqL1xuY29uc3QgZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSAocmVxdWVzdCwgcmVzcG9uc2UsIHNlbWNvbnZTdGFiaWxpdHkpID0+IHtcbiAgICAvLyB0YWtlIHNvY2tldCBmcm9tIHRoZSByZXF1ZXN0LFxuICAgIC8vIHNpbmNlIGl0IG1heSBiZSBkZXRhY2hlZCBmcm9tIHRoZSByZXNwb25zZSBvYmplY3QgaW4ga2VlcC1hbGl2ZSBtb2RlXG4gICAgY29uc3QgeyBzb2NrZXQgfSA9IHJlcXVlc3Q7XG4gICAgY29uc3QgeyBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdOiBzdGF0dXNDb2RlLFxuICAgIH07XG4gICAgY29uc3QgcnBjTWV0YWRhdGEgPSAoMCwgY29yZV8xLmdldFJQQ01ldGFkYXRhKShhcGlfMS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgICBjb25zdCB7IGxvY2FsQWRkcmVzcywgbG9jYWxQb3J0LCByZW1vdGVBZGRyZXNzLCByZW1vdGVQb3J0IH0gPSBzb2NrZXQ7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9JUF0gPSBsb2NhbEFkZHJlc3M7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9QT1JUXSA9IGxvY2FsUG9ydDtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX0lQXSA9IHJlbW90ZUFkZHJlc3M7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9QT1JUXSA9IHJlbW90ZVBvcnQ7XG4gICAgfVxuICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXSA9IHN0YXR1c0NvZGU7XG4gICAgb2xkQXR0cmlidXRlc1tBdHRyaWJ1dGVOYW1lc18xLkF0dHJpYnV0ZU5hbWVzLkhUVFBfU1RBVFVTX1RFWFRdID0gKHN0YXR1c01lc3NhZ2UgfHwgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKChycGNNZXRhZGF0YSA9PT0gbnVsbCB8fCBycGNNZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcnBjTWV0YWRhdGEudHlwZSkgPT09IGNvcmVfMS5SUENUeXBlLkhUVFAgJiYgcnBjTWV0YWRhdGEucm91dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9ST1VURV0gPSBycGNNZXRhZGF0YS5yb3V0ZTtcbiAgICAgICAgbmV3QXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9ST1VURV0gPSBycGNNZXRhZGF0YS5yb3V0ZTtcbiAgICB9XG4gICAgc3dpdGNoIChzZW1jb252U3RhYmlsaXR5KSB7XG4gICAgICAgIGNhc2UgMSAvKiBTVEFCTEUgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3QXR0cmlidXRlcztcbiAgICAgICAgY2FzZSAyIC8qIE9MRCAqLzpcbiAgICAgICAgICAgIHJldHVybiBvbGRBdHRyaWJ1dGVzO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvbGRBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcbn07XG5leHBvcnRzLmdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlID0gZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2U7XG4vKipcbiAqIFJldHVybnMgaW5jb21pbmcgcmVxdWVzdCBNZXRyaWMgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtBdHRyaWJ1dGVzfSBzcGFuQXR0cmlidXRlcyB0aGUgc3BhbiBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IGdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gKHNwYW5BdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXSA9XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX1BPUlRdID1cbiAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9QT1JUXTtcbiAgICBpZiAoc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9ST1VURV07XG4gICAgfVxuICAgIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSBnZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZTtcbmNvbnN0IGdldEluY29taW5nU3RhYmxlUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gKHNwYW5BdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9ST1VURV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JPVVRFXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9ST1VURV07XG4gICAgfVxuICAgIC8vIHJlcXVpcmVkIGlmIGFuZCBvbmx5IGlmIG9uZSB3YXMgc2VudCwgc2FtZSBhcyBzcGFuIHJlcXVpcmVtZW50XG4gICAgaWYgKHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXSkge1xuICAgICAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXSA9XG4gICAgICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV07XG4gICAgfVxuICAgIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0SW5jb21pbmdTdGFibGVSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSBnZXRJbmNvbWluZ1N0YWJsZVJlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZTtcbmZ1bmN0aW9uIGhlYWRlckNhcHR1cmUodHlwZSwgaGVhZGVycykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRIZWFkZXJzID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBoZWFkZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkSGVhZGVyID0gaGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBub3JtYWxpemVkSGVhZGVycy5zZXQoY2FwdHVyZWRIZWFkZXIsIGNhcHR1cmVkSGVhZGVyLnJlcGxhY2UoLy0vZywgJ18nKSk7XG4gICAgfVxuICAgIHJldHVybiAoc3BhbiwgZ2V0SGVhZGVyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY2FwdHVyZWRIZWFkZXIgb2Ygbm9ybWFsaXplZEhlYWRlcnMua2V5cygpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEhlYWRlcihjYXB0dXJlZEhlYWRlcik7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEhlYWRlciA9IG5vcm1hbGl6ZWRIZWFkZXJzLmdldChjYXB0dXJlZEhlYWRlcik7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgaHR0cC4ke3R5cGV9LmhlYWRlci4ke25vcm1hbGl6ZWRIZWFkZXJ9YDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoa2V5LCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShrZXksIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuaGVhZGVyQ2FwdHVyZSA9IGhlYWRlckNhcHR1cmU7XG5jb25zdCBLTk9XTl9NRVRIT0RTID0gbmV3IFNldChbXG4gICAgLy8gbWV0aG9kcyBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTEwLmh0bWwjbmFtZS1tZXRob2RzXG4gICAgJ0dFVCcsXG4gICAgJ0hFQUQnLFxuICAgICdQT1NUJyxcbiAgICAnUFVUJyxcbiAgICAnREVMRVRFJyxcbiAgICAnQ09OTkVDVCcsXG4gICAgJ09QVElPTlMnLFxuICAgICdUUkFDRScsXG4gICAgLy8gUEFUQ0ggZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNTc4OS5odG1sXG4gICAgJ1BBVENIJyxcbl0pO1xuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIGlmIChtZXRob2QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ0dFVCc7XG4gICAgfVxuICAgIGNvbnN0IHVwcGVyID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKEtOT1dOX01FVEhPRFMuaGFzKHVwcGVyKSkge1xuICAgICAgICByZXR1cm4gdXBwZXI7XG4gICAgfVxuICAgIHJldHVybiAnX09USEVSJztcbn1cbmZ1bmN0aW9uIHBhcnNlRm9yd2FyZGVkSGVhZGVyKGhlYWRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmb3J3YXJkZWRQYXJzZShoZWFkZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.VERSION = '0.57.2';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjJfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZFUlNJT04gPSB2b2lkIDA7XG4vLyB0aGlzIGlzIGF1dG9nZW5lcmF0ZWQgZmlsZSwgc2VlIHNjcmlwdHMvdmVyc2lvbi11cGRhdGUuanNcbmV4cG9ydHMuVkVSU0lPTiA9ICcwLjU3LjInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js":</span>
<span class="cstat-no" title="statement not covered" >/*!***********************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \***********************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttributeNames = void 0;\n/**\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md\n */\nvar AttributeNames;\n(function (AttributeNames) {\n    AttributeNames[\"HTTP_ERROR_NAME\"] = \"http.error_name\";\n    AttributeNames[\"HTTP_ERROR_MESSAGE\"] = \"http.error_message\";\n    AttributeNames[\"HTTP_STATUS_TEXT\"] = \"http.status_text\";\n})(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));\n//# sourceMappingURL=AttributeNames.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2VudW1zL0F0dHJpYnV0ZU5hbWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEMsc0JBQXNCLEtBQUs7QUFDMUUiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2VudW1zL0F0dHJpYnV0ZU5hbWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXR0cmlidXRlTmFtZXMgPSB2b2lkIDA7XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LXNwZWNpZmljYXRpb24vYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi90cmFjZS9zZW1hbnRpY19jb252ZW50aW9ucy9odHRwLm1kXG4gKi9cbnZhciBBdHRyaWJ1dGVOYW1lcztcbihmdW5jdGlvbiAoQXR0cmlidXRlTmFtZXMpIHtcbiAgICBBdHRyaWJ1dGVOYW1lc1tcIkhUVFBfRVJST1JfTkFNRVwiXSA9IFwiaHR0cC5lcnJvcl9uYW1lXCI7XG4gICAgQXR0cmlidXRlTmFtZXNbXCJIVFRQX0VSUk9SX01FU1NBR0VcIl0gPSBcImh0dHAuZXJyb3JfbWVzc2FnZVwiO1xuICAgIEF0dHJpYnV0ZU5hbWVzW1wiSFRUUF9TVEFUVVNfVEVYVFwiXSA9IFwiaHR0cC5zdGF0dXNfdGV4dFwiO1xufSkoQXR0cmlidXRlTmFtZXMgPSBleHBvcnRzLkF0dHJpYnV0ZU5hbWVzIHx8IChleHBvcnRzLkF0dHJpYnV0ZU5hbWVzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0ZU5hbWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js":</span>
<span class="cstat-no" title="statement not covered" >/*!*******************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \*******************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst core_2 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js\");\n/**\n * `node:http` and `node:https` instrumentation for OpenTelemetry\n */\nclass HttpInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super('@opentelemetry/instrumentation-http', version_1.VERSION, config);\n        /** keep track on spans not ended */\n        this._spanNotEnded = new WeakSet();\n        this._semconvStability = 2 /* OLD */;\n        this._headerCapture = this._createHeaderCapture();\n        for (const entry of (0, core_2.getEnv)().OTEL_SEMCONV_STABILITY_OPT_IN) {\n            if (entry.toLowerCase() === 'http/dup') {\n                // http/dup takes highest precedence. If it is found, there is no need to read the rest of the list\n                this._semconvStability = 3 /* DUPLICATE */;\n                break;\n            }\n            else if (entry.toLowerCase() === 'http') {\n                this._semconvStability = 1 /* STABLE */;\n            }\n        }\n    }\n    _updateMetricInstruments() {\n        this._oldHttpServerDurationHistogram = this.meter.createHistogram('http.server.duration', {\n            description: 'Measures the duration of inbound HTTP requests.',\n            unit: 'ms',\n            valueType: api_1.ValueType.DOUBLE,\n        });\n        this._oldHttpClientDurationHistogram = this.meter.createHistogram('http.client.duration', {\n            description: 'Measures the duration of outbound HTTP requests.',\n            unit: 'ms',\n            valueType: api_1.ValueType.DOUBLE,\n        });\n        this._stableHttpServerDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_SERVER_REQUEST_DURATION, {\n            description: 'Duration of HTTP server requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n        this._stableHttpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {\n            description: 'Duration of HTTP client requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n    }\n    _recordServerDuration(durationMs, oldAttributes, stableAttributes) {\n        if ((this._semconvStability &amp; 2 /* OLD */) ===\n            2 /* OLD */) {\n            // old histogram is counted in MS\n            this._oldHttpServerDurationHistogram.record(durationMs, oldAttributes);\n        }\n        if ((this._semconvStability &amp; 1 /* STABLE */) ===\n            1 /* STABLE */) {\n            // stable histogram is counted in S\n            this._stableHttpServerDurationHistogram.record(durationMs / 1000, stableAttributes);\n        }\n    }\n    _recordClientDuration(durationMs, oldAttributes, stableAttributes) {\n        if ((this._semconvStability &amp; 2 /* OLD */) ===\n            2 /* OLD */) {\n            // old histogram is counted in MS\n            this._oldHttpClientDurationHistogram.record(durationMs, oldAttributes);\n        }\n        if ((this._semconvStability &amp; 1 /* STABLE */) ===\n            1 /* STABLE */) {\n            // stable histogram is counted in S\n            this._stableHttpClientDurationHistogram.record(durationMs / 1000, stableAttributes);\n        }\n    }\n    setConfig(config = {}) {\n        super.setConfig(config);\n        this._headerCapture = this._createHeaderCapture();\n    }\n    init() {\n        return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n    }\n    _getHttpInstrumentation() {\n        return new instrumentation_1.InstrumentationNodeModuleDefinition('http', ['*'], (moduleExports) =&gt; {\n            const isESM = moduleExports[Symbol.toStringTag] === 'Module';\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                const patchedRequest = this._wrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction('http'));\n                const patchedGet = this._wrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n                if (isESM) {\n                    // To handle `import http from 'http'`, which returns the default\n                    // export, we need to set `module.default.*`.\n                    moduleExports.default.request = patchedRequest;\n                    moduleExports.default.get = patchedGet;\n                }\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._wrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction('http'));\n            }\n            return moduleExports;\n        }, (moduleExports) =&gt; {\n            if (moduleExports === undefined)\n                return;\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                this._unwrap(moduleExports, 'request');\n                this._unwrap(moduleExports, 'get');\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._unwrap(moduleExports.Server.prototype, 'emit');\n            }\n        });\n    }\n    _getHttpsInstrumentation() {\n        return new instrumentation_1.InstrumentationNodeModuleDefinition('https', ['*'], (moduleExports) =&gt; {\n            const isESM = moduleExports[Symbol.toStringTag] === 'Module';\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                const patchedRequest = this._wrap(moduleExports, 'request', this._getPatchHttpsOutgoingRequestFunction('https'));\n                const patchedGet = this._wrap(moduleExports, 'get', this._getPatchHttpsOutgoingGetFunction(patchedRequest));\n                if (isESM) {\n                    // To handle `import https from 'https'`, which returns the default\n                    // export, we need to set `module.default.*`.\n                    moduleExports.default.request = patchedRequest;\n                    moduleExports.default.get = patchedGet;\n                }\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._wrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction('https'));\n            }\n            return moduleExports;\n        }, (moduleExports) =&gt; {\n            if (moduleExports === undefined)\n                return;\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                this._unwrap(moduleExports, 'request');\n                this._unwrap(moduleExports, 'get');\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._unwrap(moduleExports.Server.prototype, 'emit');\n            }\n        });\n    }\n    /**\n     * Creates spans for incoming requests, restoring spans' context if applied.\n     */\n    _getPatchIncomingRequestFunction(component) {\n        return (original) =&gt; {\n            return this._incomingRequestFunction(component, original);\n        };\n    }\n    /**\n     * Creates spans for outgoing requests, sending spans' context for distributed\n     * tracing.\n     */\n    _getPatchOutgoingRequestFunction(component) {\n        return (original) =&gt; {\n            return this._outgoingRequestFunction(component, original);\n        };\n    }\n    _getPatchOutgoingGetFunction(clientRequest) {\n        return (_original) =&gt; {\n            // Re-implement http.get. This needs to be done (instead of using\n            // getPatchOutgoingRequestFunction to patch it) because we need to\n            // set the trace context header before the returned http.ClientRequest is\n            // ended. The Node.js docs state that the only differences between\n            // request and get are that (1) get defaults to the HTTP GET method and\n            // (2) the returned request object is ended immediately. The former is\n            // already true (at least in supported Node versions up to v10), so we\n            // simply follow the latter. Ref:\n            // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback\n            // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/instrumentations/instrumentation-http.ts#L198\n            return function outgoingGetRequest(options, ...args) {\n                const req = clientRequest(options, ...args);\n                req.end();\n                return req;\n            };\n        };\n    }\n    /** Patches HTTPS outgoing requests */\n    _getPatchHttpsOutgoingRequestFunction(component) {\n        return (original) =&gt; {\n            const instrumentation = this;\n            return function httpsOutgoingRequest(\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            options, ...args) {\n                var _a;\n                // Makes sure options will have default HTTPS parameters\n                if (component === 'https' &amp;&amp;\n                    typeof options === 'object' &amp;&amp;\n                    ((_a = options === null || options === void 0 ? void 0 : options.constructor) === null || _a === void 0 ? void 0 : _a.name) !== 'URL') {\n                    options = Object.assign({}, options);\n                    instrumentation._setDefaultOptions(options);\n                }\n                return instrumentation._getPatchOutgoingRequestFunction(component)(original)(options, ...args);\n            };\n        };\n    }\n    _setDefaultOptions(options) {\n        options.protocol = options.protocol || 'https:';\n        options.port = options.port || 443;\n    }\n    /** Patches HTTPS outgoing get requests */\n    _getPatchHttpsOutgoingGetFunction(clientRequest) {\n        return (original) =&gt; {\n            const instrumentation = this;\n            return function httpsOutgoingRequest(\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            options, ...args) {\n                return instrumentation._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);\n            };\n        };\n    }\n    /**\n     * Attach event listeners to a client request to end span and add span attributes.\n     *\n     * @param request The original request object.\n     * @param span representing the current operation\n     * @param startTime representing the start time of the request to calculate duration in Metric\n     * @param oldMetricAttributes metric attributes for old semantic conventions\n     * @param stableMetricAttributes metric attributes for new semantic conventions\n     */\n    _traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes) {\n        if (this.getConfig().requestHook) {\n            this._callRequestHook(span, request);\n        }\n        /**\n         * Determines if the request has errored or the response has ended/errored.\n         */\n        let responseFinished = false;\n        /*\n         * User 'response' event listeners can be added before our listener,\n         * force our listener to be the first, so response emitter is bound\n         * before any user listeners are added to it.\n         */\n        request.prependListener('response', (response) =&gt; {\n            this._diag.debug('outgoingRequest on response()');\n            if (request.listenerCount('response') &lt;= 1) {\n                response.resume();\n            }\n            const responseAttributes = (0, utils_1.getOutgoingRequestAttributesOnResponse)(response, this._semconvStability);\n            span.setAttributes(responseAttributes);\n            oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getOutgoingRequestMetricAttributesOnResponse)(responseAttributes));\n            if (this.getConfig().responseHook) {\n                this._callResponseHook(span, response);\n            }\n            this._headerCapture.client.captureRequestHeaders(span, header =&gt; request.getHeader(header));\n            this._headerCapture.client.captureResponseHeaders(span, header =&gt; response.headers[header]);\n            api_1.context.bind(api_1.context.active(), response);\n            const endHandler = () =&gt; {\n                this._diag.debug('outgoingRequest on end()');\n                if (responseFinished) {\n                    return;\n                }\n                responseFinished = true;\n                let status;\n                if (response.aborted &amp;&amp; !response.complete) {\n                    status = { code: api_1.SpanStatusCode.ERROR };\n                }\n                else {\n                    // behaves same for new and old semconv\n                    status = {\n                        code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.CLIENT, response.statusCode),\n                    };\n                }\n                span.setStatus(status);\n                if (this.getConfig().applyCustomAttributesOnSpan) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().applyCustomAttributesOnSpan(span, request, response), () =&gt; { }, true);\n                }\n                this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n            };\n            response.on('end', endHandler);\n            // See https://github.com/open-telemetry/opentelemetry-js/pull/3625#issuecomment-1475673533\n            if (semver.lt(process.version, '16.0.0')) {\n                response.on('close', endHandler);\n            }\n            response.on(events_1.errorMonitor, (error) =&gt; {\n                this._diag.debug('outgoingRequest on error()', error);\n                if (responseFinished) {\n                    return;\n                }\n                responseFinished = true;\n                (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: error.message,\n                });\n                this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n            });\n        });\n        request.on('close', () =&gt; {\n            this._diag.debug('outgoingRequest on request close()');\n            if (request.aborted || responseFinished) {\n                return;\n            }\n            responseFinished = true;\n            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n        });\n        request.on(events_1.errorMonitor, (error) =&gt; {\n            this._diag.debug('outgoingRequest on request error()', error);\n            if (responseFinished) {\n                return;\n            }\n            responseFinished = true;\n            (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n        });\n        this._diag.debug('http.ClientRequest return request');\n        return request;\n    }\n    _incomingRequestFunction(component, original) {\n        const instrumentation = this;\n        return function incomingRequest(event, ...args) {\n            // Only traces request events\n            if (event !== 'request') {\n                return original.apply(this, [event, ...args]);\n            }\n            const request = args[0];\n            const response = args[1];\n            const method = request.method || 'GET';\n            instrumentation._diag.debug(`${component} instrumentation incomingRequest`);\n            if ((0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; { var _a, _b; return (_b = (_a = instrumentation.getConfig()).ignoreIncomingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, request); }, (e) =&gt; {\n                if (e != null) {\n                    instrumentation._diag.error('caught ignoreIncomingRequestHook error: ', e);\n                }\n            }, true)) {\n                return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () =&gt; {\n                    api_1.context.bind(api_1.context.active(), request);\n                    api_1.context.bind(api_1.context.active(), response);\n                    return original.apply(this, [event, ...args]);\n                });\n            }\n            const headers = request.headers;\n            const spanAttributes = (0, utils_1.getIncomingRequestAttributes)(request, {\n                component: component,\n                serverName: instrumentation.getConfig().serverName,\n                hookAttributes: instrumentation._callStartSpanHook(request, instrumentation.getConfig().startIncomingSpanHook),\n                semconvStability: instrumentation._semconvStability,\n            }, instrumentation._diag);\n            const spanOptions = {\n                kind: api_1.SpanKind.SERVER,\n                attributes: spanAttributes,\n            };\n            const startTime = (0, core_1.hrTime)();\n            const oldMetricAttributes = (0, utils_1.getIncomingRequestMetricAttributes)(spanAttributes);\n            // request method and url.scheme are both required span attributes\n            const stableMetricAttributes = {\n                [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: spanAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],\n                [semantic_conventions_1.ATTR_URL_SCHEME]: spanAttributes[semantic_conventions_1.ATTR_URL_SCHEME],\n            };\n            // recommended if and only if one was sent, same as span recommendation\n            if (spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] =\n                    spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];\n            }\n            const ctx = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n            const span = instrumentation._startHttpSpan(method, spanOptions, ctx);\n            const rpcMetadata = {\n                type: core_2.RPCType.HTTP,\n                span,\n            };\n            return api_1.context.with((0, core_2.setRPCMetadata)(api_1.trace.setSpan(ctx, span), rpcMetadata), () =&gt; {\n                api_1.context.bind(api_1.context.active(), request);\n                api_1.context.bind(api_1.context.active(), response);\n                if (instrumentation.getConfig().requestHook) {\n                    instrumentation._callRequestHook(span, request);\n                }\n                if (instrumentation.getConfig().responseHook) {\n                    instrumentation._callResponseHook(span, response);\n                }\n                instrumentation._headerCapture.server.captureRequestHeaders(span, header =&gt; request.headers[header]);\n                // After 'error', no further events other than 'close' should be emitted.\n                let hasError = false;\n                response.on('close', () =&gt; {\n                    if (hasError) {\n                        return;\n                    }\n                    instrumentation._onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime);\n                });\n                response.on(events_1.errorMonitor, (err) =&gt; {\n                    hasError = true;\n                    instrumentation._onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, err);\n                });\n                return (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; original.apply(this, [event, ...args]), error =&gt; {\n                    if (error) {\n                        (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);\n                        instrumentation._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n                        throw error;\n                    }\n                });\n            });\n        };\n    }\n    _outgoingRequestFunction(component, original) {\n        const instrumentation = this;\n        return function outgoingRequest(options, ...args) {\n            if (!(0, utils_1.isValidOptionsType)(options)) {\n                return original.apply(this, [options, ...args]);\n            }\n            const extraOptions = typeof args[0] === 'object' &amp;&amp;\n                (typeof options === 'string' || options instanceof url.URL)\n                ? args.shift()\n                : undefined;\n            const { method, invalidUrl, optionsParsed } = (0, utils_1.getRequestInfo)(instrumentation._diag, options, extraOptions);\n            /**\n             * Node 8's https module directly call the http one so to avoid creating\n             * 2 span for the same request we need to check that the protocol is correct\n             * See: https://github.com/nodejs/node/blob/v8.17.0/lib/https.js#L245\n             */\n            if (component === 'http' &amp;&amp;\n                semver.lt(process.version, '9.0.0') &amp;&amp;\n                optionsParsed.protocol === 'https:') {\n                return original.apply(this, [optionsParsed, ...args]);\n            }\n            if ((0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; {\n                var _a, _b;\n                return (_b = (_a = instrumentation\n                    .getConfig()).ignoreOutgoingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, optionsParsed);\n            }, (e) =&gt; {\n                if (e != null) {\n                    instrumentation._diag.error('caught ignoreOutgoingRequestHook error: ', e);\n                }\n            }, true)) {\n                return original.apply(this, [optionsParsed, ...args]);\n            }\n            const { hostname, port } = (0, utils_1.extractHostnameAndPort)(optionsParsed);\n            const attributes = (0, utils_1.getOutgoingRequestAttributes)(optionsParsed, {\n                component,\n                port,\n                hostname,\n                hookAttributes: instrumentation._callStartSpanHook(optionsParsed, instrumentation.getConfig().startOutgoingSpanHook),\n            }, instrumentation._semconvStability);\n            const startTime = (0, core_1.hrTime)();\n            const oldMetricAttributes = (0, utils_1.getOutgoingRequestMetricAttributes)(attributes);\n            // request method, server address, and server port are both required span attributes\n            const stableMetricAttributes = {\n                [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: attributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],\n                [semantic_conventions_1.ATTR_SERVER_ADDRESS]: attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS],\n                [semantic_conventions_1.ATTR_SERVER_PORT]: attributes[semantic_conventions_1.ATTR_SERVER_PORT],\n            };\n            // required if and only if one was sent, same as span requirement\n            if (attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] =\n                    attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];\n            }\n            // recommended if and only if one was sent, same as span recommendation\n            if (attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] =\n                    attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];\n            }\n            const spanOptions = {\n                kind: api_1.SpanKind.CLIENT,\n                attributes,\n            };\n            const span = instrumentation._startHttpSpan(method, spanOptions);\n            const parentContext = api_1.context.active();\n            const requestContext = api_1.trace.setSpan(parentContext, span);\n            if (!optionsParsed.headers) {\n                optionsParsed.headers = {};\n            }\n            else {\n                // Make a copy of the headers object to avoid mutating an object the\n                // caller might have a reference to.\n                optionsParsed.headers = Object.assign({}, optionsParsed.headers);\n            }\n            api_1.propagation.inject(requestContext, optionsParsed.headers);\n            return api_1.context.with(requestContext, () =&gt; {\n                /*\n                 * The response callback is registered before ClientRequest is bound,\n                 * thus it is needed to bind it before the function call.\n                 */\n                const cb = args[args.length - 1];\n                if (typeof cb === 'function') {\n                    args[args.length - 1] = api_1.context.bind(parentContext, cb);\n                }\n                const request = (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; {\n                    if (invalidUrl) {\n                        // we know that the url is invalid, there's no point in injecting context as it will fail validation.\n                        // Passing in what the user provided will give the user an error that matches what they'd see without\n                        // the instrumentation.\n                        return original.apply(this, [options, ...args]);\n                    }\n                    else {\n                        return original.apply(this, [optionsParsed, ...args]);\n                    }\n                }, error =&gt; {\n                    if (error) {\n                        (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);\n                        instrumentation._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n                        throw error;\n                    }\n                });\n                instrumentation._diag.debug(`${component} instrumentation outgoingRequest`);\n                api_1.context.bind(parentContext, request);\n                return instrumentation._traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes);\n            });\n        };\n    }\n    _onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime) {\n        const attributes = (0, utils_1.getIncomingRequestAttributesOnResponse)(request, response, this._semconvStability);\n        oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getIncomingRequestMetricAttributesOnResponse)(attributes));\n        stableMetricAttributes = Object.assign(stableMetricAttributes, (0, utils_1.getIncomingStableRequestMetricAttributesOnResponse)(attributes));\n        this._headerCapture.server.captureResponseHeaders(span, header =&gt; response.getHeader(header));\n        span.setAttributes(attributes).setStatus({\n            code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.SERVER, response.statusCode),\n        });\n        const route = attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n        if (route) {\n            span.updateName(`${request.method || 'GET'} ${route}`);\n        }\n        if (this.getConfig().applyCustomAttributesOnSpan) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().applyCustomAttributesOnSpan(span, request, response), () =&gt; { }, true);\n        }\n        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n    }\n    _onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, error) {\n        (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n        // TODO get error attributes for metrics\n        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n    }\n    _startHttpSpan(name, options, ctx = api_1.context.active()) {\n        /*\n         * If a parent is required but not present, we use a `NoopSpan` to still\n         * propagate context without recording it.\n         */\n        const requireParent = options.kind === api_1.SpanKind.CLIENT\n            ? this.getConfig().requireParentforOutgoingSpans\n            : this.getConfig().requireParentforIncomingSpans;\n        let span;\n        const currentSpan = api_1.trace.getSpan(ctx);\n        if (requireParent === true &amp;&amp; currentSpan === undefined) {\n            span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);\n        }\n        else if (requireParent === true &amp;&amp; (currentSpan === null || currentSpan === void 0 ? void 0 : currentSpan.spanContext().isRemote)) {\n            span = currentSpan;\n        }\n        else {\n            span = this.tracer.startSpan(name, options, ctx);\n        }\n        this._spanNotEnded.add(span);\n        return span;\n    }\n    _closeHttpSpan(span, spanKind, startTime, oldMetricAttributes, stableMetricAttributes) {\n        if (!this._spanNotEnded.has(span)) {\n            return;\n        }\n        span.end();\n        this._spanNotEnded.delete(span);\n        // Record metrics\n        const duration = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)()));\n        if (spanKind === api_1.SpanKind.SERVER) {\n            this._recordServerDuration(duration, oldMetricAttributes, stableMetricAttributes);\n        }\n        else if (spanKind === api_1.SpanKind.CLIENT) {\n            this._recordClientDuration(duration, oldMetricAttributes, stableMetricAttributes);\n        }\n    }\n    _callResponseHook(span, response) {\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().responseHook(span, response), () =&gt; { }, true);\n    }\n    _callRequestHook(span, request) {\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().requestHook(span, request), () =&gt; { }, true);\n    }\n    _callStartSpanHook(request, hookFunc) {\n        if (typeof hookFunc === 'function') {\n            return (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; hookFunc(request), () =&gt; { }, true);\n        }\n    }\n    _createHeaderCapture() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const config = this.getConfig();\n        return {\n            client: {\n                captureRequestHeaders: (0, utils_1.headerCapture)('request', (_c = (_b = (_a = config.headersToSpanAttributes) === null || _a === void 0 ? void 0 : _a.client) === null || _b === void 0 ? void 0 : _b.requestHeaders) !== null &amp;&amp; _c !== void 0 ? _c : []),\n                captureResponseHeaders: (0, utils_1.headerCapture)('response', (_f = (_e = (_d = config.headersToSpanAttributes) === null || _d === void 0 ? void 0 : _d.client) === null || _e === void 0 ? void 0 : _e.responseHeaders) !== null &amp;&amp; _f !== void 0 ? _f : []),\n            },\n            server: {\n                captureRequestHeaders: (0, utils_1.headerCapture)('request', (_j = (_h = (_g = config.headersToSpanAttributes) === null || _g === void 0 ? void 0 : _g.server) === null || _h === void 0 ? void 0 : _h.requestHeaders) !== null &amp;&amp; _j !== void 0 ? _j : []),\n                captureResponseHeaders: (0, utils_1.headerCapture)('response', (_m = (_l = (_k = config.headersToSpanAttributes) === null || _k === void 0 ? void 0 : _k.server) === null || _l === void 0 ? void 0 : _l.responseHeaders) !== null &amp;&amp; _m !== void 0 ? _m : []),\n            },\n        };\n    }\n}\nexports.HttpInstrumentation = HttpInstrumentation;\n//# sourceMappingURL=http.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2h0dHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxrSUFBb0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLCtKQUFxQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsb0ZBQVE7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLHVMQUFXO0FBQ3JDLDBCQUEwQixtQkFBTyxDQUFDLGdNQUFnQztBQUNsRSxlQUFlLG1CQUFPLENBQUMsK0pBQXFCO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLCtCQUErQixtQkFBTyxDQUFDLHNMQUFxQztBQUM1RSxnQkFBZ0IsbUJBQU8sQ0FBQyxtTEFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0o7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQsc0VBQXNFLFlBQVksdUlBQXVJO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCLEVBQUUsTUFBTTtBQUNoRTtBQUNBO0FBQ0EsZ0pBQWdKO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9IO0FBQ3BIO0FBQ0E7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy9odHRwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuY29uc3QgaW5zdHJ1bWVudGF0aW9uXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uXCIpO1xuY29uc3QgY29yZV8yID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2NvcmVcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBgbm9kZTpodHRwYCBhbmQgYG5vZGU6aHR0cHNgIGluc3RydW1lbnRhdGlvbiBmb3IgT3BlblRlbGVtZXRyeVxuICovXG5jbGFzcyBIdHRwSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwJywgdmVyc2lvbl8xLlZFUlNJT04sIGNvbmZpZyk7XG4gICAgICAgIC8qKiBrZWVwIHRyYWNrIG9uIHNwYW5zIG5vdCBlbmRlZCAqL1xuICAgICAgICB0aGlzLl9zcGFuTm90RW5kZWQgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICB0aGlzLl9zZW1jb252U3RhYmlsaXR5ID0gMiAvKiBPTEQgKi87XG4gICAgICAgIHRoaXMuX2hlYWRlckNhcHR1cmUgPSB0aGlzLl9jcmVhdGVIZWFkZXJDYXB0dXJlKCk7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgKDAsIGNvcmVfMi5nZXRFbnYpKCkuT1RFTF9TRU1DT05WX1NUQUJJTElUWV9PUFRfSU4pIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cC9kdXAnKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cC9kdXAgdGFrZXMgaGlnaGVzdCBwcmVjZWRlbmNlLiBJZiBpdCBpcyBmb3VuZCwgdGhlcmUgaXMgbm8gbmVlZCB0byByZWFkIHRoZSByZXN0IG9mIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VtY29udlN0YWJpbGl0eSA9IDMgLyogRFVQTElDQVRFICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkudG9Mb3dlckNhc2UoKSA9PT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VtY29udlN0YWJpbGl0eSA9IDEgLyogU1RBQkxFICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVNZXRyaWNJbnN0cnVtZW50cygpIHtcbiAgICAgICAgdGhpcy5fb2xkSHR0cFNlcnZlckR1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oJ2h0dHAuc2VydmVyLmR1cmF0aW9uJywge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdNZWFzdXJlcyB0aGUgZHVyYXRpb24gb2YgaW5ib3VuZCBIVFRQIHJlcXVlc3RzLicsXG4gICAgICAgICAgICB1bml0OiAnbXMnLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBhcGlfMS5WYWx1ZVR5cGUuRE9VQkxFLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2xkSHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oJ2h0dHAuY2xpZW50LmR1cmF0aW9uJywge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdNZWFzdXJlcyB0aGUgZHVyYXRpb24gb2Ygb3V0Ym91bmQgSFRUUCByZXF1ZXN0cy4nLFxuICAgICAgICAgICAgdW5pdDogJ21zJyxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogYXBpXzEuVmFsdWVUeXBlLkRPVUJMRSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N0YWJsZUh0dHBTZXJ2ZXJEdXJhdGlvbkhpc3RvZ3JhbSA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVUUklDX0hUVFBfU0VSVkVSX1JFUVVFU1RfRFVSQVRJT04sIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRHVyYXRpb24gb2YgSFRUUCBzZXJ2ZXIgcmVxdWVzdHMuJyxcbiAgICAgICAgICAgIHVuaXQ6ICdzJyxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogYXBpXzEuVmFsdWVUeXBlLkRPVUJMRSxcbiAgICAgICAgICAgIGFkdmljZToge1xuICAgICAgICAgICAgICAgIGV4cGxpY2l0QnVja2V0Qm91bmRhcmllczogW1xuICAgICAgICAgICAgICAgICAgICAwLjAwNSwgMC4wMSwgMC4wMjUsIDAuMDUsIDAuMDc1LCAwLjEsIDAuMjUsIDAuNSwgMC43NSwgMSwgMi41LCA1LFxuICAgICAgICAgICAgICAgICAgICA3LjUsIDEwLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3RhYmxlSHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oc2VtYW50aWNfY29udmVudGlvbnNfMS5NRVRSSUNfSFRUUF9DTElFTlRfUkVRVUVTVF9EVVJBVElPTiwge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEdXJhdGlvbiBvZiBIVFRQIGNsaWVudCByZXF1ZXN0cy4nLFxuICAgICAgICAgICAgdW5pdDogJ3MnLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBhcGlfMS5WYWx1ZVR5cGUuRE9VQkxFLFxuICAgICAgICAgICAgYWR2aWNlOiB7XG4gICAgICAgICAgICAgICAgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBbXG4gICAgICAgICAgICAgICAgICAgIDAuMDA1LCAwLjAxLCAwLjAyNSwgMC4wNSwgMC4wNzUsIDAuMSwgMC4yNSwgMC41LCAwLjc1LCAxLCAyLjUsIDUsXG4gICAgICAgICAgICAgICAgICAgIDcuNSwgMTAsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVjb3JkU2VydmVyRHVyYXRpb24oZHVyYXRpb25Ncywgb2xkQXR0cmlidXRlcywgc3RhYmxlQXR0cmlidXRlcykge1xuICAgICAgICBpZiAoKHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgJiAyIC8qIE9MRCAqLykgPT09XG4gICAgICAgICAgICAyIC8qIE9MRCAqLykge1xuICAgICAgICAgICAgLy8gb2xkIGhpc3RvZ3JhbSBpcyBjb3VudGVkIGluIE1TXG4gICAgICAgICAgICB0aGlzLl9vbGRIdHRwU2VydmVyRHVyYXRpb25IaXN0b2dyYW0ucmVjb3JkKGR1cmF0aW9uTXMsIG9sZEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fc2VtY29udlN0YWJpbGl0eSAmIDEgLyogU1RBQkxFICovKSA9PT1cbiAgICAgICAgICAgIDEgLyogU1RBQkxFICovKSB7XG4gICAgICAgICAgICAvLyBzdGFibGUgaGlzdG9ncmFtIGlzIGNvdW50ZWQgaW4gU1xuICAgICAgICAgICAgdGhpcy5fc3RhYmxlSHR0cFNlcnZlckR1cmF0aW9uSGlzdG9ncmFtLnJlY29yZChkdXJhdGlvbk1zIC8gMTAwMCwgc3RhYmxlQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlY29yZENsaWVudER1cmF0aW9uKGR1cmF0aW9uTXMsIG9sZEF0dHJpYnV0ZXMsIHN0YWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCh0aGlzLl9zZW1jb252U3RhYmlsaXR5ICYgMiAvKiBPTEQgKi8pID09PVxuICAgICAgICAgICAgMiAvKiBPTEQgKi8pIHtcbiAgICAgICAgICAgIC8vIG9sZCBoaXN0b2dyYW0gaXMgY291bnRlZCBpbiBNU1xuICAgICAgICAgICAgdGhpcy5fb2xkSHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtLnJlY29yZChkdXJhdGlvbk1zLCBvbGRBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgJiAxIC8qIFNUQUJMRSAqLykgPT09XG4gICAgICAgICAgICAxIC8qIFNUQUJMRSAqLykge1xuICAgICAgICAgICAgLy8gc3RhYmxlIGhpc3RvZ3JhbSBpcyBjb3VudGVkIGluIFNcbiAgICAgICAgICAgIHRoaXMuX3N0YWJsZUh0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbS5yZWNvcmQoZHVyYXRpb25NcyAvIDEwMDAsIHN0YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbmZpZyhjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlci5zZXRDb25maWcoY29uZmlnKTtcbiAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZSA9IHRoaXMuX2NyZWF0ZUhlYWRlckNhcHR1cmUoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9nZXRIdHRwc0luc3RydW1lbnRhdGlvbigpLCB0aGlzLl9nZXRIdHRwSW5zdHJ1bWVudGF0aW9uKCldO1xuICAgIH1cbiAgICBfZ2V0SHR0cEluc3RydW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbignaHR0cCcsIFsnKiddLCAobW9kdWxlRXhwb3J0cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNFU00gPSBtb2R1bGVFeHBvcnRzW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVPdXRnb2luZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkUmVxdWVzdCA9IHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgJ3JlcXVlc3QnLCB0aGlzLl9nZXRQYXRjaE91dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKCdodHRwJykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRHZXQgPSB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMsICdnZXQnLCB0aGlzLl9nZXRQYXRjaE91dGdvaW5nR2V0RnVuY3Rpb24ocGF0Y2hlZFJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFU00pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gaGFuZGxlIGBpbXBvcnQgaHR0cCBmcm9tICdodHRwJ2AsIHdoaWNoIHJldHVybnMgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3J0LCB3ZSBuZWVkIHRvIHNldCBgbW9kdWxlLmRlZmF1bHQuKmAuXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydHMuZGVmYXVsdC5yZXF1ZXN0ID0gcGF0Y2hlZFJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydHMuZGVmYXVsdC5nZXQgPSBwYXRjaGVkR2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlSW5jb21pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsICdlbWl0JywgdGhpcy5fZ2V0UGF0Y2hJbmNvbWluZ1JlcXVlc3RGdW5jdGlvbignaHR0cCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgICAgICB9LCAobW9kdWxlRXhwb3J0cykgPT4ge1xuICAgICAgICAgICAgaWYgKG1vZHVsZUV4cG9ydHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZU91dGdvaW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAncmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAnZ2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZUluY29taW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsICdlbWl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0SHR0cHNJbnN0cnVtZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZURlZmluaXRpb24oJ2h0dHBzJywgWycqJ10sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0VTTSA9IG1vZHVsZUV4cG9ydHNbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZSc7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZU91dGdvaW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRSZXF1ZXN0ID0gdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLCAncmVxdWVzdCcsIHRoaXMuX2dldFBhdGNoSHR0cHNPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbignaHR0cHMnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZEdldCA9IHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgJ2dldCcsIHRoaXMuX2dldFBhdGNoSHR0cHNPdXRnb2luZ0dldEZ1bmN0aW9uKHBhdGNoZWRSZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRVNNKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGhhbmRsZSBgaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJ2AsIHdoaWNoIHJldHVybnMgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3J0LCB3ZSBuZWVkIHRvIHNldCBgbW9kdWxlLmRlZmF1bHQuKmAuXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydHMuZGVmYXVsdC5yZXF1ZXN0ID0gcGF0Y2hlZFJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydHMuZGVmYXVsdC5nZXQgPSBwYXRjaGVkR2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlSW5jb21pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsICdlbWl0JywgdGhpcy5fZ2V0UGF0Y2hJbmNvbWluZ1JlcXVlc3RGdW5jdGlvbignaHR0cHMnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICAgICAgfSwgKG1vZHVsZUV4cG9ydHMpID0+IHtcbiAgICAgICAgICAgIGlmIChtb2R1bGVFeHBvcnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVPdXRnb2luZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgJ3JlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgJ2dldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVJbmNvbWluZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5TZXJ2ZXIucHJvdG90eXBlLCAnZW1pdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBzcGFucyBmb3IgaW5jb21pbmcgcmVxdWVzdHMsIHJlc3RvcmluZyBzcGFucycgY29udGV4dCBpZiBhcHBsaWVkLlxuICAgICAqL1xuICAgIF9nZXRQYXRjaEluY29taW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5jb21pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50LCBvcmlnaW5hbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgc3BhbnMgZm9yIG91dGdvaW5nIHJlcXVlc3RzLCBzZW5kaW5nIHNwYW5zJyBjb250ZXh0IGZvciBkaXN0cmlidXRlZFxuICAgICAqIHRyYWNpbmcuXG4gICAgICovXG4gICAgX2dldFBhdGNoT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQsIG9yaWdpbmFsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldFBhdGNoT3V0Z29pbmdHZXRGdW5jdGlvbihjbGllbnRSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiAoX29yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICAvLyBSZS1pbXBsZW1lbnQgaHR0cC5nZXQuIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSAoaW5zdGVhZCBvZiB1c2luZ1xuICAgICAgICAgICAgLy8gZ2V0UGF0Y2hPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbiB0byBwYXRjaCBpdCkgYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHRyYWNlIGNvbnRleHQgaGVhZGVyIGJlZm9yZSB0aGUgcmV0dXJuZWQgaHR0cC5DbGllbnRSZXF1ZXN0IGlzXG4gICAgICAgICAgICAvLyBlbmRlZC4gVGhlIE5vZGUuanMgZG9jcyBzdGF0ZSB0aGF0IHRoZSBvbmx5IGRpZmZlcmVuY2VzIGJldHdlZW5cbiAgICAgICAgICAgIC8vIHJlcXVlc3QgYW5kIGdldCBhcmUgdGhhdCAoMSkgZ2V0IGRlZmF1bHRzIHRvIHRoZSBIVFRQIEdFVCBtZXRob2QgYW5kXG4gICAgICAgICAgICAvLyAoMikgdGhlIHJldHVybmVkIHJlcXVlc3Qgb2JqZWN0IGlzIGVuZGVkIGltbWVkaWF0ZWx5LiBUaGUgZm9ybWVyIGlzXG4gICAgICAgICAgICAvLyBhbHJlYWR5IHRydWUgKGF0IGxlYXN0IGluIHN1cHBvcnRlZCBOb2RlIHZlcnNpb25zIHVwIHRvIHYxMCksIHNvIHdlXG4gICAgICAgICAgICAvLyBzaW1wbHkgZm9sbG93IHRoZSBsYXR0ZXIuIFJlZjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS9odHRwLmh0bWwjaHR0cF9odHRwX2dldF9vcHRpb25zX2NhbGxiYWNrXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9jbG91ZC10cmFjZS1ub2RlanMvYmxvYi9tYXN0ZXIvc3JjL2luc3RydW1lbnRhdGlvbnMvaW5zdHJ1bWVudGF0aW9uLWh0dHAudHMjTDE5OFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG91dGdvaW5nR2V0UmVxdWVzdChvcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxID0gY2xpZW50UmVxdWVzdChvcHRpb25zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICByZXEuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBQYXRjaGVzIEhUVFBTIG91dGdvaW5nIHJlcXVlc3RzICovXG4gICAgX2dldFBhdGNoSHR0cHNPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBodHRwc091dGdvaW5nUmVxdWVzdChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgIG9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gTWFrZXMgc3VyZSBvcHRpb25zIHdpbGwgaGF2ZSBkZWZhdWx0IEhUVFBTIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSAnaHR0cHMnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgIT09ICdVUkwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9zZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZ2V0UGF0Y2hPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQpKG9yaWdpbmFsKShvcHRpb25zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMucHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sIHx8ICdodHRwczonO1xuICAgICAgICBvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgNDQzO1xuICAgIH1cbiAgICAvKiogUGF0Y2hlcyBIVFRQUyBvdXRnb2luZyBnZXQgcmVxdWVzdHMgKi9cbiAgICBfZ2V0UGF0Y2hIdHRwc091dGdvaW5nR2V0RnVuY3Rpb24oY2xpZW50UmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBzT3V0Z29pbmdSZXF1ZXN0KFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgb3B0aW9ucywgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX2dldFBhdGNoT3V0Z29pbmdHZXRGdW5jdGlvbihjbGllbnRSZXF1ZXN0KShvcmlnaW5hbCkob3B0aW9ucywgLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIGEgY2xpZW50IHJlcXVlc3QgdG8gZW5kIHNwYW4gYW5kIGFkZCBzcGFuIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QuXG4gICAgICogQHBhcmFtIHNwYW4gcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgcmVwcmVzZW50aW5nIHRoZSBzdGFydCB0aW1lIG9mIHRoZSByZXF1ZXN0IHRvIGNhbGN1bGF0ZSBkdXJhdGlvbiBpbiBNZXRyaWNcbiAgICAgKiBAcGFyYW0gb2xkTWV0cmljQXR0cmlidXRlcyBtZXRyaWMgYXR0cmlidXRlcyBmb3Igb2xkIHNlbWFudGljIGNvbnZlbnRpb25zXG4gICAgICogQHBhcmFtIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMgbWV0cmljIGF0dHJpYnV0ZXMgZm9yIG5ldyBzZW1hbnRpYyBjb252ZW50aW9uc1xuICAgICAqL1xuICAgIF90cmFjZUNsaWVudFJlcXVlc3QocmVxdWVzdCwgc3Bhbiwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmdldENvbmZpZygpLnJlcXVlc3RIb29rKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsUmVxdWVzdEhvb2soc3BhbiwgcmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIHJlcXVlc3QgaGFzIGVycm9yZWQgb3IgdGhlIHJlc3BvbnNlIGhhcyBlbmRlZC9lcnJvcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHJlc3BvbnNlRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgLypcbiAgICAgICAgICogVXNlciAncmVzcG9uc2UnIGV2ZW50IGxpc3RlbmVycyBjYW4gYmUgYWRkZWQgYmVmb3JlIG91ciBsaXN0ZW5lcixcbiAgICAgICAgICogZm9yY2Ugb3VyIGxpc3RlbmVyIHRvIGJlIHRoZSBmaXJzdCwgc28gcmVzcG9uc2UgZW1pdHRlciBpcyBib3VuZFxuICAgICAgICAgKiBiZWZvcmUgYW55IHVzZXIgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVlc3QucHJlcGVuZExpc3RlbmVyKCdyZXNwb25zZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGlhZy5kZWJ1Zygnb3V0Z29pbmdSZXF1ZXN0IG9uIHJlc3BvbnNlKCknKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lmxpc3RlbmVyQ291bnQoJ3Jlc3BvbnNlJykgPD0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UpKHJlc3BvbnNlLCB0aGlzLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhyZXNwb25zZUF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgb2xkTWV0cmljQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24ob2xkTWV0cmljQXR0cmlidXRlcywgKDAsIHV0aWxzXzEuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UpKHJlc3BvbnNlQXR0cmlidXRlcykpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q29uZmlnKCkucmVzcG9uc2VIb29rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbFJlc3BvbnNlSG9vayhzcGFuLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJDYXB0dXJlLmNsaWVudC5jYXB0dXJlUmVxdWVzdEhlYWRlcnMoc3BhbiwgaGVhZGVyID0+IHJlcXVlc3QuZ2V0SGVhZGVyKGhlYWRlcikpO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZS5jbGllbnQuY2FwdHVyZVJlc3BvbnNlSGVhZGVycyhzcGFuLCBoZWFkZXIgPT4gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCByZXNwb25zZSk7XG4gICAgICAgICAgICBjb25zdCBlbmRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpYWcuZGVidWcoJ291dGdvaW5nUmVxdWVzdCBvbiBlbmQoKScpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCAmJiAhcmVzcG9uc2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0geyBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVoYXZlcyBzYW1lIGZvciBuZXcgYW5kIG9sZCBzZW1jb252XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6ICgwLCB1dGlsc18xLnBhcnNlUmVzcG9uc2VTdGF0dXMpKGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgcmVzcG9uc2Uuc3RhdHVzQ29kZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q29uZmlnKCkuYXBwbHlDdXN0b21BdHRyaWJ1dGVzT25TcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB0aGlzLmdldENvbmZpZygpLmFwcGx5Q3VzdG9tQXR0cmlidXRlc09uU3BhbihzcGFuLCByZXF1ZXN0LCByZXNwb25zZSksICgpID0+IHsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9wdWxsLzM2MjUjaXNzdWVjb21tZW50LTE0NzU2NzM1MzNcbiAgICAgICAgICAgIGlmIChzZW12ZXIubHQocHJvY2Vzcy52ZXJzaW9uLCAnMTYuMC4wJykpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbignY2xvc2UnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKGV2ZW50c18xLmVycm9yTW9uaXRvciwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlhZy5kZWJ1Zygnb3V0Z29pbmdSZXF1ZXN0IG9uIGVycm9yKCknLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5zZXRTcGFuV2l0aEVycm9yKShzcGFuLCBlcnJvciwgdGhpcy5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnLmRlYnVnKCdvdXRnb2luZ1JlcXVlc3Qgb24gcmVxdWVzdCBjbG9zZSgpJyk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlc3BvbnNlRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5vbihldmVudHNfMS5lcnJvck1vbml0b3IsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGlhZy5kZWJ1Zygnb3V0Z29pbmdSZXF1ZXN0IG9uIHJlcXVlc3QgZXJyb3IoKScsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2VGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS5zZXRTcGFuV2l0aEVycm9yKShzcGFuLCBlcnJvciwgdGhpcy5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RpYWcuZGVidWcoJ2h0dHAuQ2xpZW50UmVxdWVzdCByZXR1cm4gcmVxdWVzdCcpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgX2luY29taW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGluY29taW5nUmVxdWVzdChldmVudCwgLi4uYXJncykge1xuICAgICAgICAgICAgLy8gT25seSB0cmFjZXMgcmVxdWVzdCBldmVudHNcbiAgICAgICAgICAgIGlmIChldmVudCAhPT0gJ3JlcXVlc3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtldmVudCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZCB8fCAnR0VUJztcbiAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fZGlhZy5kZWJ1ZyhgJHtjb21wb25lbnR9IGluc3RydW1lbnRhdGlvbiBpbmNvbWluZ1JlcXVlc3RgKTtcbiAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gaW5zdHJ1bWVudGF0aW9uLmdldENvbmZpZygpKS5pZ25vcmVJbmNvbWluZ1JlcXVlc3RIb29rKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgcmVxdWVzdCk7IH0sIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2RpYWcuZXJyb3IoJ2NhdWdodCBpZ25vcmVJbmNvbWluZ1JlcXVlc3RIb29rIGVycm9yOiAnLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5jb250ZXh0LndpdGgoKDAsIGNvcmVfMS5zdXBwcmVzc1RyYWNpbmcpKGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtldmVudCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcbiAgICAgICAgICAgIGNvbnN0IHNwYW5BdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlcykocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHNlcnZlck5hbWU6IGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5zZXJ2ZXJOYW1lLFxuICAgICAgICAgICAgICAgIGhvb2tBdHRyaWJ1dGVzOiBpbnN0cnVtZW50YXRpb24uX2NhbGxTdGFydFNwYW5Ib29rKHJlcXVlc3QsIGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5zdGFydEluY29taW5nU3Bhbkhvb2spLFxuICAgICAgICAgICAgICAgIHNlbWNvbnZTdGFiaWxpdHk6IGluc3RydW1lbnRhdGlvbi5fc2VtY29udlN0YWJpbGl0eSxcbiAgICAgICAgICAgIH0sIGluc3RydW1lbnRhdGlvbi5fZGlhZyk7XG4gICAgICAgICAgICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5TRVJWRVIsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogc3BhbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gKDAsIGNvcmVfMS5oclRpbWUpKCk7XG4gICAgICAgICAgICBjb25zdCBvbGRNZXRyaWNBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcykoc3BhbkF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgLy8gcmVxdWVzdCBtZXRob2QgYW5kIHVybC5zY2hlbWUgYXJlIGJvdGggcmVxdWlyZWQgc3BhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjb25zdCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF06IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXSxcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9TQ0hFTUVdOiBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmVjb21tZW5kZWQgaWYgYW5kIG9ubHkgaWYgb25lIHdhcyBzZW50LCBzYW1lIGFzIHNwYW4gcmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgIGlmIChzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXSkge1xuICAgICAgICAgICAgICAgIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl0gPVxuICAgICAgICAgICAgICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGFwaV8xLnByb3BhZ2F0aW9uLmV4dHJhY3QoYXBpXzEuUk9PVF9DT05URVhULCBoZWFkZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0SHR0cFNwYW4obWV0aG9kLCBzcGFuT3B0aW9ucywgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IHJwY01ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGNvcmVfMi5SUENUeXBlLkhUVFAsXG4gICAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKCgwLCBjb3JlXzIuc2V0UlBDTWV0YWRhdGEpKGFwaV8xLnRyYWNlLnNldFNwYW4oY3R4LCBzcGFuKSwgcnBjTWV0YWRhdGEpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5yZXF1ZXN0SG9vaykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2NhbGxSZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5yZXNwb25zZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9jYWxsUmVzcG9uc2VIb29rKHNwYW4sIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9oZWFkZXJDYXB0dXJlLnNlcnZlci5jYXB0dXJlUmVxdWVzdEhlYWRlcnMoc3BhbiwgaGVhZGVyID0+IHJlcXVlc3QuaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgICAgICAgICAvLyBBZnRlciAnZXJyb3InLCBubyBmdXJ0aGVyIGV2ZW50cyBvdGhlciB0aGFuICdjbG9zZScgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gICAgICAgICAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX29uU2VydmVyUmVzcG9uc2VGaW5pc2gocmVxdWVzdCwgcmVzcG9uc2UsIHNwYW4sIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oZXZlbnRzXzEuZXJyb3JNb25pdG9yLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9vblNlcnZlclJlc3BvbnNlRXJyb3Ioc3Bhbiwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcywgc3RhcnRUaW1lLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2V2ZW50LCAuLi5hcmdzXSksIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5zZXRTcGFuV2l0aEVycm9yKShzcGFuLCBlcnJvciwgaW5zdHJ1bWVudGF0aW9uLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5TRVJWRVIsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9vdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQsIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBvdXRnb2luZ1JlcXVlc3Qob3B0aW9ucywgLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc1ZhbGlkT3B0aW9uc1R5cGUpKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHRyYU9wdGlvbnMgPSB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMgaW5zdGFuY2VvZiB1cmwuVVJMKVxuICAgICAgICAgICAgICAgID8gYXJncy5zaGlmdCgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgaW52YWxpZFVybCwgb3B0aW9uc1BhcnNlZCB9ID0gKDAsIHV0aWxzXzEuZ2V0UmVxdWVzdEluZm8pKGluc3RydW1lbnRhdGlvbi5fZGlhZywgb3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm9kZSA4J3MgaHR0cHMgbW9kdWxlIGRpcmVjdGx5IGNhbGwgdGhlIGh0dHAgb25lIHNvIHRvIGF2b2lkIGNyZWF0aW5nXG4gICAgICAgICAgICAgKiAyIHNwYW4gZm9yIHRoZSBzYW1lIHJlcXVlc3Qgd2UgbmVlZCB0byBjaGVjayB0aGF0IHRoZSBwcm90b2NvbCBpcyBjb3JyZWN0XG4gICAgICAgICAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjE3LjAvbGliL2h0dHBzLmpzI0wyNDVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJ2h0dHAnICYmXG4gICAgICAgICAgICAgICAgc2VtdmVyLmx0KHByb2Nlc3MudmVyc2lvbiwgJzkuMC4wJykgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zUGFyc2VkLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbb3B0aW9uc1BhcnNlZCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gaW5zdHJ1bWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5nZXRDb25maWcoKSkuaWdub3JlT3V0Z29pbmdSZXF1ZXN0SG9vaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG9wdGlvbnNQYXJzZWQpO1xuICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fZGlhZy5lcnJvcignY2F1Z2h0IGlnbm9yZU91dGdvaW5nUmVxdWVzdEhvb2sgZXJyb3I6ICcsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zUGFyc2VkLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGhvc3RuYW1lLCBwb3J0IH0gPSAoMCwgdXRpbHNfMS5leHRyYWN0SG9zdG5hbWVBbmRQb3J0KShvcHRpb25zUGFyc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzKShvcHRpb25zUGFyc2VkLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgaG9va0F0dHJpYnV0ZXM6IGluc3RydW1lbnRhdGlvbi5fY2FsbFN0YXJ0U3Bhbkhvb2sob3B0aW9uc1BhcnNlZCwgaW5zdHJ1bWVudGF0aW9uLmdldENvbmZpZygpLnN0YXJ0T3V0Z29pbmdTcGFuSG9vayksXG4gICAgICAgICAgICB9LCBpbnN0cnVtZW50YXRpb24uX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gKDAsIGNvcmVfMS5oclRpbWUpKCk7XG4gICAgICAgICAgICBjb25zdCBvbGRNZXRyaWNBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcykoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAvLyByZXF1ZXN0IG1ldGhvZCwgc2VydmVyIGFkZHJlc3MsIGFuZCBzZXJ2ZXIgcG9ydCBhcmUgYm90aCByZXF1aXJlZCBzcGFuIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNvbnN0IHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTogYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF0sXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9BRERSRVNTXSxcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXTogYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIGlmIGFuZCBvbmx5IGlmIG9uZSB3YXMgc2VudCwgc2FtZSBhcyBzcGFuIHJlcXVpcmVtZW50XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV0pIHtcbiAgICAgICAgICAgICAgICBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXSA9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVjb21tZW5kZWQgaWYgYW5kIG9ubHkgaWYgb25lIHdhcyBzZW50LCBzYW1lIGFzIHNwYW4gcmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dKSB7XG4gICAgICAgICAgICAgICAgc3RhYmxlTWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXSA9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5DTElFTlQsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gaW5zdHJ1bWVudGF0aW9uLl9zdGFydEh0dHBTcGFuKG1ldGhvZCwgc3Bhbk9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q29udGV4dCA9IGFwaV8xLmNvbnRleHQuYWN0aXZlKCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29udGV4dCA9IGFwaV8xLnRyYWNlLnNldFNwYW4ocGFyZW50Q29udGV4dCwgc3Bhbik7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnNQYXJzZWQuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNQYXJzZWQuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGhlYWRlcnMgb2JqZWN0IHRvIGF2b2lkIG11dGF0aW5nIGFuIG9iamVjdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjYWxsZXIgbWlnaHQgaGF2ZSBhIHJlZmVyZW5jZSB0by5cbiAgICAgICAgICAgICAgICBvcHRpb25zUGFyc2VkLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zUGFyc2VkLmhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KHJlcXVlc3RDb250ZXh0LCBvcHRpb25zUGFyc2VkLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChyZXF1ZXN0Q29udGV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogVGhlIHJlc3BvbnNlIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQgYmVmb3JlIENsaWVudFJlcXVlc3QgaXMgYm91bmQsXG4gICAgICAgICAgICAgICAgICogdGh1cyBpdCBpcyBuZWVkZWQgdG8gYmluZCBpdCBiZWZvcmUgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBhcGlfMS5jb250ZXh0LmJpbmQocGFyZW50Q29udGV4dCwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludmFsaWRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgdXJsIGlzIGludmFsaWQsIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gaW5qZWN0aW5nIGNvbnRleHQgYXMgaXQgd2lsbCBmYWlsIHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzaW5nIGluIHdoYXQgdGhlIHVzZXIgcHJvdmlkZWQgd2lsbCBnaXZlIHRoZSB1c2VyIGFuIGVycm9yIHRoYXQgbWF0Y2hlcyB3aGF0IHRoZXknZCBzZWUgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGluc3RydW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbb3B0aW9ucywgLi4uYXJnc10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zUGFyc2VkLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuc2V0U3BhbldpdGhFcnJvcikoc3BhbiwgZXJyb3IsIGluc3RydW1lbnRhdGlvbi5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2RpYWcuZGVidWcoYCR7Y29tcG9uZW50fSBpbnN0cnVtZW50YXRpb24gb3V0Z29pbmdSZXF1ZXN0YCk7XG4gICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKHBhcmVudENvbnRleHQsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX3RyYWNlQ2xpZW50UmVxdWVzdChyZXF1ZXN0LCBzcGFuLCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9vblNlcnZlclJlc3BvbnNlRmluaXNoKHJlcXVlc3QsIHJlc3BvbnNlLCBzcGFuLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzLCBzdGFydFRpbWUpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlKShyZXF1ZXN0LCByZXNwb25zZSwgdGhpcy5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgIG9sZE1ldHJpY0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKG9sZE1ldHJpY0F0dHJpYnV0ZXMsICgwLCB1dGlsc18xLmdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlKShhdHRyaWJ1dGVzKSk7XG4gICAgICAgIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMsICgwLCB1dGlsc18xLmdldEluY29taW5nU3RhYmxlUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlKShhdHRyaWJ1dGVzKSk7XG4gICAgICAgIHRoaXMuX2hlYWRlckNhcHR1cmUuc2VydmVyLmNhcHR1cmVSZXNwb25zZUhlYWRlcnMoc3BhbiwgaGVhZGVyID0+IHJlc3BvbnNlLmdldEhlYWRlcihoZWFkZXIpKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiAoMCwgdXRpbHNfMS5wYXJzZVJlc3BvbnNlU3RhdHVzKShhcGlfMS5TcGFuS2luZC5TRVJWRVIsIHJlc3BvbnNlLnN0YXR1c0NvZGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9ST1VURV07XG4gICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgc3Bhbi51cGRhdGVOYW1lKGAke3JlcXVlc3QubWV0aG9kIHx8ICdHRVQnfSAke3JvdXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldENvbmZpZygpLmFwcGx5Q3VzdG9tQXR0cmlidXRlc09uU3Bhbikge1xuICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHRoaXMuZ2V0Q29uZmlnKCkuYXBwbHlDdXN0b21BdHRyaWJ1dGVzT25TcGFuKHNwYW4sIHJlcXVlc3QsIHJlc3BvbnNlKSwgKCkgPT4geyB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLlNFUlZFUiwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgX29uU2VydmVyUmVzcG9uc2VFcnJvcihzcGFuLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzLCBzdGFydFRpbWUsIGVycm9yKSB7XG4gICAgICAgICgwLCB1dGlsc18xLnNldFNwYW5XaXRoRXJyb3IpKHNwYW4sIGVycm9yLCB0aGlzLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgLy8gVE9ETyBnZXQgZXJyb3IgYXR0cmlidXRlcyBmb3IgbWV0cmljc1xuICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLlNFUlZFUiwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgX3N0YXJ0SHR0cFNwYW4obmFtZSwgb3B0aW9ucywgY3R4ID0gYXBpXzEuY29udGV4dC5hY3RpdmUoKSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJZiBhIHBhcmVudCBpcyByZXF1aXJlZCBidXQgbm90IHByZXNlbnQsIHdlIHVzZSBhIGBOb29wU3BhbmAgdG8gc3RpbGxcbiAgICAgICAgICogcHJvcGFnYXRlIGNvbnRleHQgd2l0aG91dCByZWNvcmRpbmcgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXF1aXJlUGFyZW50ID0gb3B0aW9ucy5raW5kID09PSBhcGlfMS5TcGFuS2luZC5DTElFTlRcbiAgICAgICAgICAgID8gdGhpcy5nZXRDb25maWcoKS5yZXF1aXJlUGFyZW50Zm9yT3V0Z29pbmdTcGFuc1xuICAgICAgICAgICAgOiB0aGlzLmdldENvbmZpZygpLnJlcXVpcmVQYXJlbnRmb3JJbmNvbWluZ1NwYW5zO1xuICAgICAgICBsZXQgc3BhbjtcbiAgICAgICAgY29uc3QgY3VycmVudFNwYW4gPSBhcGlfMS50cmFjZS5nZXRTcGFuKGN0eCk7XG4gICAgICAgIGlmIChyZXF1aXJlUGFyZW50ID09PSB0cnVlICYmIGN1cnJlbnRTcGFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4gPSBhcGlfMS50cmFjZS53cmFwU3BhbkNvbnRleHQoYXBpXzEuSU5WQUxJRF9TUEFOX0NPTlRFWFQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVpcmVQYXJlbnQgPT09IHRydWUgJiYgKGN1cnJlbnRTcGFuID09PSBudWxsIHx8IGN1cnJlbnRTcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U3Bhbi5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSkge1xuICAgICAgICAgICAgc3BhbiA9IGN1cnJlbnRTcGFuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihuYW1lLCBvcHRpb25zLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NwYW5Ob3RFbmRlZC5hZGQoc3Bhbik7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBfY2xvc2VIdHRwU3BhbihzcGFuLCBzcGFuS2luZCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3Bhbk5vdEVuZGVkLmhhcyhzcGFuKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIHRoaXMuX3NwYW5Ob3RFbmRlZC5kZWxldGUoc3Bhbik7XG4gICAgICAgIC8vIFJlY29yZCBtZXRyaWNzXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gKDAsIGNvcmVfMS5oclRpbWVUb01pbGxpc2Vjb25kcykoKDAsIGNvcmVfMS5oclRpbWVEdXJhdGlvbikoc3RhcnRUaW1lLCAoMCwgY29yZV8xLmhyVGltZSkoKSkpO1xuICAgICAgICBpZiAoc3BhbktpbmQgPT09IGFwaV8xLlNwYW5LaW5kLlNFUlZFUikge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkU2VydmVyRHVyYXRpb24oZHVyYXRpb24sIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwYW5LaW5kID09PSBhcGlfMS5TcGFuS2luZC5DTElFTlQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZENsaWVudER1cmF0aW9uKGR1cmF0aW9uLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2FsbFJlc3BvbnNlSG9vayhzcGFuLCByZXNwb25zZSkge1xuICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gdGhpcy5nZXRDb25maWcoKS5yZXNwb25zZUhvb2soc3BhbiwgcmVzcG9uc2UpLCAoKSA9PiB7IH0sIHRydWUpO1xuICAgIH1cbiAgICBfY2FsbFJlcXVlc3RIb29rKHNwYW4sIHJlcXVlc3QpIHtcbiAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHRoaXMuZ2V0Q29uZmlnKCkucmVxdWVzdEhvb2soc3BhbiwgcmVxdWVzdCksICgpID0+IHsgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIF9jYWxsU3RhcnRTcGFuSG9vayhyZXF1ZXN0LCBob29rRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIGhvb2tGdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGhvb2tGdW5jKHJlcXVlc3QpLCAoKSA9PiB7IH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jcmVhdGVIZWFkZXJDYXB0dXJlKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudDoge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVSZXF1ZXN0SGVhZGVyczogKDAsIHV0aWxzXzEuaGVhZGVyQ2FwdHVyZSkoJ3JlcXVlc3QnLCAoX2MgPSAoX2IgPSAoX2EgPSBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGllbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXF1ZXN0SGVhZGVycykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pLFxuICAgICAgICAgICAgICAgIGNhcHR1cmVSZXNwb25zZUhlYWRlcnM6ICgwLCB1dGlsc18xLmhlYWRlckNhcHR1cmUpKCdyZXNwb25zZScsIChfZiA9IChfZSA9IChfZCA9IGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNsaWVudCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlc3BvbnNlSGVhZGVycykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogW10pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcnZlcjoge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVSZXF1ZXN0SGVhZGVyczogKDAsIHV0aWxzXzEuaGVhZGVyQ2FwdHVyZSkoJ3JlcXVlc3QnLCAoX2ogPSAoX2ggPSAoX2cgPSBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5zZXJ2ZXIpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SGVhZGVycykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogW10pLFxuICAgICAgICAgICAgICAgIGNhcHR1cmVSZXNwb25zZUhlYWRlcnM6ICgwLCB1dGlsc18xLmhlYWRlckNhcHR1cmUpKCdyZXNwb25zZScsIChfbSA9IChfbCA9IChfayA9IGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLnNlcnZlcikgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnJlc3BvbnNlSGVhZGVycykgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogW10pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHBJbnN0cnVtZW50YXRpb24gPSBIdHRwSW5zdHJ1bWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js":</span>
<span class="cstat-no" title="statement not covered" >/*!********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpInstrumentation = void 0;\nvar http_1 = __webpack_require__(/*! ./http */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js\");\nObject.defineProperty(exports, \"HttpInstrumentation\", ({ enumerable: true, get: function () { return http_1.HttpInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixhQUFhLG1CQUFPLENBQUMsaUxBQVE7QUFDN0IsdURBQXNELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ3BJIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHBJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG52YXIgaHR0cF8xID0gcmVxdWlyZShcIi4vaHR0cFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBJbnN0cnVtZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBfMS5IdHRwSW5zdHJ1bWVudGF0aW9uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js":</span>
<span class="cstat-no" title="statement not covered" >/*!********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.headerCapture = exports.getIncomingStableRequestMetricAttributesOnResponse = exports.getIncomingRequestMetricAttributesOnResponse = exports.getIncomingRequestAttributesOnResponse = exports.getIncomingRequestMetricAttributes = exports.getIncomingRequestAttributes = exports.getRemoteClientAddress = exports.getOutgoingRequestMetricAttributesOnResponse = exports.getOutgoingRequestAttributesOnResponse = exports.setAttributesFromHttpKind = exports.getOutgoingRequestMetricAttributes = exports.getOutgoingRequestAttributes = exports.extractHostnameAndPort = exports.isValidOptionsType = exports.getRequestInfo = exports.isCompressed = exports.setResponseContentLengthAttribute = exports.setRequestContentLengthAttribute = exports.setSpanWithError = exports.satisfiesPattern = exports.parseResponseStatus = exports.getAbsoluteUrl = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst AttributeNames_1 = __webpack_require__(/*! ./enums/AttributeNames */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js\");\nconst forwardedParse = __webpack_require__(/*! forwarded-parse */ \"(rsc)/./node_modules/.pnpm/forwarded-parse@2.1.2/node_modules/forwarded-parse/index.js\");\n/**\n * Get an absolute url\n */\nconst getAbsoluteUrl = (requestUrl, headers, fallbackProtocol = 'http:') =&gt; {\n    const reqUrlObject = requestUrl || {};\n    const protocol = reqUrlObject.protocol || fallbackProtocol;\n    const port = (reqUrlObject.port || '').toString();\n    const path = reqUrlObject.path || '/';\n    let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || 'localhost';\n    // if there is no port in host and there is a port\n    // it should be displayed if it's not 80 and 443 (default ports)\n    if (host.indexOf(':') === -1 &amp;&amp;\n        port &amp;&amp;\n        port !== '80' &amp;&amp;\n        port !== '443') {\n        host += `:${port}`;\n    }\n    return `${protocol}//${host}${path}`;\n};\nexports.getAbsoluteUrl = getAbsoluteUrl;\n/**\n * Parse status code from HTTP response. [More details](https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-http.md#status)\n */\nconst parseResponseStatus = (kind, statusCode) =&gt; {\n    const upperBound = kind === api_1.SpanKind.CLIENT ? 400 : 500;\n    // 1xx, 2xx, 3xx are OK on client and server\n    // 4xx is OK on server\n    if (statusCode &amp;&amp; statusCode &gt;= 100 &amp;&amp; statusCode &lt; upperBound) {\n        return api_1.SpanStatusCode.UNSET;\n    }\n    // All other codes are error\n    return api_1.SpanStatusCode.ERROR;\n};\nexports.parseResponseStatus = parseResponseStatus;\n/**\n * Check whether the given obj match pattern\n * @param constant e.g URL of request\n * @param pattern Match pattern\n */\nconst satisfiesPattern = (constant, pattern) =&gt; {\n    if (typeof pattern === 'string') {\n        return pattern === constant;\n    }\n    else if (pattern instanceof RegExp) {\n        return pattern.test(constant);\n    }\n    else if (typeof pattern === 'function') {\n        return pattern(constant);\n    }\n    else {\n        throw new TypeError('Pattern is in unsupported datatype');\n    }\n};\nexports.satisfiesPattern = satisfiesPattern;\n/**\n * Sets the span with the error passed in params\n * @param {Span} span the span that need to be set\n * @param {Error} error error that will be set to span\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst setSpanWithError = (span, error, semconvStability) =&gt; {\n    const message = error.message;\n    if ((semconvStability &amp; 2 /* OLD */) === 2 /* OLD */) {\n        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_NAME, error.name);\n        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_MESSAGE, message);\n    }\n    if ((semconvStability &amp; 1 /* STABLE */) ===\n        1 /* STABLE */) {\n        span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, error.name);\n    }\n    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });\n    span.recordException(error);\n};\nexports.setSpanWithError = setSpanWithError;\n/**\n * Adds attributes for request content-length and content-encoding HTTP headers\n * @param { IncomingMessage } Request object whose headers will be analyzed\n * @param { Attributes } Attributes object to be modified\n */\nconst setRequestContentLengthAttribute = (request, attributes) =&gt; {\n    const length = getContentLength(request.headers);\n    if (length === null)\n        return;\n    if ((0, exports.isCompressed)(request.headers)) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH] = length;\n    }\n    else {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;\n    }\n};\nexports.setRequestContentLengthAttribute = setRequestContentLengthAttribute;\n/**\n * Adds attributes for response content-length and content-encoding HTTP headers\n * @param { IncomingMessage } Response object whose headers will be analyzed\n * @param { Attributes } Attributes object to be modified\n *\n * @deprecated this is for an older version of semconv. It is retained for compatibility using OTEL_SEMCONV_STABILITY_OPT_IN\n */\nconst setResponseContentLengthAttribute = (response, attributes) =&gt; {\n    const length = getContentLength(response.headers);\n    if (length === null)\n        return;\n    if ((0, exports.isCompressed)(response.headers)) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH] = length;\n    }\n    else {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;\n    }\n};\nexports.setResponseContentLengthAttribute = setResponseContentLengthAttribute;\nfunction getContentLength(headers) {\n    const contentLengthHeader = headers['content-length'];\n    if (contentLengthHeader === undefined)\n        return null;\n    const contentLength = parseInt(contentLengthHeader, 10);\n    if (isNaN(contentLength))\n        return null;\n    return contentLength;\n}\nconst isCompressed = (headers) =&gt; {\n    const encoding = headers['content-encoding'];\n    return !!encoding &amp;&amp; encoding !== 'identity';\n};\nexports.isCompressed = isCompressed;\n/**\n * Mimics Node.js conversion of URL strings to RequestOptions expected by\n * `http.request` and `https.request` APIs.\n *\n * See https://github.com/nodejs/node/blob/2505e217bba05fc581b572c685c5cf280a16c5a3/lib/internal/url.js#L1415-L1437\n *\n * @param stringUrl\n * @throws TypeError if the URL is not valid.\n */\nfunction stringUrlToHttpOptions(stringUrl) {\n    // This is heavily inspired by Node.js handling of the same situation, trying\n    // to follow it as closely as possible while keeping in mind that we only\n    // deal with string URLs, not URL objects.\n    const { hostname, pathname, port, username, password, search, protocol, hash, href, origin, host, } = new URL(stringUrl);\n    const options = {\n        protocol: protocol,\n        hostname: hostname &amp;&amp; hostname[0] === '[' ? hostname.slice(1, -1) : hostname,\n        hash: hash,\n        search: search,\n        pathname: pathname,\n        path: `${pathname || ''}${search || ''}`,\n        href: href,\n        origin: origin,\n        host: host,\n    };\n    if (port !== '') {\n        options.port = Number(port);\n    }\n    if (username || password) {\n        options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;\n    }\n    return options;\n}\n/**\n * Makes sure options is an url object\n * return an object with default value and parsed options\n * @param logger component logger\n * @param options original options for the request\n * @param [extraOptions] additional options for the request\n */\nconst getRequestInfo = (logger, options, extraOptions) =&gt; {\n    let pathname;\n    let origin;\n    let optionsParsed;\n    let invalidUrl = false;\n    if (typeof options === 'string') {\n        try {\n            const convertedOptions = stringUrlToHttpOptions(options);\n            optionsParsed = convertedOptions;\n            pathname = convertedOptions.pathname || '/';\n        }\n        catch (e) {\n            invalidUrl = true;\n            logger.verbose('Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:', e);\n            // for backward compatibility with how url.parse() behaved.\n            optionsParsed = {\n                path: options,\n            };\n            pathname = optionsParsed.path || '/';\n        }\n        origin = `${optionsParsed.protocol || 'http:'}//${optionsParsed.host}`;\n        if (extraOptions !== undefined) {\n            Object.assign(optionsParsed, extraOptions);\n        }\n    }\n    else if (options instanceof url.URL) {\n        optionsParsed = {\n            protocol: options.protocol,\n            hostname: typeof options.hostname === 'string' &amp;&amp; options.hostname.startsWith('[')\n                ? options.hostname.slice(1, -1)\n                : options.hostname,\n            path: `${options.pathname || ''}${options.search || ''}`,\n        };\n        if (options.port !== '') {\n            optionsParsed.port = Number(options.port);\n        }\n        if (options.username || options.password) {\n            optionsParsed.auth = `${options.username}:${options.password}`;\n        }\n        pathname = options.pathname;\n        origin = options.origin;\n        if (extraOptions !== undefined) {\n            Object.assign(optionsParsed, extraOptions);\n        }\n    }\n    else {\n        optionsParsed = Object.assign({ protocol: options.host ? 'http:' : undefined }, options);\n        const hostname = optionsParsed.host ||\n            (optionsParsed.port != null\n                ? `${optionsParsed.hostname}${optionsParsed.port}`\n                : optionsParsed.hostname);\n        origin = `${optionsParsed.protocol || 'http:'}//${hostname}`;\n        pathname = options.pathname;\n        if (!pathname &amp;&amp; optionsParsed.path) {\n            try {\n                const parsedUrl = new URL(optionsParsed.path, origin);\n                pathname = parsedUrl.pathname || '/';\n            }\n            catch (e) {\n                pathname = '/';\n            }\n        }\n    }\n    // some packages return method in lowercase..\n    // ensure upperCase for consistency\n    const method = optionsParsed.method\n        ? optionsParsed.method.toUpperCase()\n        : 'GET';\n    return { origin, pathname, method, optionsParsed, invalidUrl };\n};\nexports.getRequestInfo = getRequestInfo;\n/**\n * Makes sure options is of type string or object\n * @param options for the request\n */\nconst isValidOptionsType = (options) =&gt; {\n    if (!options) {\n        return false;\n    }\n    const type = typeof options;\n    return type === 'string' || (type === 'object' &amp;&amp; !Array.isArray(options));\n};\nexports.isValidOptionsType = isValidOptionsType;\nconst extractHostnameAndPort = (requestOptions) =&gt; {\n    var _a;\n    if (requestOptions.hostname &amp;&amp; requestOptions.port) {\n        return { hostname: requestOptions.hostname, port: requestOptions.port };\n    }\n    const matches = ((_a = requestOptions.host) === null || _a === void 0 ? void 0 : _a.match(/^([^:/ ]+)(:\\d{1,5})?/)) || null;\n    const hostname = requestOptions.hostname || (matches === null ? 'localhost' : matches[1]);\n    let port = requestOptions.port;\n    if (!port) {\n        if (matches &amp;&amp; matches[2]) {\n            // remove the leading \":\". The extracted port would be something like \":8080\"\n            port = matches[2].substring(1);\n        }\n        else {\n            port = requestOptions.protocol === 'https:' ? '443' : '80';\n        }\n    }\n    return { hostname, port };\n};\nexports.extractHostnameAndPort = extractHostnameAndPort;\n/**\n * Returns outgoing request attributes scoped to the options passed to the request\n * @param {ParsedRequestOptions} requestOptions the same options used to make the request\n * @param {{ component: string, hostname: string, hookAttributes?: Attributes }} options used to pass data needed to create attributes\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getOutgoingRequestAttributes = (requestOptions, options, semconvStability) =&gt; {\n    var _a, _b;\n    const hostname = options.hostname;\n    const port = options.port;\n    const method = (_a = requestOptions.method) !== null &amp;&amp; _a !== void 0 ? _a : 'GET';\n    const normalizedMethod = normalizeMethod(method);\n    const headers = requestOptions.headers || {};\n    const userAgent = headers['user-agent'];\n    const urlFull = (0, exports.getAbsoluteUrl)(requestOptions, headers, `${options.component}:`);\n    const oldAttributes = {\n        [semantic_conventions_1.SEMATTRS_HTTP_URL]: urlFull,\n        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,\n        [semantic_conventions_1.SEMATTRS_HTTP_TARGET]: requestOptions.path || '/',\n        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: hostname,\n        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: (_b = headers.host) !== null &amp;&amp; _b !== void 0 ? _b : `${hostname}:${port}`,\n    };\n    const newAttributes = {\n        // Required attributes\n        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,\n        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: hostname,\n        [semantic_conventions_1.ATTR_SERVER_PORT]: Number(port),\n        [semantic_conventions_1.ATTR_URL_FULL]: urlFull,\n        // leaving out protocol version, it is not yet negotiated\n        // leaving out protocol name, it is only required when protocol version is set\n        // retries and redirects not supported\n        // Opt-in attributes left off for now\n    };\n    // conditionally required if request method required case normalization\n    if (method !== normalizedMethod) {\n        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;\n    }\n    if (userAgent !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;\n    }\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return Object.assign(newAttributes, options.hookAttributes);\n        case 2 /* OLD */:\n            return Object.assign(oldAttributes, options.hookAttributes);\n    }\n    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);\n};\nexports.getOutgoingRequestAttributes = getOutgoingRequestAttributes;\n/**\n * Returns outgoing request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getOutgoingRequestMetricAttributes = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME];\n    //TODO: http.url attribute, it should substitute any parameters to avoid high cardinality.\n    return metricAttributes;\n};\nexports.getOutgoingRequestMetricAttributes = getOutgoingRequestMetricAttributes;\n/**\n * Returns attributes related to the kind of HTTP protocol used\n * @param {string} [kind] Kind of HTTP protocol used: \"1.0\", \"1.1\", \"2\", \"SPDY\" or \"QUIC\".\n */\nconst setAttributesFromHttpKind = (kind, attributes) =&gt; {\n    if (kind) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = kind;\n        if (kind.toUpperCase() !== 'QUIC') {\n            attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_TCP;\n        }\n        else {\n            attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_UDP;\n        }\n    }\n};\nexports.setAttributesFromHttpKind = setAttributesFromHttpKind;\n/**\n * Returns outgoing request attributes scoped to the response data\n * @param {IncomingMessage} response the response object\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getOutgoingRequestAttributesOnResponse = (response, semconvStability) =&gt; {\n    const { statusCode, statusMessage, httpVersion, socket } = response;\n    const oldAttributes = {};\n    const stableAttributes = {};\n    if (statusCode != null) {\n        stableAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = statusCode;\n    }\n    if (socket) {\n        const { remoteAddress, remotePort } = socket;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;\n        // Recommended\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS] = remoteAddress;\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_PORT] = remotePort;\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = response.httpVersion;\n    }\n    (0, exports.setResponseContentLengthAttribute)(response, oldAttributes);\n    if (statusCode) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n        oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || '').toUpperCase();\n    }\n    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return stableAttributes;\n        case 2 /* OLD */:\n            return oldAttributes;\n    }\n    return Object.assign(oldAttributes, stableAttributes);\n};\nexports.getOutgoingRequestAttributesOnResponse = getOutgoingRequestAttributesOnResponse;\n/**\n * Returns outgoing request Metric attributes scoped to the response data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];\n    return metricAttributes;\n};\nexports.getOutgoingRequestMetricAttributesOnResponse = getOutgoingRequestMetricAttributesOnResponse;\nfunction parseHostHeader(hostHeader, proto) {\n    const parts = hostHeader.split(':');\n    // no semicolon implies ipv4 dotted syntax or host name without port\n    // x.x.x.x\n    // example.com\n    if (parts.length === 1) {\n        if (proto === 'http') {\n            return { host: parts[0], port: '80' };\n        }\n        if (proto === 'https') {\n            return { host: parts[0], port: '443' };\n        }\n        return { host: parts[0] };\n    }\n    // single semicolon implies ipv4 dotted syntax or host name with port\n    // x.x.x.x:yyyy\n    // example.com:yyyy\n    if (parts.length === 2) {\n        return {\n            host: parts[0],\n            port: parts[1],\n        };\n    }\n    // more than 2 parts implies ipv6 syntax with multiple colons\n    // [x:x:x:x:x:x:x:x]\n    // [x:x:x:x:x:x:x:x]:yyyy\n    if (parts[0].startsWith('[')) {\n        if (parts[parts.length - 1].endsWith(']')) {\n            if (proto === 'http') {\n                return { host: hostHeader, port: '80' };\n            }\n            if (proto === 'https') {\n                return { host: hostHeader, port: '443' };\n            }\n        }\n        else if (parts[parts.length - 2].endsWith(']')) {\n            return {\n                host: parts.slice(0, -1).join(':'),\n                port: parts[parts.length - 1],\n            };\n        }\n    }\n    // if nothing above matches just return the host header\n    return { host: hostHeader };\n}\n/**\n * Get server.address and port according to http semconv 1.27\n * https://github.com/open-telemetry/semantic-conventions/blob/bf0a2c1134f206f034408b201dbec37960ed60ec/docs/http/http-spans.md#setting-serveraddress-and-serverport-attributes\n */\nfunction getServerAddress(request, component) {\n    const forwardedHeader = request.headers['forwarded'];\n    if (forwardedHeader) {\n        for (const entry of parseForwardedHeader(forwardedHeader)) {\n            if (entry.host) {\n                return parseHostHeader(entry.host, entry.proto);\n            }\n        }\n    }\n    const xForwardedHost = request.headers['x-forwarded-host'];\n    if (typeof xForwardedHost === 'string') {\n        if (typeof request.headers['x-forwarded-proto'] === 'string') {\n            return parseHostHeader(xForwardedHost, request.headers['x-forwarded-proto']);\n        }\n        if (Array.isArray(request.headers['x-forwarded-proto'])) {\n            return parseHostHeader(xForwardedHost, request.headers['x-forwarded-proto'][0]);\n        }\n        return parseHostHeader(xForwardedHost);\n    }\n    else if (Array.isArray(xForwardedHost) &amp;&amp;\n        typeof xForwardedHost[0] === 'string' &amp;&amp;\n        xForwardedHost[0].length &gt; 0) {\n        if (typeof request.headers['x-forwarded-proto'] === 'string') {\n            return parseHostHeader(xForwardedHost[0], request.headers['x-forwarded-proto']);\n        }\n        if (Array.isArray(request.headers['x-forwarded-proto'])) {\n            return parseHostHeader(xForwardedHost[0], request.headers['x-forwarded-proto'][0]);\n        }\n        return parseHostHeader(xForwardedHost[0]);\n    }\n    const host = request.headers['host'];\n    if (typeof host === 'string' &amp;&amp; host.length &gt; 0) {\n        return parseHostHeader(host, component);\n    }\n    return null;\n}\n/**\n * Get server.address and port according to http semconv 1.27\n * https://github.com/open-telemetry/semantic-conventions/blob/bf0a2c1134f206f034408b201dbec37960ed60ec/docs/http/http-spans.md#setting-serveraddress-and-serverport-attributes\n */\nfunction getRemoteClientAddress(request) {\n    const forwardedHeader = request.headers['forwarded'];\n    if (forwardedHeader) {\n        for (const entry of parseForwardedHeader(forwardedHeader)) {\n            if (entry.for) {\n                return entry.for;\n            }\n        }\n    }\n    const xForwardedFor = request.headers['x-forwarded-for'];\n    if (typeof xForwardedFor === 'string') {\n        return xForwardedFor;\n    }\n    else if (Array.isArray(xForwardedFor)) {\n        return xForwardedFor[0];\n    }\n    const remote = request.socket.remoteAddress;\n    if (remote) {\n        return remote;\n    }\n    return null;\n}\nexports.getRemoteClientAddress = getRemoteClientAddress;\nfunction getInfoFromIncomingMessage(component, request, logger) {\n    var _a, _b;\n    try {\n        if (request.headers.host) {\n            return new URL((_a = request.url) !== null &amp;&amp; _a !== void 0 ? _a : '/', `${component}://${request.headers.host}`);\n        }\n        else {\n            const unsafeParsedUrl = new URL((_b = request.url) !== null &amp;&amp; _b !== void 0 ? _b : '/', \n            // using localhost as a workaround to still use the URL constructor for parsing\n            `${component}://localhost`);\n            // since we use localhost as a workaround, ensure we hide the rest of the properties to avoid\n            // our workaround leaking though.\n            return {\n                pathname: unsafeParsedUrl.pathname,\n                search: unsafeParsedUrl.search,\n                toString: function () {\n                    // we cannot use the result of unsafeParsedUrl.toString as it's potentially wrong.\n                    return unsafeParsedUrl.pathname + unsafeParsedUrl.search;\n                },\n            };\n        }\n    }\n    catch (e) {\n        // something is wrong, use undefined - this *should* never happen, logging\n        // for troubleshooting in case it does happen.\n        logger.verbose('Unable to get URL from request', e);\n        return {};\n    }\n}\n/**\n * Returns incoming request attributes scoped to the request data\n * @param {IncomingMessage} request the request object\n * @param {{ component: string, serverName?: string, hookAttributes?: Attributes }} options used to pass data needed to create attributes\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getIncomingRequestAttributes = (request, options, logger) =&gt; {\n    const headers = request.headers;\n    const userAgent = headers['user-agent'];\n    const ips = headers['x-forwarded-for'];\n    const httpVersion = request.httpVersion;\n    const host = headers.host;\n    const hostname = (host === null || host === void 0 ? void 0 : host.replace(/^(.*)(:[0-9]{1,5})/, '$1')) || 'localhost';\n    const method = request.method;\n    const normalizedMethod = normalizeMethod(method);\n    const serverAddress = getServerAddress(request, options.component);\n    const serverName = options.serverName;\n    const remoteClientAddress = getRemoteClientAddress(request);\n    const newAttributes = {\n        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,\n        [semantic_conventions_1.ATTR_URL_SCHEME]: options.component,\n        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.host,\n        [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: request.socket.remoteAddress,\n        [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: request.socket.remotePort,\n        [semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]: request.httpVersion,\n        [semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL]: userAgent,\n    };\n    const parsedUrl = getInfoFromIncomingMessage(options.component, request, logger);\n    if ((parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) != null) {\n        newAttributes[semantic_conventions_1.ATTR_URL_PATH] = parsedUrl.pathname;\n    }\n    if (remoteClientAddress != null) {\n        newAttributes[semantic_conventions_1.ATTR_CLIENT_ADDRESS] = remoteClientAddress;\n    }\n    if ((serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.port) != null) {\n        newAttributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverAddress.port);\n    }\n    // conditionally required if request method required case normalization\n    if (method !== normalizedMethod) {\n        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;\n    }\n    const oldAttributes = {\n        [semantic_conventions_1.SEMATTRS_HTTP_URL]: parsedUrl.toString(),\n        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: host,\n        [semantic_conventions_1.SEMATTRS_NET_HOST_NAME]: hostname,\n        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,\n        [semantic_conventions_1.SEMATTRS_HTTP_SCHEME]: options.component,\n    };\n    if (typeof ips === 'string') {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_CLIENT_IP] = ips.split(',')[0];\n    }\n    if (typeof serverName === 'string') {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_SERVER_NAME] = serverName;\n    }\n    if (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_TARGET] =\n            (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) + (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.search) || '/';\n    }\n    if (userAgent !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;\n    }\n    (0, exports.setRequestContentLengthAttribute)(request, oldAttributes);\n    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);\n    switch (options.semconvStability) {\n        case 1 /* STABLE */:\n            return Object.assign(newAttributes, options.hookAttributes);\n        case 2 /* OLD */:\n            return Object.assign(oldAttributes, options.hookAttributes);\n    }\n    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);\n};\nexports.getIncomingRequestAttributes = getIncomingRequestAttributes;\n/**\n * Returns incoming request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n * @param {{ component: string }} options used to pass data needed to create attributes\n */\nconst getIncomingRequestMetricAttributes = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];\n    //TODO: http.target attribute, it should substitute any parameters to avoid high cardinality.\n    return metricAttributes;\n};\nexports.getIncomingRequestMetricAttributes = getIncomingRequestMetricAttributes;\n/**\n * Returns incoming request attributes scoped to the response data\n * @param {(ServerResponse &amp; { socket: Socket; })} response the response object\n */\nconst getIncomingRequestAttributesOnResponse = (request, response, semconvStability) =&gt; {\n    // take socket from the request,\n    // since it may be detached from the response object in keep-alive mode\n    const { socket } = request;\n    const { statusCode, statusMessage } = response;\n    const newAttributes = {\n        [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: statusCode,\n    };\n    const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());\n    const oldAttributes = {};\n    if (socket) {\n        const { localAddress, localPort, remoteAddress, remotePort } = socket;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_IP] = localAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = localPort;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;\n    }\n    oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n    oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || '').toUpperCase();\n    if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP &amp;&amp; rpcMetadata.route !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = rpcMetadata.route;\n        newAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = rpcMetadata.route;\n    }\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return newAttributes;\n        case 2 /* OLD */:\n            return oldAttributes;\n    }\n    return Object.assign(oldAttributes, newAttributes);\n};\nexports.getIncomingRequestAttributesOnResponse = getIncomingRequestAttributesOnResponse;\n/**\n * Returns incoming request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getIncomingRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT];\n    if (spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] !== undefined) {\n        metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n    }\n    return metricAttributes;\n};\nexports.getIncomingRequestMetricAttributesOnResponse = getIncomingRequestMetricAttributesOnResponse;\nconst getIncomingStableRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] !== undefined) {\n        metricAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n    }\n    // required if and only if one was sent, same as span requirement\n    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {\n        metricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] =\n            spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];\n    }\n    return metricAttributes;\n};\nexports.getIncomingStableRequestMetricAttributesOnResponse = getIncomingStableRequestMetricAttributesOnResponse;\nfunction headerCapture(type, headers) {\n    const normalizedHeaders = new Map();\n    for (let i = 0, len = headers.length; i &lt; len; i++) {\n        const capturedHeader = headers[i].toLowerCase();\n        normalizedHeaders.set(capturedHeader, capturedHeader.replace(/-/g, '_'));\n    }\n    return (span, getHeader) =&gt; {\n        for (const capturedHeader of normalizedHeaders.keys()) {\n            const value = getHeader(capturedHeader);\n            if (value === undefined) {\n                continue;\n            }\n            const normalizedHeader = normalizedHeaders.get(capturedHeader);\n            const key = `http.${type}.header.${normalizedHeader}`;\n            if (typeof value === 'string') {\n                span.setAttribute(key, [value]);\n            }\n            else if (Array.isArray(value)) {\n                span.setAttribute(key, value);\n            }\n            else {\n                span.setAttribute(key, [value]);\n            }\n        }\n    };\n}\nexports.headerCapture = headerCapture;\nconst KNOWN_METHODS = new Set([\n    // methods from https://www.rfc-editor.org/rfc/rfc9110.html#name-methods\n    'GET',\n    'HEAD',\n    'POST',\n    'PUT',\n    'DELETE',\n    'CONNECT',\n    'OPTIONS',\n    'TRACE',\n    // PATCH from https://www.rfc-editor.org/rfc/rfc5789.html\n    'PATCH',\n]);\nfunction normalizeMethod(method) {\n    if (method == null) {\n        return 'GET';\n    }\n    const upper = method.toUpperCase();\n    if (KNOWN_METHODS.has(upper)) {\n        return upper;\n    }\n    return '_OTHER';\n}\nfunction parseForwardedHeader(header) {\n    try {\n        return forwardedParse(header);\n    }\n    catch (_a) {\n        return [];\n    }\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLDBEQUEwRCxHQUFHLG9EQUFvRCxHQUFHLDhDQUE4QyxHQUFHLDBDQUEwQyxHQUFHLG9DQUFvQyxHQUFHLDhCQUE4QixHQUFHLG9EQUFvRCxHQUFHLDhDQUE4QyxHQUFHLGlDQUFpQyxHQUFHLDBDQUEwQyxHQUFHLG9DQUFvQyxHQUFHLDhCQUE4QixHQUFHLDBCQUEwQixHQUFHLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLHlDQUF5QyxHQUFHLHdDQUF3QyxHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQjtBQUNqMEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGtJQUFvQjtBQUMxQywrQkFBK0IsbUJBQU8sQ0FBQyxzTEFBcUM7QUFDNUUsZUFBZSxtQkFBTyxDQUFDLCtKQUFxQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIseUJBQXlCLG1CQUFPLENBQUMsaU5BQXdCO0FBQ3pELHVCQUF1QixtQkFBTyxDQUFDLCtHQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLGNBQWMsU0FBUyxJQUFJLEtBQUssRUFBRSxLQUFLO0FBQ3ZDO0FBQ0Esc0JBQXNC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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjJfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhlYWRlckNhcHR1cmUgPSBleHBvcnRzLmdldEluY29taW5nU3RhYmxlUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSBleHBvcnRzLmdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMgPSBleHBvcnRzLmdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSBleHBvcnRzLmdldFJlbW90ZUNsaWVudEFkZHJlc3MgPSBleHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGV4cG9ydHMuc2V0QXR0cmlidXRlc0Zyb21IdHRwS2luZCA9IGV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IGV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlcyA9IGV4cG9ydHMuZXh0cmFjdEhvc3RuYW1lQW5kUG9ydCA9IGV4cG9ydHMuaXNWYWxpZE9wdGlvbnNUeXBlID0gZXhwb3J0cy5nZXRSZXF1ZXN0SW5mbyA9IGV4cG9ydHMuaXNDb21wcmVzc2VkID0gZXhwb3J0cy5zZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSBleHBvcnRzLnNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlID0gZXhwb3J0cy5zZXRTcGFuV2l0aEVycm9yID0gZXhwb3J0cy5zYXRpc2ZpZXNQYXR0ZXJuID0gZXhwb3J0cy5wYXJzZVJlc3BvbnNlU3RhdHVzID0gZXhwb3J0cy5nZXRBYnNvbHV0ZVVybCA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2NvcmVcIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgQXR0cmlidXRlTmFtZXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zL0F0dHJpYnV0ZU5hbWVzXCIpO1xuY29uc3QgZm9yd2FyZGVkUGFyc2UgPSByZXF1aXJlKFwiZm9yd2FyZGVkLXBhcnNlXCIpO1xuLyoqXG4gKiBHZXQgYW4gYWJzb2x1dGUgdXJsXG4gKi9cbmNvbnN0IGdldEFic29sdXRlVXJsID0gKHJlcXVlc3RVcmwsIGhlYWRlcnMsIGZhbGxiYWNrUHJvdG9jb2wgPSAnaHR0cDonKSA9PiB7XG4gICAgY29uc3QgcmVxVXJsT2JqZWN0ID0gcmVxdWVzdFVybCB8fCB7fTtcbiAgICBjb25zdCBwcm90b2NvbCA9IHJlcVVybE9iamVjdC5wcm90b2NvbCB8fCBmYWxsYmFja1Byb3RvY29sO1xuICAgIGNvbnN0IHBvcnQgPSAocmVxVXJsT2JqZWN0LnBvcnQgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgcGF0aCA9IHJlcVVybE9iamVjdC5wYXRoIHx8ICcvJztcbiAgICBsZXQgaG9zdCA9IHJlcVVybE9iamVjdC5ob3N0IHx8IHJlcVVybE9iamVjdC5ob3N0bmFtZSB8fCBoZWFkZXJzLmhvc3QgfHwgJ2xvY2FsaG9zdCc7XG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gcG9ydCBpbiBob3N0IGFuZCB0aGVyZSBpcyBhIHBvcnRcbiAgICAvLyBpdCBzaG91bGQgYmUgZGlzcGxheWVkIGlmIGl0J3Mgbm90IDgwIGFuZCA0NDMgKGRlZmF1bHQgcG9ydHMpXG4gICAgaWYgKGhvc3QuaW5kZXhPZignOicpID09PSAtMSAmJlxuICAgICAgICBwb3J0ICYmXG4gICAgICAgIHBvcnQgIT09ICc4MCcgJiZcbiAgICAgICAgcG9ydCAhPT0gJzQ0MycpIHtcbiAgICAgICAgaG9zdCArPSBgOiR7cG9ydH1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtwYXRofWA7XG59O1xuZXhwb3J0cy5nZXRBYnNvbHV0ZVVybCA9IGdldEFic29sdXRlVXJsO1xuLyoqXG4gKiBQYXJzZSBzdGF0dXMgY29kZSBmcm9tIEhUVFAgcmVzcG9uc2UuIFtNb3JlIGRldGFpbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LXNwZWNpZmljYXRpb24vYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi9kYXRhLWh0dHAubWQjc3RhdHVzKVxuICovXG5jb25zdCBwYXJzZVJlc3BvbnNlU3RhdHVzID0gKGtpbmQsIHN0YXR1c0NvZGUpID0+IHtcbiAgICBjb25zdCB1cHBlckJvdW5kID0ga2luZCA9PT0gYXBpXzEuU3BhbktpbmQuQ0xJRU5UID8gNDAwIDogNTAwO1xuICAgIC8vIDF4eCwgMnh4LCAzeHggYXJlIE9LIG9uIGNsaWVudCBhbmQgc2VydmVyXG4gICAgLy8gNHh4IGlzIE9LIG9uIHNlcnZlclxuICAgIGlmIChzdGF0dXNDb2RlICYmIHN0YXR1c0NvZGUgPj0gMTAwICYmIHN0YXR1c0NvZGUgPCB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5VTlNFVDtcbiAgICB9XG4gICAgLy8gQWxsIG90aGVyIGNvZGVzIGFyZSBlcnJvclxuICAgIHJldHVybiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUjtcbn07XG5leHBvcnRzLnBhcnNlUmVzcG9uc2VTdGF0dXMgPSBwYXJzZVJlc3BvbnNlU3RhdHVzO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBvYmogbWF0Y2ggcGF0dGVyblxuICogQHBhcmFtIGNvbnN0YW50IGUuZyBVUkwgb2YgcmVxdWVzdFxuICogQHBhcmFtIHBhdHRlcm4gTWF0Y2ggcGF0dGVyblxuICovXG5jb25zdCBzYXRpc2ZpZXNQYXR0ZXJuID0gKGNvbnN0YW50LCBwYXR0ZXJuKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGF0dGVybiA9PT0gY29uc3RhbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChjb25zdGFudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuKGNvbnN0YW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdHRlcm4gaXMgaW4gdW5zdXBwb3J0ZWQgZGF0YXR5cGUnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zYXRpc2ZpZXNQYXR0ZXJuID0gc2F0aXNmaWVzUGF0dGVybjtcbi8qKlxuICogU2V0cyB0aGUgc3BhbiB3aXRoIHRoZSBlcnJvciBwYXNzZWQgaW4gcGFyYW1zXG4gKiBAcGFyYW0ge1NwYW59IHNwYW4gdGhlIHNwYW4gdGhhdCBuZWVkIHRvIGJlIHNldFxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgZXJyb3IgdGhhdCB3aWxsIGJlIHNldCB0byBzcGFuXG4gKiBAcGFyYW0ge1NlbWNvbnZTdGFiaWxpdHl9IHNlbWNvbnZTdGFiaWxpdHkgZGV0ZXJtaW5lcyB3aGljaCBzZW1jb252IHZlcnNpb24gdG8gdXNlXG4gKi9cbmNvbnN0IHNldFNwYW5XaXRoRXJyb3IgPSAoc3BhbiwgZXJyb3IsIHNlbWNvbnZTdGFiaWxpdHkpID0+IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoKHNlbWNvbnZTdGFiaWxpdHkgJiAyIC8qIE9MRCAqLykgPT09IDIgLyogT0xEICovKSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKEF0dHJpYnV0ZU5hbWVzXzEuQXR0cmlidXRlTmFtZXMuSFRUUF9FUlJPUl9OQU1FLCBlcnJvci5uYW1lKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoQXR0cmlidXRlTmFtZXNfMS5BdHRyaWJ1dGVOYW1lcy5IVFRQX0VSUk9SX01FU1NBR0UsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoKHNlbWNvbnZTdGFiaWxpdHkgJiAxIC8qIFNUQUJMRSAqLykgPT09XG4gICAgICAgIDEgLyogU1RBQkxFICovKSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFLCBlcnJvci5uYW1lKTtcbiAgICB9XG4gICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUiwgbWVzc2FnZSB9KTtcbiAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihlcnJvcik7XG59O1xuZXhwb3J0cy5zZXRTcGFuV2l0aEVycm9yID0gc2V0U3BhbldpdGhFcnJvcjtcbi8qKlxuICogQWRkcyBhdHRyaWJ1dGVzIGZvciByZXF1ZXN0IGNvbnRlbnQtbGVuZ3RoIGFuZCBjb250ZW50LWVuY29kaW5nIEhUVFAgaGVhZGVyc1xuICogQHBhcmFtIHsgSW5jb21pbmdNZXNzYWdlIH0gUmVxdWVzdCBvYmplY3Qgd2hvc2UgaGVhZGVycyB3aWxsIGJlIGFuYWx5emVkXG4gKiBAcGFyYW0geyBBdHRyaWJ1dGVzIH0gQXR0cmlidXRlcyBvYmplY3QgdG8gYmUgbW9kaWZpZWRcbiAqL1xuY29uc3Qgc2V0UmVxdWVzdENvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSAocmVxdWVzdCwgYXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldENvbnRlbnRMZW5ndGgocmVxdWVzdC5oZWFkZXJzKTtcbiAgICBpZiAobGVuZ3RoID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCgwLCBleHBvcnRzLmlzQ29tcHJlc3NlZCkocmVxdWVzdC5oZWFkZXJzKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIXSA9IGxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VEXSA9IGxlbmd0aDtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRSZXF1ZXN0Q29udGVudExlbmd0aEF0dHJpYnV0ZSA9IHNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlO1xuLyoqXG4gKiBBZGRzIGF0dHJpYnV0ZXMgZm9yIHJlc3BvbnNlIGNvbnRlbnQtbGVuZ3RoIGFuZCBjb250ZW50LWVuY29kaW5nIEhUVFAgaGVhZGVyc1xuICogQHBhcmFtIHsgSW5jb21pbmdNZXNzYWdlIH0gUmVzcG9uc2Ugb2JqZWN0IHdob3NlIGhlYWRlcnMgd2lsbCBiZSBhbmFseXplZFxuICogQHBhcmFtIHsgQXR0cmlidXRlcyB9IEF0dHJpYnV0ZXMgb2JqZWN0IHRvIGJlIG1vZGlmaWVkXG4gKlxuICogQGRlcHJlY2F0ZWQgdGhpcyBpcyBmb3IgYW4gb2xkZXIgdmVyc2lvbiBvZiBzZW1jb252LiBJdCBpcyByZXRhaW5lZCBmb3IgY29tcGF0aWJpbGl0eSB1c2luZyBPVEVMX1NFTUNPTlZfU1RBQklMSVRZX09QVF9JTlxuICovXG5jb25zdCBzZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSAocmVzcG9uc2UsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRDb250ZW50TGVuZ3RoKHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgIGlmIChsZW5ndGggPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNDb21wcmVzc2VkKShyZXNwb25zZS5oZWFkZXJzKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSF0gPSBsZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSF9VTkNPTVBSRVNTRURdID0gbGVuZ3RoO1xuICAgIH1cbn07XG5leHBvcnRzLnNldFJlc3BvbnNlQ29udGVudExlbmd0aEF0dHJpYnV0ZSA9IHNldFJlc3BvbnNlQ29udGVudExlbmd0aEF0dHJpYnV0ZTtcbmZ1bmN0aW9uIGdldENvbnRlbnRMZW5ndGgoaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZWFkZXIgPSBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgIGlmIChjb250ZW50TGVuZ3RoSGVhZGVyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBwYXJzZUludChjb250ZW50TGVuZ3RoSGVhZGVyLCAxMCk7XG4gICAgaWYgKGlzTmFOKGNvbnRlbnRMZW5ndGgpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY29udGVudExlbmd0aDtcbn1cbmNvbnN0IGlzQ29tcHJlc3NlZCA9IChoZWFkZXJzKSA9PiB7XG4gICAgY29uc3QgZW5jb2RpbmcgPSBoZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgcmV0dXJuICEhZW5jb2RpbmcgJiYgZW5jb2RpbmcgIT09ICdpZGVudGl0eSc7XG59O1xuZXhwb3J0cy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4vKipcbiAqIE1pbWljcyBOb2RlLmpzIGNvbnZlcnNpb24gb2YgVVJMIHN0cmluZ3MgdG8gUmVxdWVzdE9wdGlvbnMgZXhwZWN0ZWQgYnlcbiAqIGBodHRwLnJlcXVlc3RgIGFuZCBgaHR0cHMucmVxdWVzdGAgQVBJcy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvMjUwNWUyMTdiYmEwNWZjNTgxYjU3MmM2ODVjNWNmMjgwYTE2YzVhMy9saWIvaW50ZXJuYWwvdXJsLmpzI0wxNDE1LUwxNDM3XG4gKlxuICogQHBhcmFtIHN0cmluZ1VybFxuICogQHRocm93cyBUeXBlRXJyb3IgaWYgdGhlIFVSTCBpcyBub3QgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1VybFRvSHR0cE9wdGlvbnMoc3RyaW5nVXJsKSB7XG4gICAgLy8gVGhpcyBpcyBoZWF2aWx5IGluc3BpcmVkIGJ5IE5vZGUuanMgaGFuZGxpbmcgb2YgdGhlIHNhbWUgc2l0dWF0aW9uLCB0cnlpbmdcbiAgICAvLyB0byBmb2xsb3cgaXQgYXMgY2xvc2VseSBhcyBwb3NzaWJsZSB3aGlsZSBrZWVwaW5nIGluIG1pbmQgdGhhdCB3ZSBvbmx5XG4gICAgLy8gZGVhbCB3aXRoIHN0cmluZyBVUkxzLCBub3QgVVJMIG9iamVjdHMuXG4gICAgY29uc3QgeyBob3N0bmFtZSwgcGF0aG5hbWUsIHBvcnQsIHVzZXJuYW1lLCBwYXNzd29yZCwgc2VhcmNoLCBwcm90b2NvbCwgaGFzaCwgaHJlZiwgb3JpZ2luLCBob3N0LCB9ID0gbmV3IFVSTChzdHJpbmdVcmwpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICAgICAgaG9zdG5hbWU6IGhvc3RuYW1lICYmIGhvc3RuYW1lWzBdID09PSAnWycgPyBob3N0bmFtZS5zbGljZSgxLCAtMSkgOiBob3N0bmFtZSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgICAgcGF0aDogYCR7cGF0aG5hbWUgfHwgJyd9JHtzZWFyY2ggfHwgJyd9YCxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgfTtcbiAgICBpZiAocG9ydCAhPT0gJycpIHtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gTnVtYmVyKHBvcnQpO1xuICAgIH1cbiAgICBpZiAodXNlcm5hbWUgfHwgcGFzc3dvcmQpIHtcbiAgICAgICAgb3B0aW9ucy5hdXRoID0gYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpfWA7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuLyoqXG4gKiBNYWtlcyBzdXJlIG9wdGlvbnMgaXMgYW4gdXJsIG9iamVjdFxuICogcmV0dXJuIGFuIG9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWUgYW5kIHBhcnNlZCBvcHRpb25zXG4gKiBAcGFyYW0gbG9nZ2VyIGNvbXBvbmVudCBsb2dnZXJcbiAqIEBwYXJhbSBvcHRpb25zIG9yaWdpbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0gW2V4dHJhT3B0aW9uc10gYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdFxuICovXG5jb25zdCBnZXRSZXF1ZXN0SW5mbyA9IChsb2dnZXIsIG9wdGlvbnMsIGV4dHJhT3B0aW9ucykgPT4ge1xuICAgIGxldCBwYXRobmFtZTtcbiAgICBsZXQgb3JpZ2luO1xuICAgIGxldCBvcHRpb25zUGFyc2VkO1xuICAgIGxldCBpbnZhbGlkVXJsID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udmVydGVkT3B0aW9ucyA9IHN0cmluZ1VybFRvSHR0cE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBvcHRpb25zUGFyc2VkID0gY29udmVydGVkT3B0aW9ucztcbiAgICAgICAgICAgIHBhdGhuYW1lID0gY29udmVydGVkT3B0aW9ucy5wYXRobmFtZSB8fCAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGludmFsaWRVcmwgPSB0cnVlO1xuICAgICAgICAgICAgbG9nZ2VyLnZlcmJvc2UoJ1VuYWJsZSB0byBwYXJzZSBVUkwgcHJvdmlkZWQgdG8gSFRUUCByZXF1ZXN0LCB1c2luZyBmYWxsYmFjayB0byBkZXRlcm1pbmUgcGF0aC4gT3JpZ2luYWwgZXJyb3I6JywgZSk7XG4gICAgICAgICAgICAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGhvdyB1cmwucGFyc2UoKSBiZWhhdmVkLlxuICAgICAgICAgICAgb3B0aW9uc1BhcnNlZCA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiBvcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gb3B0aW9uc1BhcnNlZC5wYXRoIHx8ICcvJztcbiAgICAgICAgfVxuICAgICAgICBvcmlnaW4gPSBgJHtvcHRpb25zUGFyc2VkLnByb3RvY29sIHx8ICdodHRwOid9Ly8ke29wdGlvbnNQYXJzZWQuaG9zdH1gO1xuICAgICAgICBpZiAoZXh0cmFPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc1BhcnNlZCwgZXh0cmFPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zIGluc3RhbmNlb2YgdXJsLlVSTCkge1xuICAgICAgICBvcHRpb25zUGFyc2VkID0ge1xuICAgICAgICAgICAgcHJvdG9jb2w6IG9wdGlvbnMucHJvdG9jb2wsXG4gICAgICAgICAgICBob3N0bmFtZTogdHlwZW9mIG9wdGlvbnMuaG9zdG5hbWUgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBhdGg6IGAke29wdGlvbnMucGF0aG5hbWUgfHwgJyd9JHtvcHRpb25zLnNlYXJjaCB8fCAnJ31gLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5wb3J0ICE9PSAnJykge1xuICAgICAgICAgICAgb3B0aW9uc1BhcnNlZC5wb3J0ID0gTnVtYmVyKG9wdGlvbnMucG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlcm5hbWUgfHwgb3B0aW9ucy5wYXNzd29yZCkge1xuICAgICAgICAgICAgb3B0aW9uc1BhcnNlZC5hdXRoID0gYCR7b3B0aW9ucy51c2VybmFtZX06JHtvcHRpb25zLnBhc3N3b3JkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aG5hbWUgPSBvcHRpb25zLnBhdGhuYW1lO1xuICAgICAgICBvcmlnaW4gPSBvcHRpb25zLm9yaWdpbjtcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnNQYXJzZWQsIGV4dHJhT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnNQYXJzZWQgPSBPYmplY3QuYXNzaWduKHsgcHJvdG9jb2w6IG9wdGlvbnMuaG9zdCA/ICdodHRwOicgOiB1bmRlZmluZWQgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gb3B0aW9uc1BhcnNlZC5ob3N0IHx8XG4gICAgICAgICAgICAob3B0aW9uc1BhcnNlZC5wb3J0ICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IGAke29wdGlvbnNQYXJzZWQuaG9zdG5hbWV9JHtvcHRpb25zUGFyc2VkLnBvcnR9YFxuICAgICAgICAgICAgICAgIDogb3B0aW9uc1BhcnNlZC5ob3N0bmFtZSk7XG4gICAgICAgIG9yaWdpbiA9IGAke29wdGlvbnNQYXJzZWQucHJvdG9jb2wgfHwgJ2h0dHA6J30vLyR7aG9zdG5hbWV9YDtcbiAgICAgICAgcGF0aG5hbWUgPSBvcHRpb25zLnBhdGhuYW1lO1xuICAgICAgICBpZiAoIXBhdGhuYW1lICYmIG9wdGlvbnNQYXJzZWQucGF0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKG9wdGlvbnNQYXJzZWQucGF0aCwgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZFVybC5wYXRobmFtZSB8fCAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNvbWUgcGFja2FnZXMgcmV0dXJuIG1ldGhvZCBpbiBsb3dlcmNhc2UuLlxuICAgIC8vIGVuc3VyZSB1cHBlckNhc2UgZm9yIGNvbnNpc3RlbmN5XG4gICAgY29uc3QgbWV0aG9kID0gb3B0aW9uc1BhcnNlZC5tZXRob2RcbiAgICAgICAgPyBvcHRpb25zUGFyc2VkLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIDogJ0dFVCc7XG4gICAgcmV0dXJuIHsgb3JpZ2luLCBwYXRobmFtZSwgbWV0aG9kLCBvcHRpb25zUGFyc2VkLCBpbnZhbGlkVXJsIH07XG59O1xuZXhwb3J0cy5nZXRSZXF1ZXN0SW5mbyA9IGdldFJlcXVlc3RJbmZvO1xuLyoqXG4gKiBNYWtlcyBzdXJlIG9wdGlvbnMgaXMgb2YgdHlwZSBzdHJpbmcgb3Igb2JqZWN0XG4gKiBAcGFyYW0gb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3RcbiAqL1xuY29uc3QgaXNWYWxpZE9wdGlvbnNUeXBlID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9wdGlvbnM7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8ICh0eXBlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkT3B0aW9uc1R5cGUgPSBpc1ZhbGlkT3B0aW9uc1R5cGU7XG5jb25zdCBleHRyYWN0SG9zdG5hbWVBbmRQb3J0ID0gKHJlcXVlc3RPcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5ob3N0bmFtZSAmJiByZXF1ZXN0T3B0aW9ucy5wb3J0KSB7XG4gICAgICAgIHJldHVybiB7IGhvc3RuYW1lOiByZXF1ZXN0T3B0aW9ucy5ob3N0bmFtZSwgcG9ydDogcmVxdWVzdE9wdGlvbnMucG9ydCB9O1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0gKChfYSA9IHJlcXVlc3RPcHRpb25zLmhvc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXRjaCgvXihbXjovIF0rKSg6XFxkezEsNX0pPy8pKSB8fCBudWxsO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gcmVxdWVzdE9wdGlvbnMuaG9zdG5hbWUgfHwgKG1hdGNoZXMgPT09IG51bGwgPyAnbG9jYWxob3N0JyA6IG1hdGNoZXNbMV0pO1xuICAgIGxldCBwb3J0ID0gcmVxdWVzdE9wdGlvbnMucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsZWFkaW5nIFwiOlwiLiBUaGUgZXh0cmFjdGVkIHBvcnQgd291bGQgYmUgc29tZXRoaW5nIGxpa2UgXCI6ODA4MFwiXG4gICAgICAgICAgICBwb3J0ID0gbWF0Y2hlc1syXS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3J0ID0gcmVxdWVzdE9wdGlvbnMucHJvdG9jb2wgPT09ICdodHRwczonID8gJzQ0MycgOiAnODAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGhvc3RuYW1lLCBwb3J0IH07XG59O1xuZXhwb3J0cy5leHRyYWN0SG9zdG5hbWVBbmRQb3J0ID0gZXh0cmFjdEhvc3RuYW1lQW5kUG9ydDtcbi8qKlxuICogUmV0dXJucyBvdXRnb2luZyByZXF1ZXN0IGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgcmVxdWVzdFxuICogQHBhcmFtIHtQYXJzZWRSZXF1ZXN0T3B0aW9uc30gcmVxdWVzdE9wdGlvbnMgdGhlIHNhbWUgb3B0aW9ucyB1c2VkIHRvIG1ha2UgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB7eyBjb21wb25lbnQ6IHN0cmluZywgaG9zdG5hbWU6IHN0cmluZywgaG9va0F0dHJpYnV0ZXM/OiBBdHRyaWJ1dGVzIH19IG9wdGlvbnMgdXNlZCB0byBwYXNzIGRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge1NlbWNvbnZTdGFiaWxpdHl9IHNlbWNvbnZTdGFiaWxpdHkgZGV0ZXJtaW5lcyB3aGljaCBzZW1jb252IHZlcnNpb24gdG8gdXNlXG4gKi9cbmNvbnN0IGdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSAocmVxdWVzdE9wdGlvbnMsIG9wdGlvbnMsIHNlbWNvbnZTdGFiaWxpdHkpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gb3B0aW9ucy5ob3N0bmFtZTtcbiAgICBjb25zdCBwb3J0ID0gb3B0aW9ucy5wb3J0O1xuICAgIGNvbnN0IG1ldGhvZCA9IChfYSA9IHJlcXVlc3RPcHRpb25zLm1ldGhvZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0dFVCc7XG4gICAgY29uc3Qgbm9ybWFsaXplZE1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IGhlYWRlcnNbJ3VzZXItYWdlbnQnXTtcbiAgICBjb25zdCB1cmxGdWxsID0gKDAsIGV4cG9ydHMuZ2V0QWJzb2x1dGVVcmwpKHJlcXVlc3RPcHRpb25zLCBoZWFkZXJzLCBgJHtvcHRpb25zLmNvbXBvbmVudH06YCk7XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHtcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9VUkxdOiB1cmxGdWxsLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX01FVEhPRF06IG1ldGhvZCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9UQVJHRVRdOiByZXF1ZXN0T3B0aW9ucy5wYXRoIHx8ICcvJyxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfTkFNRV06IGhvc3RuYW1lLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0hPU1RdOiAoX2IgPSBoZWFkZXJzLmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGAke2hvc3RuYW1lfToke3BvcnR9YCxcbiAgICB9O1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIC8vIFJlcXVpcmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTogbm9ybWFsaXplZE1ldGhvZCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IGhvc3RuYW1lLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXTogTnVtYmVyKHBvcnQpLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9GVUxMXTogdXJsRnVsbCxcbiAgICAgICAgLy8gbGVhdmluZyBvdXQgcHJvdG9jb2wgdmVyc2lvbiwgaXQgaXMgbm90IHlldCBuZWdvdGlhdGVkXG4gICAgICAgIC8vIGxlYXZpbmcgb3V0IHByb3RvY29sIG5hbWUsIGl0IGlzIG9ubHkgcmVxdWlyZWQgd2hlbiBwcm90b2NvbCB2ZXJzaW9uIGlzIHNldFxuICAgICAgICAvLyByZXRyaWVzIGFuZCByZWRpcmVjdHMgbm90IHN1cHBvcnRlZFxuICAgICAgICAvLyBPcHQtaW4gYXR0cmlidXRlcyBsZWZ0IG9mZiBmb3Igbm93XG4gICAgfTtcbiAgICAvLyBjb25kaXRpb25hbGx5IHJlcXVpcmVkIGlmIHJlcXVlc3QgbWV0aG9kIHJlcXVpcmVkIGNhc2Ugbm9ybWFsaXphdGlvblxuICAgIGlmIChtZXRob2QgIT09IG5vcm1hbGl6ZWRNZXRob2QpIHtcbiAgICAgICAgbmV3QXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF9PUklHSU5BTF0gPSBtZXRob2Q7XG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9VU0VSX0FHRU5UXSA9IHVzZXJBZ2VudDtcbiAgICB9XG4gICAgc3dpdGNoIChzZW1jb252U3RhYmlsaXR5KSB7XG4gICAgICAgIGNhc2UgMSAvKiBTVEFCTEUgKi86XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCBvcHRpb25zLmhvb2tBdHRyaWJ1dGVzKTtcbiAgICAgICAgY2FzZSAyIC8qIE9MRCAqLzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvbGRBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzLCBvcHRpb25zLmhvb2tBdHRyaWJ1dGVzKTtcbn07XG5leHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzO1xuLyoqXG4gKiBSZXR1cm5zIG91dGdvaW5nIHJlcXVlc3QgTWV0cmljIGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7QXR0cmlidXRlc30gc3BhbkF0dHJpYnV0ZXMgdGhlIHNwYW4gYXR0cmlidXRlc1xuICovXG5jb25zdCBnZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzID0gKHNwYW5BdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX01FVEhPRF0gPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfTkFNRV0gPVxuICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX05BTUVdO1xuICAgIC8vVE9ETzogaHR0cC51cmwgYXR0cmlidXRlLCBpdCBzaG91bGQgc3Vic3RpdHV0ZSBhbnkgcGFyYW1ldGVycyB0byBhdm9pZCBoaWdoIGNhcmRpbmFsaXR5LlxuICAgIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXM7XG4vKipcbiAqIFJldHVybnMgYXR0cmlidXRlcyByZWxhdGVkIHRvIHRoZSBraW5kIG9mIEhUVFAgcHJvdG9jb2wgdXNlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtraW5kXSBLaW5kIG9mIEhUVFAgcHJvdG9jb2wgdXNlZDogXCIxLjBcIiwgXCIxLjFcIiwgXCIyXCIsIFwiU1BEWVwiIG9yIFwiUVVJQ1wiLlxuICovXG5jb25zdCBzZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kID0gKGtpbmQsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICBpZiAoa2luZCkge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9GTEFWT1JdID0ga2luZDtcbiAgICAgICAgaWYgKGtpbmQudG9VcHBlckNhc2UoKSAhPT0gJ1FVSUMnKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1RSQU5TUE9SVF0gPSBzZW1hbnRpY19jb252ZW50aW9uc18xLk5FVFRSQU5TUE9SVFZBTFVFU19JUF9UQ1A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1RSQU5TUE9SVF0gPSBzZW1hbnRpY19jb252ZW50aW9uc18xLk5FVFRSQU5TUE9SVFZBTFVFU19JUF9VRFA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5zZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kID0gc2V0QXR0cmlidXRlc0Zyb21IdHRwS2luZDtcbi8qKlxuICogUmV0dXJucyBvdXRnb2luZyByZXF1ZXN0IGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXNwb25zZSBkYXRhXG4gKiBAcGFyYW0ge0luY29taW5nTWVzc2FnZX0gcmVzcG9uc2UgdGhlIHJlc3BvbnNlIG9iamVjdFxuICogQHBhcmFtIHtTZW1jb252U3RhYmlsaXR5fSBzZW1jb252U3RhYmlsaXR5IGRldGVybWluZXMgd2hpY2ggc2VtY29udiB2ZXJzaW9uIHRvIHVzZVxuICovXG5jb25zdCBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChyZXNwb25zZSwgc2VtY29udlN0YWJpbGl0eSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaHR0cFZlcnNpb24sIHNvY2tldCB9ID0gcmVzcG9uc2U7XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IHN0YWJsZUF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAoc3RhdHVzQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHN0YWJsZUF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdID0gc3RhdHVzQ29kZTtcbiAgICB9XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgICBjb25zdCB7IHJlbW90ZUFkZHJlc3MsIHJlbW90ZVBvcnQgfSA9IHNvY2tldDtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX0lQXSA9IHJlbW90ZUFkZHJlc3M7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9QT1JUXSA9IHJlbW90ZVBvcnQ7XG4gICAgICAgIC8vIFJlY29tbWVuZGVkXG4gICAgICAgIHN0YWJsZUF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9BRERSRVNTXSA9IHJlbW90ZUFkZHJlc3M7XG4gICAgICAgIHN0YWJsZUF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9QT1JUXSA9IHJlbW90ZVBvcnQ7XG4gICAgICAgIHN0YWJsZUF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl0gPSByZXNwb25zZS5odHRwVmVyc2lvbjtcbiAgICB9XG4gICAgKDAsIGV4cG9ydHMuc2V0UmVzcG9uc2VDb250ZW50TGVuZ3RoQXR0cmlidXRlKShyZXNwb25zZSwgb2xkQXR0cmlidXRlcyk7XG4gICAgaWYgKHN0YXR1c0NvZGUpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdID0gc3RhdHVzQ29kZTtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tBdHRyaWJ1dGVOYW1lc18xLkF0dHJpYnV0ZU5hbWVzLkhUVFBfU1RBVFVTX1RFWFRdID0gKHN0YXR1c01lc3NhZ2UgfHwgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgICgwLCBleHBvcnRzLnNldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQpKGh0dHBWZXJzaW9uLCBvbGRBdHRyaWJ1dGVzKTtcbiAgICBzd2l0Y2ggKHNlbWNvbnZTdGFiaWxpdHkpIHtcbiAgICAgICAgY2FzZSAxIC8qIFNUQUJMRSAqLzpcbiAgICAgICAgICAgIHJldHVybiBzdGFibGVBdHRyaWJ1dGVzO1xuICAgICAgICBjYXNlIDIgLyogT0xEICovOlxuICAgICAgICAgICAgcmV0dXJuIG9sZEF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIHN0YWJsZUF0dHJpYnV0ZXMpO1xufTtcbmV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZTtcbi8qKlxuICogUmV0dXJucyBvdXRnb2luZyByZXF1ZXN0IE1ldHJpYyBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVzcG9uc2UgZGF0YVxuICogQHBhcmFtIHtBdHRyaWJ1dGVzfSBzcGFuQXR0cmlidXRlcyB0aGUgc3BhbiBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gKHNwYW5BdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9QT1JUXSA9XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVF07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdID1cbiAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9GTEFWT1JdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0ZMQVZPUl07XG4gICAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlO1xuZnVuY3Rpb24gcGFyc2VIb3N0SGVhZGVyKGhvc3RIZWFkZXIsIHByb3RvKSB7XG4gICAgY29uc3QgcGFydHMgPSBob3N0SGVhZGVyLnNwbGl0KCc6Jyk7XG4gICAgLy8gbm8gc2VtaWNvbG9uIGltcGxpZXMgaXB2NCBkb3R0ZWQgc3ludGF4IG9yIGhvc3QgbmFtZSB3aXRob3V0IHBvcnRcbiAgICAvLyB4LngueC54XG4gICAgLy8gZXhhbXBsZS5jb21cbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChwcm90byA9PT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBob3N0OiBwYXJ0c1swXSwgcG9ydDogJzgwJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm90byA9PT0gJ2h0dHBzJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogcGFydHNbMF0sIHBvcnQ6ICc0NDMnIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaG9zdDogcGFydHNbMF0gfTtcbiAgICB9XG4gICAgLy8gc2luZ2xlIHNlbWljb2xvbiBpbXBsaWVzIGlwdjQgZG90dGVkIHN5bnRheCBvciBob3N0IG5hbWUgd2l0aCBwb3J0XG4gICAgLy8geC54LngueDp5eXl5XG4gICAgLy8gZXhhbXBsZS5jb206eXl5eVxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvc3Q6IHBhcnRzWzBdLFxuICAgICAgICAgICAgcG9ydDogcGFydHNbMV0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIG1vcmUgdGhhbiAyIHBhcnRzIGltcGxpZXMgaXB2NiBzeW50YXggd2l0aCBtdWx0aXBsZSBjb2xvbnNcbiAgICAvLyBbeDp4Ong6eDp4Ong6eDp4XVxuICAgIC8vIFt4Ong6eDp4Ong6eDp4OnhdOnl5eXlcbiAgICBpZiAocGFydHNbMF0uc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICBpZiAocHJvdG8gPT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IGhvc3RIZWFkZXIsIHBvcnQ6ICc4MCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm90byA9PT0gJ2h0dHBzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IGhvc3RIZWFkZXIsIHBvcnQ6ICc0NDMnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMl0uZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0OiBwYXJ0cy5zbGljZSgwLCAtMSkuam9pbignOicpLFxuICAgICAgICAgICAgICAgIHBvcnQ6IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBub3RoaW5nIGFib3ZlIG1hdGNoZXMganVzdCByZXR1cm4gdGhlIGhvc3QgaGVhZGVyXG4gICAgcmV0dXJuIHsgaG9zdDogaG9zdEhlYWRlciB9O1xufVxuLyoqXG4gKiBHZXQgc2VydmVyLmFkZHJlc3MgYW5kIHBvcnQgYWNjb3JkaW5nIHRvIGh0dHAgc2VtY29udiAxLjI3XG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYmxvYi9iZjBhMmMxMTM0ZjIwNmYwMzQ0MDhiMjAxZGJlYzM3OTYwZWQ2MGVjL2RvY3MvaHR0cC9odHRwLXNwYW5zLm1kI3NldHRpbmctc2VydmVyYWRkcmVzcy1hbmQtc2VydmVycG9ydC1hdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFNlcnZlckFkZHJlc3MocmVxdWVzdCwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgZm9yd2FyZGVkSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzWydmb3J3YXJkZWQnXTtcbiAgICBpZiAoZm9yd2FyZGVkSGVhZGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcGFyc2VGb3J3YXJkZWRIZWFkZXIoZm9yd2FyZGVkSGVhZGVyKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5Lmhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKGVudHJ5Lmhvc3QsIGVudHJ5LnByb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4Rm9yd2FyZGVkSG9zdCA9IHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtaG9zdCddO1xuICAgIGlmICh0eXBlb2YgeEZvcndhcmRlZEhvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcih4Rm9yd2FyZGVkSG9zdCwgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKHhGb3J3YXJkZWRIb3N0LCByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ11bMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoeEZvcndhcmRlZEhvc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHhGb3J3YXJkZWRIb3N0KSAmJlxuICAgICAgICB0eXBlb2YgeEZvcndhcmRlZEhvc3RbMF0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHhGb3J3YXJkZWRIb3N0WzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKHhGb3J3YXJkZWRIb3N0WzBdLCByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoeEZvcndhcmRlZEhvc3RbMF0sIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcih4Rm9yd2FyZGVkSG9zdFswXSk7XG4gICAgfVxuICAgIGNvbnN0IGhvc3QgPSByZXF1ZXN0LmhlYWRlcnNbJ2hvc3QnXTtcbiAgICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnICYmIGhvc3QubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKGhvc3QsIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHZXQgc2VydmVyLmFkZHJlc3MgYW5kIHBvcnQgYWNjb3JkaW5nIHRvIGh0dHAgc2VtY29udiAxLjI3XG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYmxvYi9iZjBhMmMxMTM0ZjIwNmYwMzQ0MDhiMjAxZGJlYzM3OTYwZWQ2MGVjL2RvY3MvaHR0cC9odHRwLXNwYW5zLm1kI3NldHRpbmctc2VydmVyYWRkcmVzcy1hbmQtc2VydmVycG9ydC1hdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFJlbW90ZUNsaWVudEFkZHJlc3MocmVxdWVzdCkge1xuICAgIGNvbnN0IGZvcndhcmRlZEhlYWRlciA9IHJlcXVlc3QuaGVhZGVyc1snZm9yd2FyZGVkJ107XG4gICAgaWYgKGZvcndhcmRlZEhlYWRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHBhcnNlRm9yd2FyZGVkSGVhZGVyKGZvcndhcmRlZEhlYWRlcikpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5mb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuZm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHhGb3J3YXJkZWRGb3IgPSByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddO1xuICAgIGlmICh0eXBlb2YgeEZvcndhcmRlZEZvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHhGb3J3YXJkZWRGb3I7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeEZvcndhcmRlZEZvcikpIHtcbiAgICAgICAgcmV0dXJuIHhGb3J3YXJkZWRGb3JbMF07XG4gICAgfVxuICAgIGNvbnN0IHJlbW90ZSA9IHJlcXVlc3Quc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgaWYgKHJlbW90ZSkge1xuICAgICAgICByZXR1cm4gcmVtb3RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZ2V0UmVtb3RlQ2xpZW50QWRkcmVzcyA9IGdldFJlbW90ZUNsaWVudEFkZHJlc3M7XG5mdW5jdGlvbiBnZXRJbmZvRnJvbUluY29taW5nTWVzc2FnZShjb21wb25lbnQsIHJlcXVlc3QsIGxvZ2dlcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaGVhZGVycy5ob3N0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTCgoX2EgPSByZXF1ZXN0LnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJy8nLCBgJHtjb21wb25lbnR9Oi8vJHtyZXF1ZXN0LmhlYWRlcnMuaG9zdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2FmZVBhcnNlZFVybCA9IG5ldyBVUkwoKF9iID0gcmVxdWVzdC51cmwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcvJywgXG4gICAgICAgICAgICAvLyB1c2luZyBsb2NhbGhvc3QgYXMgYSB3b3JrYXJvdW5kIHRvIHN0aWxsIHVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIGZvciBwYXJzaW5nXG4gICAgICAgICAgICBgJHtjb21wb25lbnR9Oi8vbG9jYWxob3N0YCk7XG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSB1c2UgbG9jYWxob3N0IGFzIGEgd29ya2Fyb3VuZCwgZW5zdXJlIHdlIGhpZGUgdGhlIHJlc3Qgb2YgdGhlIHByb3BlcnRpZXMgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIG91ciB3b3JrYXJvdW5kIGxlYWtpbmcgdGhvdWdoLlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogdW5zYWZlUGFyc2VkVXJsLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogdW5zYWZlUGFyc2VkVXJsLnNlYXJjaCxcbiAgICAgICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgdXNlIHRoZSByZXN1bHQgb2YgdW5zYWZlUGFyc2VkVXJsLnRvU3RyaW5nIGFzIGl0J3MgcG90ZW50aWFsbHkgd3JvbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bnNhZmVQYXJzZWRVcmwucGF0aG5hbWUgKyB1bnNhZmVQYXJzZWRVcmwuc2VhcmNoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyBpcyB3cm9uZywgdXNlIHVuZGVmaW5lZCAtIHRoaXMgKnNob3VsZCogbmV2ZXIgaGFwcGVuLCBsb2dnaW5nXG4gICAgICAgIC8vIGZvciB0cm91Ymxlc2hvb3RpbmcgaW4gY2FzZSBpdCBkb2VzIGhhcHBlbi5cbiAgICAgICAgbG9nZ2VyLnZlcmJvc2UoJ1VuYWJsZSB0byBnZXQgVVJMIGZyb20gcmVxdWVzdCcsIGUpO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGluY29taW5nIHJlcXVlc3QgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtJbmNvbWluZ01lc3NhZ2V9IHJlcXVlc3QgdGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge3sgY29tcG9uZW50OiBzdHJpbmcsIHNlcnZlck5hbWU/OiBzdHJpbmcsIGhvb2tBdHRyaWJ1dGVzPzogQXR0cmlidXRlcyB9fSBvcHRpb25zIHVzZWQgdG8gcGFzcyBkYXRhIG5lZWRlZCB0byBjcmVhdGUgYXR0cmlidXRlc1xuICogQHBhcmFtIHtTZW1jb252U3RhYmlsaXR5fSBzZW1jb252U3RhYmlsaXR5IGRldGVybWluZXMgd2hpY2ggc2VtY29udiB2ZXJzaW9uIHRvIHVzZVxuICovXG5jb25zdCBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzID0gKHJlcXVlc3QsIG9wdGlvbnMsIGxvZ2dlcikgPT4ge1xuICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnM7XG4gICAgY29uc3QgdXNlckFnZW50ID0gaGVhZGVyc1sndXNlci1hZ2VudCddO1xuICAgIGNvbnN0IGlwcyA9IGhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddO1xuICAgIGNvbnN0IGh0dHBWZXJzaW9uID0gcmVxdWVzdC5odHRwVmVyc2lvbjtcbiAgICBjb25zdCBob3N0ID0gaGVhZGVycy5ob3N0O1xuICAgIGNvbnN0IGhvc3RuYW1lID0gKGhvc3QgPT09IG51bGwgfHwgaG9zdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdC5yZXBsYWNlKC9eKC4qKSg6WzAtOV17MSw1fSkvLCAnJDEnKSkgfHwgJ2xvY2FsaG9zdCc7XG4gICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgY29uc3Qgbm9ybWFsaXplZE1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpO1xuICAgIGNvbnN0IHNlcnZlckFkZHJlc3MgPSBnZXRTZXJ2ZXJBZGRyZXNzKHJlcXVlc3QsIG9wdGlvbnMuY29tcG9uZW50KTtcbiAgICBjb25zdCBzZXJ2ZXJOYW1lID0gb3B0aW9ucy5zZXJ2ZXJOYW1lO1xuICAgIGNvbnN0IHJlbW90ZUNsaWVudEFkZHJlc3MgPSBnZXRSZW1vdGVDbGllbnRBZGRyZXNzKHJlcXVlc3QpO1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF06IG5vcm1hbGl6ZWRNZXRob2QsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRV06IG9wdGlvbnMuY29tcG9uZW50LFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9BRERSRVNTXTogc2VydmVyQWRkcmVzcyA9PT0gbnVsbCB8fCBzZXJ2ZXJBZGRyZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2ZXJBZGRyZXNzLmhvc3QsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QRUVSX0FERFJFU1NdOiByZXF1ZXN0LnNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9QT1JUXTogcmVxdWVzdC5zb2NrZXQucmVtb3RlUG9ydCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dOiByZXF1ZXN0Lmh0dHBWZXJzaW9uLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VTRVJfQUdFTlRfT1JJR0lOQUxdOiB1c2VyQWdlbnQsXG4gICAgfTtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBnZXRJbmZvRnJvbUluY29taW5nTWVzc2FnZShvcHRpb25zLmNvbXBvbmVudCwgcmVxdWVzdCwgbG9nZ2VyKTtcbiAgICBpZiAoKHBhcnNlZFVybCA9PT0gbnVsbCB8fCBwYXJzZWRVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlZFVybC5wYXRobmFtZSkgIT0gbnVsbCkge1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfUEFUSF0gPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gICAgfVxuICAgIGlmIChyZW1vdGVDbGllbnRBZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgbmV3QXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfQ0xJRU5UX0FERFJFU1NdID0gcmVtb3RlQ2xpZW50QWRkcmVzcztcbiAgICB9XG4gICAgaWYgKChzZXJ2ZXJBZGRyZXNzID09PSBudWxsIHx8IHNlcnZlckFkZHJlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZlckFkZHJlc3MucG9ydCkgIT0gbnVsbCkge1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfUE9SVF0gPSBOdW1iZXIoc2VydmVyQWRkcmVzcy5wb3J0KTtcbiAgICB9XG4gICAgLy8gY29uZGl0aW9uYWxseSByZXF1aXJlZCBpZiByZXF1ZXN0IG1ldGhvZCByZXF1aXJlZCBjYXNlIG5vcm1hbGl6YXRpb25cbiAgICBpZiAobWV0aG9kICE9PSBub3JtYWxpemVkTWV0aG9kKSB7XG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RfT1JJR0lOQUxdID0gbWV0aG9kO1xuICAgIH1cbiAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0ge1xuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1VSTF06IHBhcnNlZFVybC50b1N0cmluZygpLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0hPU1RdOiBob3N0LFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9OQU1FXTogaG9zdG5hbWUsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTogbWV0aG9kLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NDSEVNRV06IG9wdGlvbnMuY29tcG9uZW50LFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBpcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0NMSUVOVF9JUF0gPSBpcHMuc3BsaXQoJywnKVswXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXJ2ZXJOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TRVJWRVJfTkFNRV0gPSBzZXJ2ZXJOYW1lO1xuICAgIH1cbiAgICBpZiAocGFyc2VkVXJsID09PSBudWxsIHx8IHBhcnNlZFVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyc2VkVXJsLnBhdGhuYW1lKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1RBUkdFVF0gPVxuICAgICAgICAgICAgKHBhcnNlZFVybCA9PT0gbnVsbCB8fCBwYXJzZWRVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlZFVybC5wYXRobmFtZSkgKyAocGFyc2VkVXJsID09PSBudWxsIHx8IHBhcnNlZFVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyc2VkVXJsLnNlYXJjaCkgfHwgJy8nO1xuICAgIH1cbiAgICBpZiAodXNlckFnZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfVVNFUl9BR0VOVF0gPSB1c2VyQWdlbnQ7XG4gICAgfVxuICAgICgwLCBleHBvcnRzLnNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlKShyZXF1ZXN0LCBvbGRBdHRyaWJ1dGVzKTtcbiAgICAoMCwgZXhwb3J0cy5zZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kKShodHRwVmVyc2lvbiwgb2xkQXR0cmlidXRlcyk7XG4gICAgc3dpdGNoIChvcHRpb25zLnNlbWNvbnZTdGFiaWxpdHkpIHtcbiAgICAgICAgY2FzZSAxIC8qIFNUQUJMRSAqLzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xuICAgICAgICBjYXNlIDIgLyogT0xEICovOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2xkQXR0cmlidXRlcywgb3B0aW9ucy5ob29rQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xufTtcbmV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlcyA9IGdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXM7XG4vKipcbiAqIFJldHVybnMgaW5jb21pbmcgcmVxdWVzdCBNZXRyaWMgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtBdHRyaWJ1dGVzfSBzcGFuQXR0cmlidXRlcyB0aGUgc3BhbiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge3sgY29tcG9uZW50OiBzdHJpbmcgfX0gb3B0aW9ucyB1c2VkIHRvIHBhc3MgZGF0YSBuZWVkZWQgdG8gY3JlYXRlIGF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IChzcGFuQXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IG1ldHJpY0F0dHJpYnV0ZXMgPSB7fTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TQ0hFTUVdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NDSEVNRV07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9NRVRIT0RdO1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9OQU1FXSA9XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfTkFNRV07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfRkxBVk9SXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9GTEFWT1JdO1xuICAgIC8vVE9ETzogaHR0cC50YXJnZXQgYXR0cmlidXRlLCBpdCBzaG91bGQgc3Vic3RpdHV0ZSBhbnkgcGFyYW1ldGVycyB0byBhdm9pZCBoaWdoIGNhcmRpbmFsaXR5LlxuICAgIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IGdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXM7XG4vKipcbiAqIFJldHVybnMgaW5jb21pbmcgcmVxdWVzdCBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVzcG9uc2UgZGF0YVxuICogQHBhcmFtIHsoU2VydmVyUmVzcG9uc2UgJiB7IHNvY2tldDogU29ja2V0OyB9KX0gcmVzcG9uc2UgdGhlIHJlc3BvbnNlIG9iamVjdFxuICovXG5jb25zdCBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChyZXF1ZXN0LCByZXNwb25zZSwgc2VtY29udlN0YWJpbGl0eSkgPT4ge1xuICAgIC8vIHRha2Ugc29ja2V0IGZyb20gdGhlIHJlcXVlc3QsXG4gICAgLy8gc2luY2UgaXQgbWF5IGJlIGRldGFjaGVkIGZyb20gdGhlIHJlc3BvbnNlIG9iamVjdCBpbiBrZWVwLWFsaXZlIG1vZGVcbiAgICBjb25zdCB7IHNvY2tldCB9ID0gcmVxdWVzdDtcbiAgICBjb25zdCB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UgfSA9IHJlc3BvbnNlO1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV06IHN0YXR1c0NvZGUsXG4gICAgfTtcbiAgICBjb25zdCBycGNNZXRhZGF0YSA9ICgwLCBjb3JlXzEuZ2V0UlBDTWV0YWRhdGEpKGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgIGNvbnN0IHsgbG9jYWxBZGRyZXNzLCBsb2NhbFBvcnQsIHJlbW90ZUFkZHJlc3MsIHJlbW90ZVBvcnQgfSA9IHNvY2tldDtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX0lQXSA9IGxvY2FsQWRkcmVzcztcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX1BPUlRdID0gbG9jYWxQb3J0O1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfSVBdID0gcmVtb3RlQWRkcmVzcztcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX1BPUlRdID0gcmVtb3RlUG9ydDtcbiAgICB9XG4gICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdID0gc3RhdHVzQ29kZTtcbiAgICBvbGRBdHRyaWJ1dGVzW0F0dHJpYnV0ZU5hbWVzXzEuQXR0cmlidXRlTmFtZXMuSFRUUF9TVEFUVVNfVEVYVF0gPSAoc3RhdHVzTWVzc2FnZSB8fCAnJykudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoKHJwY01ldGFkYXRhID09PSBudWxsIHx8IHJwY01ldGFkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBycGNNZXRhZGF0YS50eXBlKSA9PT0gY29yZV8xLlJQQ1R5cGUuSFRUUCAmJiBycGNNZXRhZGF0YS5yb3V0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXSA9IHJwY01ldGFkYXRhLnJvdXRlO1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JPVVRFXSA9IHJwY01ldGFkYXRhLnJvdXRlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNlbWNvbnZTdGFiaWxpdHkpIHtcbiAgICAgICAgY2FzZSAxIC8qIFNUQUJMRSAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xuICAgICAgICBjYXNlIDIgLyogT0xEICovOlxuICAgICAgICAgICAgcmV0dXJuIG9sZEF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xufTtcbmV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZTtcbi8qKlxuICogUmV0dXJucyBpbmNvbWluZyByZXF1ZXN0IE1ldHJpYyBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge0F0dHJpYnV0ZXN9IHNwYW5BdHRyaWJ1dGVzIHRoZSBzcGFuIGF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0ge307XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdID1cbiAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfUE9SVF0gPVxuICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX1BPUlRdO1xuICAgIGlmIChzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUk9VVEVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUk9VVEVdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlO1xuY29uc3QgZ2V0SW5jb21pbmdTdGFibGVSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JPVVRFXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUk9VVEVdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXTtcbiAgICB9XG4gICAgLy8gcmVxdWlyZWQgaWYgYW5kIG9ubHkgaWYgb25lIHdhcyBzZW50LCBzYW1lIGFzIHNwYW4gcmVxdWlyZW1lbnRcbiAgICBpZiAoc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdKSB7XG4gICAgICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdID1cbiAgICAgICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRJbmNvbWluZ1N0YWJsZVJlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGdldEluY29taW5nU3RhYmxlUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlO1xuZnVuY3Rpb24gaGVhZGVyQ2FwdHVyZSh0eXBlLCBoZWFkZXJzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGhlYWRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRIZWFkZXIgPSBoZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIG5vcm1hbGl6ZWRIZWFkZXJzLnNldChjYXB0dXJlZEhlYWRlciwgY2FwdHVyZWRIZWFkZXIucmVwbGFjZSgvLS9nLCAnXycpKTtcbiAgICB9XG4gICAgcmV0dXJuIChzcGFuLCBnZXRIZWFkZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjYXB0dXJlZEhlYWRlciBvZiBub3JtYWxpemVkSGVhZGVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0SGVhZGVyKGNhcHR1cmVkSGVhZGVyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSGVhZGVyID0gbm9ybWFsaXplZEhlYWRlcnMuZ2V0KGNhcHR1cmVkSGVhZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGBodHRwLiR7dHlwZX0uaGVhZGVyLiR7bm9ybWFsaXplZEhlYWRlcn1gO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShrZXksIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGtleSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5oZWFkZXJDYXB0dXJlID0gaGVhZGVyQ2FwdHVyZTtcbmNvbnN0IEtOT1dOX01FVEhPRFMgPSBuZXcgU2V0KFtcbiAgICAvLyBtZXRob2RzIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTAuaHRtbCNuYW1lLW1ldGhvZHNcbiAgICAnR0VUJyxcbiAgICAnSEVBRCcsXG4gICAgJ1BPU1QnLFxuICAgICdQVVQnLFxuICAgICdERUxFVEUnLFxuICAgICdDT05ORUNUJyxcbiAgICAnT1BUSU9OUycsXG4gICAgJ1RSQUNFJyxcbiAgICAvLyBQQVRDSCBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM1Nzg5Lmh0bWxcbiAgICAnUEFUQ0gnLFxuXSk7XG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnR0VUJztcbiAgICB9XG4gICAgY29uc3QgdXBwZXIgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoS05PV05fTUVUSE9EUy5oYXModXBwZXIpKSB7XG4gICAgICAgIHJldHVybiB1cHBlcjtcbiAgICB9XG4gICAgcmV0dXJuICdfT1RIRVInO1xufVxuZnVuY3Rpb24gcGFyc2VGb3J3YXJkZWRIZWFkZXIoaGVhZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZvcndhcmRlZFBhcnNlKGhlYWRlcik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.VERSION = '0.57.2';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5WRVJTSU9OID0gJzAuNTcuMic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js":</span>
<span class="cstat-no" title="statement not covered" >/*!***********************************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \***********************************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttributeNames = void 0;\n/**\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md\n */\nvar AttributeNames;\n(function (AttributeNames) {\n    AttributeNames[\"HTTP_ERROR_NAME\"] = \"http.error_name\";\n    AttributeNames[\"HTTP_ERROR_MESSAGE\"] = \"http.error_message\";\n    AttributeNames[\"HTTP_STATUS_TEXT\"] = \"http.status_text\";\n})(AttributeNames = exports.AttributeNames || (exports.AttributeNames = {}));\n//# sourceMappingURL=AttributeNames.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2VudW1zL0F0dHJpYnV0ZU5hbWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEMsc0JBQXNCLEtBQUs7QUFDMUUiLCJzb3VyY2VzIjpbIi9ob21lL29tYXIvRG9jdW1lbnRzL3J1bGVJUS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2VudW1zL0F0dHJpYnV0ZU5hbWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXR0cmlidXRlTmFtZXMgPSB2b2lkIDA7XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LXNwZWNpZmljYXRpb24vYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi90cmFjZS9zZW1hbnRpY19jb252ZW50aW9ucy9odHRwLm1kXG4gKi9cbnZhciBBdHRyaWJ1dGVOYW1lcztcbihmdW5jdGlvbiAoQXR0cmlidXRlTmFtZXMpIHtcbiAgICBBdHRyaWJ1dGVOYW1lc1tcIkhUVFBfRVJST1JfTkFNRVwiXSA9IFwiaHR0cC5lcnJvcl9uYW1lXCI7XG4gICAgQXR0cmlidXRlTmFtZXNbXCJIVFRQX0VSUk9SX01FU1NBR0VcIl0gPSBcImh0dHAuZXJyb3JfbWVzc2FnZVwiO1xuICAgIEF0dHJpYnV0ZU5hbWVzW1wiSFRUUF9TVEFUVVNfVEVYVFwiXSA9IFwiaHR0cC5zdGF0dXNfdGV4dFwiO1xufSkoQXR0cmlidXRlTmFtZXMgPSBleHBvcnRzLkF0dHJpYnV0ZU5hbWVzIHx8IChleHBvcnRzLkF0dHJpYnV0ZU5hbWVzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0ZU5hbWVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js":</span>
<span class="cstat-no" title="statement not covered" >/*!*******************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \*******************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst semver = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/.pnpm/semver@7.7.2/node_modules/semver/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst version_1 = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst core_2 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js\");\n/**\n * `node:http` and `node:https` instrumentation for OpenTelemetry\n */\nclass HttpInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super('@opentelemetry/instrumentation-http', version_1.VERSION, config);\n        /** keep track on spans not ended */\n        this._spanNotEnded = new WeakSet();\n        this._semconvStability = 2 /* OLD */;\n        this._headerCapture = this._createHeaderCapture();\n        for (const entry of (0, core_2.getEnv)().OTEL_SEMCONV_STABILITY_OPT_IN) {\n            if (entry.toLowerCase() === 'http/dup') {\n                // http/dup takes highest precedence. If it is found, there is no need to read the rest of the list\n                this._semconvStability = 3 /* DUPLICATE */;\n                break;\n            }\n            else if (entry.toLowerCase() === 'http') {\n                this._semconvStability = 1 /* STABLE */;\n            }\n        }\n    }\n    _updateMetricInstruments() {\n        this._oldHttpServerDurationHistogram = this.meter.createHistogram('http.server.duration', {\n            description: 'Measures the duration of inbound HTTP requests.',\n            unit: 'ms',\n            valueType: api_1.ValueType.DOUBLE,\n        });\n        this._oldHttpClientDurationHistogram = this.meter.createHistogram('http.client.duration', {\n            description: 'Measures the duration of outbound HTTP requests.',\n            unit: 'ms',\n            valueType: api_1.ValueType.DOUBLE,\n        });\n        this._stableHttpServerDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_SERVER_REQUEST_DURATION, {\n            description: 'Duration of HTTP server requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n        this._stableHttpClientDurationHistogram = this.meter.createHistogram(semantic_conventions_1.METRIC_HTTP_CLIENT_REQUEST_DURATION, {\n            description: 'Duration of HTTP client requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n    }\n    _recordServerDuration(durationMs, oldAttributes, stableAttributes) {\n        if ((this._semconvStability &amp; 2 /* OLD */) ===\n            2 /* OLD */) {\n            // old histogram is counted in MS\n            this._oldHttpServerDurationHistogram.record(durationMs, oldAttributes);\n        }\n        if ((this._semconvStability &amp; 1 /* STABLE */) ===\n            1 /* STABLE */) {\n            // stable histogram is counted in S\n            this._stableHttpServerDurationHistogram.record(durationMs / 1000, stableAttributes);\n        }\n    }\n    _recordClientDuration(durationMs, oldAttributes, stableAttributes) {\n        if ((this._semconvStability &amp; 2 /* OLD */) ===\n            2 /* OLD */) {\n            // old histogram is counted in MS\n            this._oldHttpClientDurationHistogram.record(durationMs, oldAttributes);\n        }\n        if ((this._semconvStability &amp; 1 /* STABLE */) ===\n            1 /* STABLE */) {\n            // stable histogram is counted in S\n            this._stableHttpClientDurationHistogram.record(durationMs / 1000, stableAttributes);\n        }\n    }\n    setConfig(config = {}) {\n        super.setConfig(config);\n        this._headerCapture = this._createHeaderCapture();\n    }\n    init() {\n        return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];\n    }\n    _getHttpInstrumentation() {\n        return new instrumentation_1.InstrumentationNodeModuleDefinition('http', ['*'], (moduleExports) =&gt; {\n            const isESM = moduleExports[Symbol.toStringTag] === 'Module';\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                const patchedRequest = this._wrap(moduleExports, 'request', this._getPatchOutgoingRequestFunction('http'));\n                const patchedGet = this._wrap(moduleExports, 'get', this._getPatchOutgoingGetFunction(patchedRequest));\n                if (isESM) {\n                    // To handle `import http from 'http'`, which returns the default\n                    // export, we need to set `module.default.*`.\n                    moduleExports.default.request = patchedRequest;\n                    moduleExports.default.get = patchedGet;\n                }\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._wrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction('http'));\n            }\n            return moduleExports;\n        }, (moduleExports) =&gt; {\n            if (moduleExports === undefined)\n                return;\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                this._unwrap(moduleExports, 'request');\n                this._unwrap(moduleExports, 'get');\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._unwrap(moduleExports.Server.prototype, 'emit');\n            }\n        });\n    }\n    _getHttpsInstrumentation() {\n        return new instrumentation_1.InstrumentationNodeModuleDefinition('https', ['*'], (moduleExports) =&gt; {\n            const isESM = moduleExports[Symbol.toStringTag] === 'Module';\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                const patchedRequest = this._wrap(moduleExports, 'request', this._getPatchHttpsOutgoingRequestFunction('https'));\n                const patchedGet = this._wrap(moduleExports, 'get', this._getPatchHttpsOutgoingGetFunction(patchedRequest));\n                if (isESM) {\n                    // To handle `import https from 'https'`, which returns the default\n                    // export, we need to set `module.default.*`.\n                    moduleExports.default.request = patchedRequest;\n                    moduleExports.default.get = patchedGet;\n                }\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._wrap(moduleExports.Server.prototype, 'emit', this._getPatchIncomingRequestFunction('https'));\n            }\n            return moduleExports;\n        }, (moduleExports) =&gt; {\n            if (moduleExports === undefined)\n                return;\n            if (!this.getConfig().disableOutgoingRequestInstrumentation) {\n                this._unwrap(moduleExports, 'request');\n                this._unwrap(moduleExports, 'get');\n            }\n            if (!this.getConfig().disableIncomingRequestInstrumentation) {\n                this._unwrap(moduleExports.Server.prototype, 'emit');\n            }\n        });\n    }\n    /**\n     * Creates spans for incoming requests, restoring spans' context if applied.\n     */\n    _getPatchIncomingRequestFunction(component) {\n        return (original) =&gt; {\n            return this._incomingRequestFunction(component, original);\n        };\n    }\n    /**\n     * Creates spans for outgoing requests, sending spans' context for distributed\n     * tracing.\n     */\n    _getPatchOutgoingRequestFunction(component) {\n        return (original) =&gt; {\n            return this._outgoingRequestFunction(component, original);\n        };\n    }\n    _getPatchOutgoingGetFunction(clientRequest) {\n        return (_original) =&gt; {\n            // Re-implement http.get. This needs to be done (instead of using\n            // getPatchOutgoingRequestFunction to patch it) because we need to\n            // set the trace context header before the returned http.ClientRequest is\n            // ended. The Node.js docs state that the only differences between\n            // request and get are that (1) get defaults to the HTTP GET method and\n            // (2) the returned request object is ended immediately. The former is\n            // already true (at least in supported Node versions up to v10), so we\n            // simply follow the latter. Ref:\n            // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback\n            // https://github.com/googleapis/cloud-trace-nodejs/blob/master/src/instrumentations/instrumentation-http.ts#L198\n            return function outgoingGetRequest(options, ...args) {\n                const req = clientRequest(options, ...args);\n                req.end();\n                return req;\n            };\n        };\n    }\n    /** Patches HTTPS outgoing requests */\n    _getPatchHttpsOutgoingRequestFunction(component) {\n        return (original) =&gt; {\n            const instrumentation = this;\n            return function httpsOutgoingRequest(\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            options, ...args) {\n                var _a;\n                // Makes sure options will have default HTTPS parameters\n                if (component === 'https' &amp;&amp;\n                    typeof options === 'object' &amp;&amp;\n                    ((_a = options === null || options === void 0 ? void 0 : options.constructor) === null || _a === void 0 ? void 0 : _a.name) !== 'URL') {\n                    options = Object.assign({}, options);\n                    instrumentation._setDefaultOptions(options);\n                }\n                return instrumentation._getPatchOutgoingRequestFunction(component)(original)(options, ...args);\n            };\n        };\n    }\n    _setDefaultOptions(options) {\n        options.protocol = options.protocol || 'https:';\n        options.port = options.port || 443;\n    }\n    /** Patches HTTPS outgoing get requests */\n    _getPatchHttpsOutgoingGetFunction(clientRequest) {\n        return (original) =&gt; {\n            const instrumentation = this;\n            return function httpsOutgoingRequest(\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            options, ...args) {\n                return instrumentation._getPatchOutgoingGetFunction(clientRequest)(original)(options, ...args);\n            };\n        };\n    }\n    /**\n     * Attach event listeners to a client request to end span and add span attributes.\n     *\n     * @param request The original request object.\n     * @param span representing the current operation\n     * @param startTime representing the start time of the request to calculate duration in Metric\n     * @param oldMetricAttributes metric attributes for old semantic conventions\n     * @param stableMetricAttributes metric attributes for new semantic conventions\n     */\n    _traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes) {\n        if (this.getConfig().requestHook) {\n            this._callRequestHook(span, request);\n        }\n        /**\n         * Determines if the request has errored or the response has ended/errored.\n         */\n        let responseFinished = false;\n        /*\n         * User 'response' event listeners can be added before our listener,\n         * force our listener to be the first, so response emitter is bound\n         * before any user listeners are added to it.\n         */\n        request.prependListener('response', (response) =&gt; {\n            this._diag.debug('outgoingRequest on response()');\n            if (request.listenerCount('response') &lt;= 1) {\n                response.resume();\n            }\n            const responseAttributes = (0, utils_1.getOutgoingRequestAttributesOnResponse)(response, this._semconvStability);\n            span.setAttributes(responseAttributes);\n            oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getOutgoingRequestMetricAttributesOnResponse)(responseAttributes));\n            if (this.getConfig().responseHook) {\n                this._callResponseHook(span, response);\n            }\n            this._headerCapture.client.captureRequestHeaders(span, header =&gt; request.getHeader(header));\n            this._headerCapture.client.captureResponseHeaders(span, header =&gt; response.headers[header]);\n            api_1.context.bind(api_1.context.active(), response);\n            const endHandler = () =&gt; {\n                this._diag.debug('outgoingRequest on end()');\n                if (responseFinished) {\n                    return;\n                }\n                responseFinished = true;\n                let status;\n                if (response.aborted &amp;&amp; !response.complete) {\n                    status = { code: api_1.SpanStatusCode.ERROR };\n                }\n                else {\n                    // behaves same for new and old semconv\n                    status = {\n                        code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.CLIENT, response.statusCode),\n                    };\n                }\n                span.setStatus(status);\n                if (this.getConfig().applyCustomAttributesOnSpan) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().applyCustomAttributesOnSpan(span, request, response), () =&gt; { }, true);\n                }\n                this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n            };\n            response.on('end', endHandler);\n            // See https://github.com/open-telemetry/opentelemetry-js/pull/3625#issuecomment-1475673533\n            if (semver.lt(process.version, '16.0.0')) {\n                response.on('close', endHandler);\n            }\n            response.on(events_1.errorMonitor, (error) =&gt; {\n                this._diag.debug('outgoingRequest on error()', error);\n                if (responseFinished) {\n                    return;\n                }\n                responseFinished = true;\n                (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n                span.setStatus({\n                    code: api_1.SpanStatusCode.ERROR,\n                    message: error.message,\n                });\n                this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n            });\n        });\n        request.on('close', () =&gt; {\n            this._diag.debug('outgoingRequest on request close()');\n            if (request.aborted || responseFinished) {\n                return;\n            }\n            responseFinished = true;\n            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n        });\n        request.on(events_1.errorMonitor, (error) =&gt; {\n            this._diag.debug('outgoingRequest on request error()', error);\n            if (responseFinished) {\n                return;\n            }\n            responseFinished = true;\n            (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n            this._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n        });\n        this._diag.debug('http.ClientRequest return request');\n        return request;\n    }\n    _incomingRequestFunction(component, original) {\n        const instrumentation = this;\n        return function incomingRequest(event, ...args) {\n            // Only traces request events\n            if (event !== 'request') {\n                return original.apply(this, [event, ...args]);\n            }\n            const request = args[0];\n            const response = args[1];\n            const method = request.method || 'GET';\n            instrumentation._diag.debug(`${component} instrumentation incomingRequest`);\n            if ((0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; { var _a, _b; return (_b = (_a = instrumentation.getConfig()).ignoreIncomingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, request); }, (e) =&gt; {\n                if (e != null) {\n                    instrumentation._diag.error('caught ignoreIncomingRequestHook error: ', e);\n                }\n            }, true)) {\n                return api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () =&gt; {\n                    api_1.context.bind(api_1.context.active(), request);\n                    api_1.context.bind(api_1.context.active(), response);\n                    return original.apply(this, [event, ...args]);\n                });\n            }\n            const headers = request.headers;\n            const spanAttributes = (0, utils_1.getIncomingRequestAttributes)(request, {\n                component: component,\n                serverName: instrumentation.getConfig().serverName,\n                hookAttributes: instrumentation._callStartSpanHook(request, instrumentation.getConfig().startIncomingSpanHook),\n                semconvStability: instrumentation._semconvStability,\n            }, instrumentation._diag);\n            const spanOptions = {\n                kind: api_1.SpanKind.SERVER,\n                attributes: spanAttributes,\n            };\n            const startTime = (0, core_1.hrTime)();\n            const oldMetricAttributes = (0, utils_1.getIncomingRequestMetricAttributes)(spanAttributes);\n            // request method and url.scheme are both required span attributes\n            const stableMetricAttributes = {\n                [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: spanAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],\n                [semantic_conventions_1.ATTR_URL_SCHEME]: spanAttributes[semantic_conventions_1.ATTR_URL_SCHEME],\n            };\n            // recommended if and only if one was sent, same as span recommendation\n            if (spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] =\n                    spanAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];\n            }\n            const ctx = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n            const span = instrumentation._startHttpSpan(method, spanOptions, ctx);\n            const rpcMetadata = {\n                type: core_2.RPCType.HTTP,\n                span,\n            };\n            return api_1.context.with((0, core_2.setRPCMetadata)(api_1.trace.setSpan(ctx, span), rpcMetadata), () =&gt; {\n                api_1.context.bind(api_1.context.active(), request);\n                api_1.context.bind(api_1.context.active(), response);\n                if (instrumentation.getConfig().requestHook) {\n                    instrumentation._callRequestHook(span, request);\n                }\n                if (instrumentation.getConfig().responseHook) {\n                    instrumentation._callResponseHook(span, response);\n                }\n                instrumentation._headerCapture.server.captureRequestHeaders(span, header =&gt; request.headers[header]);\n                // After 'error', no further events other than 'close' should be emitted.\n                let hasError = false;\n                response.on('close', () =&gt; {\n                    if (hasError) {\n                        return;\n                    }\n                    instrumentation._onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime);\n                });\n                response.on(events_1.errorMonitor, (err) =&gt; {\n                    hasError = true;\n                    instrumentation._onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, err);\n                });\n                return (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; original.apply(this, [event, ...args]), error =&gt; {\n                    if (error) {\n                        (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);\n                        instrumentation._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n                        throw error;\n                    }\n                });\n            });\n        };\n    }\n    _outgoingRequestFunction(component, original) {\n        const instrumentation = this;\n        return function outgoingRequest(options, ...args) {\n            if (!(0, utils_1.isValidOptionsType)(options)) {\n                return original.apply(this, [options, ...args]);\n            }\n            const extraOptions = typeof args[0] === 'object' &amp;&amp;\n                (typeof options === 'string' || options instanceof url.URL)\n                ? args.shift()\n                : undefined;\n            const { method, invalidUrl, optionsParsed } = (0, utils_1.getRequestInfo)(instrumentation._diag, options, extraOptions);\n            /**\n             * Node 8's https module directly call the http one so to avoid creating\n             * 2 span for the same request we need to check that the protocol is correct\n             * See: https://github.com/nodejs/node/blob/v8.17.0/lib/https.js#L245\n             */\n            if (component === 'http' &amp;&amp;\n                semver.lt(process.version, '9.0.0') &amp;&amp;\n                optionsParsed.protocol === 'https:') {\n                return original.apply(this, [optionsParsed, ...args]);\n            }\n            if ((0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; {\n                var _a, _b;\n                return (_b = (_a = instrumentation\n                    .getConfig()).ignoreOutgoingRequestHook) === null || _b === void 0 ? void 0 : _b.call(_a, optionsParsed);\n            }, (e) =&gt; {\n                if (e != null) {\n                    instrumentation._diag.error('caught ignoreOutgoingRequestHook error: ', e);\n                }\n            }, true)) {\n                return original.apply(this, [optionsParsed, ...args]);\n            }\n            const { hostname, port } = (0, utils_1.extractHostnameAndPort)(optionsParsed);\n            const attributes = (0, utils_1.getOutgoingRequestAttributes)(optionsParsed, {\n                component,\n                port,\n                hostname,\n                hookAttributes: instrumentation._callStartSpanHook(optionsParsed, instrumentation.getConfig().startOutgoingSpanHook),\n            }, instrumentation._semconvStability);\n            const startTime = (0, core_1.hrTime)();\n            const oldMetricAttributes = (0, utils_1.getOutgoingRequestMetricAttributes)(attributes);\n            // request method, server address, and server port are both required span attributes\n            const stableMetricAttributes = {\n                [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: attributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD],\n                [semantic_conventions_1.ATTR_SERVER_ADDRESS]: attributes[semantic_conventions_1.ATTR_SERVER_ADDRESS],\n                [semantic_conventions_1.ATTR_SERVER_PORT]: attributes[semantic_conventions_1.ATTR_SERVER_PORT],\n            };\n            // required if and only if one was sent, same as span requirement\n            if (attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] =\n                    attributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];\n            }\n            // recommended if and only if one was sent, same as span recommendation\n            if (attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]) {\n                stableMetricAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] =\n                    attributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION];\n            }\n            const spanOptions = {\n                kind: api_1.SpanKind.CLIENT,\n                attributes,\n            };\n            const span = instrumentation._startHttpSpan(method, spanOptions);\n            const parentContext = api_1.context.active();\n            const requestContext = api_1.trace.setSpan(parentContext, span);\n            if (!optionsParsed.headers) {\n                optionsParsed.headers = {};\n            }\n            else {\n                // Make a copy of the headers object to avoid mutating an object the\n                // caller might have a reference to.\n                optionsParsed.headers = Object.assign({}, optionsParsed.headers);\n            }\n            api_1.propagation.inject(requestContext, optionsParsed.headers);\n            return api_1.context.with(requestContext, () =&gt; {\n                /*\n                 * The response callback is registered before ClientRequest is bound,\n                 * thus it is needed to bind it before the function call.\n                 */\n                const cb = args[args.length - 1];\n                if (typeof cb === 'function') {\n                    args[args.length - 1] = api_1.context.bind(parentContext, cb);\n                }\n                const request = (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; {\n                    if (invalidUrl) {\n                        // we know that the url is invalid, there's no point in injecting context as it will fail validation.\n                        // Passing in what the user provided will give the user an error that matches what they'd see without\n                        // the instrumentation.\n                        return original.apply(this, [options, ...args]);\n                    }\n                    else {\n                        return original.apply(this, [optionsParsed, ...args]);\n                    }\n                }, error =&gt; {\n                    if (error) {\n                        (0, utils_1.setSpanWithError)(span, error, instrumentation._semconvStability);\n                        instrumentation._closeHttpSpan(span, api_1.SpanKind.CLIENT, startTime, oldMetricAttributes, stableMetricAttributes);\n                        throw error;\n                    }\n                });\n                instrumentation._diag.debug(`${component} instrumentation outgoingRequest`);\n                api_1.context.bind(parentContext, request);\n                return instrumentation._traceClientRequest(request, span, startTime, oldMetricAttributes, stableMetricAttributes);\n            });\n        };\n    }\n    _onServerResponseFinish(request, response, span, oldMetricAttributes, stableMetricAttributes, startTime) {\n        const attributes = (0, utils_1.getIncomingRequestAttributesOnResponse)(request, response, this._semconvStability);\n        oldMetricAttributes = Object.assign(oldMetricAttributes, (0, utils_1.getIncomingRequestMetricAttributesOnResponse)(attributes));\n        stableMetricAttributes = Object.assign(stableMetricAttributes, (0, utils_1.getIncomingStableRequestMetricAttributesOnResponse)(attributes));\n        this._headerCapture.server.captureResponseHeaders(span, header =&gt; response.getHeader(header));\n        span.setAttributes(attributes).setStatus({\n            code: (0, utils_1.parseResponseStatus)(api_1.SpanKind.SERVER, response.statusCode),\n        });\n        const route = attributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n        if (route) {\n            span.updateName(`${request.method || 'GET'} ${route}`);\n        }\n        if (this.getConfig().applyCustomAttributesOnSpan) {\n            (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().applyCustomAttributesOnSpan(span, request, response), () =&gt; { }, true);\n        }\n        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n    }\n    _onServerResponseError(span, oldMetricAttributes, stableMetricAttributes, startTime, error) {\n        (0, utils_1.setSpanWithError)(span, error, this._semconvStability);\n        // TODO get error attributes for metrics\n        this._closeHttpSpan(span, api_1.SpanKind.SERVER, startTime, oldMetricAttributes, stableMetricAttributes);\n    }\n    _startHttpSpan(name, options, ctx = api_1.context.active()) {\n        /*\n         * If a parent is required but not present, we use a `NoopSpan` to still\n         * propagate context without recording it.\n         */\n        const requireParent = options.kind === api_1.SpanKind.CLIENT\n            ? this.getConfig().requireParentforOutgoingSpans\n            : this.getConfig().requireParentforIncomingSpans;\n        let span;\n        const currentSpan = api_1.trace.getSpan(ctx);\n        if (requireParent === true &amp;&amp; currentSpan === undefined) {\n            span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);\n        }\n        else if (requireParent === true &amp;&amp; (currentSpan === null || currentSpan === void 0 ? void 0 : currentSpan.spanContext().isRemote)) {\n            span = currentSpan;\n        }\n        else {\n            span = this.tracer.startSpan(name, options, ctx);\n        }\n        this._spanNotEnded.add(span);\n        return span;\n    }\n    _closeHttpSpan(span, spanKind, startTime, oldMetricAttributes, stableMetricAttributes) {\n        if (!this._spanNotEnded.has(span)) {\n            return;\n        }\n        span.end();\n        this._spanNotEnded.delete(span);\n        // Record metrics\n        const duration = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)()));\n        if (spanKind === api_1.SpanKind.SERVER) {\n            this._recordServerDuration(duration, oldMetricAttributes, stableMetricAttributes);\n        }\n        else if (spanKind === api_1.SpanKind.CLIENT) {\n            this._recordClientDuration(duration, oldMetricAttributes, stableMetricAttributes);\n        }\n    }\n    _callResponseHook(span, response) {\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().responseHook(span, response), () =&gt; { }, true);\n    }\n    _callRequestHook(span, request) {\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; this.getConfig().requestHook(span, request), () =&gt; { }, true);\n    }\n    _callStartSpanHook(request, hookFunc) {\n        if (typeof hookFunc === 'function') {\n            return (0, instrumentation_1.safeExecuteInTheMiddle)(() =&gt; hookFunc(request), () =&gt; { }, true);\n        }\n    }\n    _createHeaderCapture() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const config = this.getConfig();\n        return {\n            client: {\n                captureRequestHeaders: (0, utils_1.headerCapture)('request', (_c = (_b = (_a = config.headersToSpanAttributes) === null || _a === void 0 ? void 0 : _a.client) === null || _b === void 0 ? void 0 : _b.requestHeaders) !== null &amp;&amp; _c !== void 0 ? _c : []),\n                captureResponseHeaders: (0, utils_1.headerCapture)('response', (_f = (_e = (_d = config.headersToSpanAttributes) === null || _d === void 0 ? void 0 : _d.client) === null || _e === void 0 ? void 0 : _e.responseHeaders) !== null &amp;&amp; _f !== void 0 ? _f : []),\n            },\n            server: {\n                captureRequestHeaders: (0, utils_1.headerCapture)('request', (_j = (_h = (_g = config.headersToSpanAttributes) === null || _g === void 0 ? void 0 : _g.server) === null || _h === void 0 ? void 0 : _h.requestHeaders) !== null &amp;&amp; _j !== void 0 ? _j : []),\n                captureResponseHeaders: (0, utils_1.headerCapture)('response', (_m = (_l = (_k = config.headersToSpanAttributes) === null || _k === void 0 ? void 0 : _k.server) === null || _l === void 0 ? void 0 : _l.responseHeaders) !== null &amp;&amp; _m !== void 0 ? _m : []),\n            },\n        };\n    }\n}\nexports.HttpInstrumentation = HttpInstrumentation;\n//# sourceMappingURL=http.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2h0dHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxrSUFBb0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLCtKQUFxQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsb0ZBQVE7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLHVMQUFXO0FBQ3JDLDBCQUEwQixtQkFBTyxDQUFDLGdNQUFnQztBQUNsRSxlQUFlLG1CQUFPLENBQUMsK0pBQXFCO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLCtCQUErQixtQkFBTyxDQUFDLHNMQUFxQztBQUM1RSxnQkFBZ0IsbUJBQU8sQ0FBQyxtTEFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9IO0FBQ3BIO0FBQ0E7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy9odHRwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuY29uc3QgaW5zdHJ1bWVudGF0aW9uXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uXCIpO1xuY29uc3QgY29yZV8yID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2NvcmVcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBgbm9kZTpodHRwYCBhbmQgYG5vZGU6aHR0cHNgIGluc3RydW1lbnRhdGlvbiBmb3IgT3BlblRlbGVtZXRyeVxuICovXG5jbGFzcyBIdHRwSW5zdHJ1bWVudGF0aW9uIGV4dGVuZHMgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwJywgdmVyc2lvbl8xLlZFUlNJT04sIGNvbmZpZyk7XG4gICAgICAgIC8qKiBrZWVwIHRyYWNrIG9uIHNwYW5zIG5vdCBlbmRlZCAqL1xuICAgICAgICB0aGlzLl9zcGFuTm90RW5kZWQgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICB0aGlzLl9zZW1jb252U3RhYmlsaXR5ID0gMiAvKiBPTEQgKi87XG4gICAgICAgIHRoaXMuX2hlYWRlckNhcHR1cmUgPSB0aGlzLl9jcmVhdGVIZWFkZXJDYXB0dXJlKCk7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgKDAsIGNvcmVfMi5nZXRFbnYpKCkuT1RFTF9TRU1DT05WX1NUQUJJTElUWV9PUFRfSU4pIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cC9kdXAnKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cC9kdXAgdGFrZXMgaGlnaGVzdCBwcmVjZWRlbmNlLiBJZiBpdCBpcyBmb3VuZCwgdGhlcmUgaXMgbm8gbmVlZCB0byByZWFkIHRoZSByZXN0IG9mIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VtY29udlN0YWJpbGl0eSA9IDMgLyogRFVQTElDQVRFICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkudG9Mb3dlckNhc2UoKSA9PT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VtY29udlN0YWJpbGl0eSA9IDEgLyogU1RBQkxFICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVNZXRyaWNJbnN0cnVtZW50cygpIHtcbiAgICAgICAgdGhpcy5fb2xkSHR0cFNlcnZlckR1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oJ2h0dHAuc2VydmVyLmR1cmF0aW9uJywge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdNZWFzdXJlcyB0aGUgZHVyYXRpb24gb2YgaW5ib3VuZCBIVFRQIHJlcXVlc3RzLicsXG4gICAgICAgICAgICB1bml0OiAnbXMnLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBhcGlfMS5WYWx1ZVR5cGUuRE9VQkxFLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2xkSHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oJ2h0dHAuY2xpZW50LmR1cmF0aW9uJywge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdNZWFzdXJlcyB0aGUgZHVyYXRpb24gb2Ygb3V0Ym91bmQgSFRUUCByZXF1ZXN0cy4nLFxuICAgICAgICAgICAgdW5pdDogJ21zJyxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogYXBpXzEuVmFsdWVUeXBlLkRPVUJMRSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N0YWJsZUh0dHBTZXJ2ZXJEdXJhdGlvbkhpc3RvZ3JhbSA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVUUklDX0hUVFBfU0VSVkVSX1JFUVVFU1RfRFVSQVRJT04sIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRHVyYXRpb24gb2YgSFRUUCBzZXJ2ZXIgcmVxdWVzdHMuJyxcbiAgICAgICAgICAgIHVuaXQ6ICdzJyxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogYXBpXzEuVmFsdWVUeXBlLkRPVUJMRSxcbiAgICAgICAgICAgIGFkdmljZToge1xuICAgICAgICAgICAgICAgIGV4cGxpY2l0QnVja2V0Qm91bmRhcmllczogW1xuICAgICAgICAgICAgICAgICAgICAwLjAwNSwgMC4wMSwgMC4wMjUsIDAuMDUsIDAuMDc1LCAwLjEsIDAuMjUsIDAuNSwgMC43NSwgMSwgMi41LCA1LFxuICAgICAgICAgICAgICAgICAgICA3LjUsIDEwLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3RhYmxlSHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtID0gdGhpcy5tZXRlci5jcmVhdGVIaXN0b2dyYW0oc2VtYW50aWNfY29udmVudGlvbnNfMS5NRVRSSUNfSFRUUF9DTElFTlRfUkVRVUVTVF9EVVJBVElPTiwge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEdXJhdGlvbiBvZiBIVFRQIGNsaWVudCByZXF1ZXN0cy4nLFxuICAgICAgICAgICAgdW5pdDogJ3MnLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBhcGlfMS5WYWx1ZVR5cGUuRE9VQkxFLFxuICAgICAgICAgICAgYWR2aWNlOiB7XG4gICAgICAgICAgICAgICAgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBbXG4gICAgICAgICAgICAgICAgICAgIDAuMDA1LCAwLjAxLCAwLjAyNSwgMC4wNSwgMC4wNzUsIDAuMSwgMC4yNSwgMC41LCAwLjc1LCAxLCAyLjUsIDUsXG4gICAgICAgICAgICAgICAgICAgIDcuNSwgMTAsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVjb3JkU2VydmVyRHVyYXRpb24oZHVyYXRpb25Ncywgb2xkQXR0cmlidXRlcywgc3RhYmxlQXR0cmlidXRlcykge1xuICAgICAgICBpZiAoKHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgJiAyIC8qIE9MRCAqLykgPT09XG4gICAgICAgICAgICAyIC8qIE9MRCAqLykge1xuICAgICAgICAgICAgLy8gb2xkIGhpc3RvZ3JhbSBpcyBjb3VudGVkIGluIE1TXG4gICAgICAgICAgICB0aGlzLl9vbGRIdHRwU2VydmVyRHVyYXRpb25IaXN0b2dyYW0ucmVjb3JkKGR1cmF0aW9uTXMsIG9sZEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fc2VtY29udlN0YWJpbGl0eSAmIDEgLyogU1RBQkxFICovKSA9PT1cbiAgICAgICAgICAgIDEgLyogU1RBQkxFICovKSB7XG4gICAgICAgICAgICAvLyBzdGFibGUgaGlzdG9ncmFtIGlzIGNvdW50ZWQgaW4gU1xuICAgICAgICAgICAgdGhpcy5fc3RhYmxlSHR0cFNlcnZlckR1cmF0aW9uSGlzdG9ncmFtLnJlY29yZChkdXJhdGlvbk1zIC8gMTAwMCwgc3RhYmxlQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlY29yZENsaWVudER1cmF0aW9uKGR1cmF0aW9uTXMsIG9sZEF0dHJpYnV0ZXMsIHN0YWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCh0aGlzLl9zZW1jb252U3RhYmlsaXR5ICYgMiAvKiBPTEQgKi8pID09PVxuICAgICAgICAgICAgMiAvKiBPTEQgKi8pIHtcbiAgICAgICAgICAgIC8vIG9sZCBoaXN0b2dyYW0gaXMgY291bnRlZCBpbiBNU1xuICAgICAgICAgICAgdGhpcy5fb2xkSHR0cENsaWVudER1cmF0aW9uSGlzdG9ncmFtLnJlY29yZChkdXJhdGlvbk1zLCBvbGRBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRoaXMuX3NlbWNvbnZTdGFiaWxpdHkgJiAxIC8qIFNUQUJMRSAqLykgPT09XG4gICAgICAgICAgICAxIC8qIFNUQUJMRSAqLykge1xuICAgICAgICAgICAgLy8gc3RhYmxlIGhpc3RvZ3JhbSBpcyBjb3VudGVkIGluIFNcbiAgICAgICAgICAgIHRoaXMuX3N0YWJsZUh0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbS5yZWNvcmQoZHVyYXRpb25NcyAvIDEwMDAsIHN0YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbmZpZyhjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlci5zZXRDb25maWcoY29uZmlnKTtcbiAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZSA9IHRoaXMuX2NyZWF0ZUhlYWRlckNhcHR1cmUoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9nZXRIdHRwc0luc3RydW1lbnRhdGlvbigpLCB0aGlzLl9nZXRIdHRwSW5zdHJ1bWVudGF0aW9uKCldO1xuICAgIH1cbiAgICBfZ2V0SHR0cEluc3RydW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRGVmaW5pdGlvbignaHR0cCcsIFsnKiddLCAobW9kdWxlRXhwb3J0cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNFU00gPSBtb2R1bGVFeHBvcnRzW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVPdXRnb2luZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkUmVxdWVzdCA9IHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgJ3JlcXVlc3QnLCB0aGlzLl9nZXRQYXRjaE91dGdvaW5nUmVxdWVzdEZ1bmN0aW9uKCdodHRwJykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRHZXQgPSB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMsICdnZXQnLCB0aGlzLl9nZXRQYXRjaE91dGdvaW5nR2V0RnVuY3Rpb24ocGF0Y2hlZFJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFU00pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gaGFuZGxlIGBpbXBvcnQgaHR0cCBmcm9tICdodHRwJ2AsIHdoaWNoIHJldHVybnMgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3J0LCB3ZSBuZWVkIHRvIHNldCBgbW9kdWxlLmRlZmF1bHQuKmAuXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydHMuZGVmYXVsdC5yZXF1ZXN0ID0gcGF0Y2hlZFJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydHMuZGVmYXVsdC5nZXQgPSBwYXRjaGVkR2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlSW5jb21pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsICdlbWl0JywgdGhpcy5fZ2V0UGF0Y2hJbmNvbWluZ1JlcXVlc3RGdW5jdGlvbignaHR0cCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgICAgICB9LCAobW9kdWxlRXhwb3J0cykgPT4ge1xuICAgICAgICAgICAgaWYgKG1vZHVsZUV4cG9ydHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZU91dGdvaW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAncmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLCAnZ2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZUluY29taW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Vud3JhcChtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsICdlbWl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0SHR0cHNJbnN0cnVtZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZURlZmluaXRpb24oJ2h0dHBzJywgWycqJ10sIChtb2R1bGVFeHBvcnRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0VTTSA9IG1vZHVsZUV4cG9ydHNbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZSc7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKCkuZGlzYWJsZU91dGdvaW5nUmVxdWVzdEluc3RydW1lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoZWRSZXF1ZXN0ID0gdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLCAncmVxdWVzdCcsIHRoaXMuX2dldFBhdGNoSHR0cHNPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbignaHR0cHMnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZEdldCA9IHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cywgJ2dldCcsIHRoaXMuX2dldFBhdGNoSHR0cHNPdXRnb2luZ0dldEZ1bmN0aW9uKHBhdGNoZWRSZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRVNNKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGhhbmRsZSBgaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJ2AsIHdoaWNoIHJldHVybnMgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3J0LCB3ZSBuZWVkIHRvIHNldCBgbW9kdWxlLmRlZmF1bHQuKmAuXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydHMuZGVmYXVsdC5yZXF1ZXN0ID0gcGF0Y2hlZFJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydHMuZGVmYXVsdC5nZXQgPSBwYXRjaGVkR2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoKS5kaXNhYmxlSW5jb21pbmdSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLlNlcnZlci5wcm90b3R5cGUsICdlbWl0JywgdGhpcy5fZ2V0UGF0Y2hJbmNvbWluZ1JlcXVlc3RGdW5jdGlvbignaHR0cHMnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICAgICAgfSwgKG1vZHVsZUV4cG9ydHMpID0+IHtcbiAgICAgICAgICAgIGlmIChtb2R1bGVFeHBvcnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVPdXRnb2luZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgJ3JlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgJ2dldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZygpLmRpc2FibGVJbmNvbWluZ1JlcXVlc3RJbnN0cnVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5TZXJ2ZXIucHJvdG90eXBlLCAnZW1pdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBzcGFucyBmb3IgaW5jb21pbmcgcmVxdWVzdHMsIHJlc3RvcmluZyBzcGFucycgY29udGV4dCBpZiBhcHBsaWVkLlxuICAgICAqL1xuICAgIF9nZXRQYXRjaEluY29taW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5jb21pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50LCBvcmlnaW5hbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgc3BhbnMgZm9yIG91dGdvaW5nIHJlcXVlc3RzLCBzZW5kaW5nIHNwYW5zJyBjb250ZXh0IGZvciBkaXN0cmlidXRlZFxuICAgICAqIHRyYWNpbmcuXG4gICAgICovXG4gICAgX2dldFBhdGNoT3V0Z29pbmdSZXF1ZXN0RnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQsIG9yaWdpbmFsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldFBhdGNoT3V0Z29pbmdHZXRGdW5jdGlvbihjbGllbnRSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiAoX29yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICAvLyBSZS1pbXBsZW1lbnQgaHR0cC5nZXQuIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSAoaW5zdGVhZCBvZiB1c2luZ1xuICAgICAgICAgICAgLy8gZ2V0UGF0Y2hPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbiB0byBwYXRjaCBpdCkgYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHRyYWNlIGNvbnRleHQgaGVhZGVyIGJlZm9yZSB0aGUgcmV0dXJuZWQgaHR0cC5DbGllbnRSZXF1ZXN0IGlzXG4gICAgICAgICAgICAvLyBlbmRlZC4gVGhlIE5vZGUuanMgZG9jcyBzdGF0ZSB0aGF0IHRoZSBvbmx5IGRpZmZlcmVuY2VzIGJldHdlZW5cbiAgICAgICAgICAgIC8vIHJlcXVlc3QgYW5kIGdldCBhcmUgdGhhdCAoMSkgZ2V0IGRlZmF1bHRzIHRvIHRoZSBIVFRQIEdFVCBtZXRob2QgYW5kXG4gICAgICAgICAgICAvLyAoMikgdGhlIHJldHVybmVkIHJlcXVlc3Qgb2JqZWN0IGlzIGVuZGVkIGltbWVkaWF0ZWx5LiBUaGUgZm9ybWVyIGlzXG4gICAgICAgICAgICAvLyBhbHJlYWR5IHRydWUgKGF0IGxlYXN0IGluIHN1cHBvcnRlZCBOb2RlIHZlcnNpb25zIHVwIHRvIHYxMCksIHNvIHdlXG4gICAgICAgICAgICAvLyBzaW1wbHkgZm9sbG93IHRoZSBsYXR0ZXIuIFJlZjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS9odHRwLmh0bWwjaHR0cF9odHRwX2dldF9vcHRpb25zX2NhbGxiYWNrXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9jbG91ZC10cmFjZS1ub2RlanMvYmxvYi9tYXN0ZXIvc3JjL2luc3RydW1lbnRhdGlvbnMvaW5zdHJ1bWVudGF0aW9uLWh0dHAudHMjTDE5OFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG91dGdvaW5nR2V0UmVxdWVzdChvcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxID0gY2xpZW50UmVxdWVzdChvcHRpb25zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICByZXEuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBQYXRjaGVzIEhUVFBTIG91dGdvaW5nIHJlcXVlc3RzICovXG4gICAgX2dldFBhdGNoSHR0cHNPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIChvcmlnaW5hbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBodHRwc091dGdvaW5nUmVxdWVzdChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICAgIG9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gTWFrZXMgc3VyZSBvcHRpb25zIHdpbGwgaGF2ZSBkZWZhdWx0IEhUVFBTIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ID09PSAnaHR0cHMnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgIT09ICdVUkwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9zZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbi5fZ2V0UGF0Y2hPdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQpKG9yaWdpbmFsKShvcHRpb25zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMucHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sIHx8ICdodHRwczonO1xuICAgICAgICBvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgNDQzO1xuICAgIH1cbiAgICAvKiogUGF0Y2hlcyBIVFRQUyBvdXRnb2luZyBnZXQgcmVxdWVzdHMgKi9cbiAgICBfZ2V0UGF0Y2hIdHRwc091dGdvaW5nR2V0RnVuY3Rpb24oY2xpZW50UmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gKG9yaWdpbmFsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVtZW50YXRpb24gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBzT3V0Z29pbmdSZXF1ZXN0KFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgICAgb3B0aW9ucywgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX2dldFBhdGNoT3V0Z29pbmdHZXRGdW5jdGlvbihjbGllbnRSZXF1ZXN0KShvcmlnaW5hbCkob3B0aW9ucywgLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIGEgY2xpZW50IHJlcXVlc3QgdG8gZW5kIHNwYW4gYW5kIGFkZCBzcGFuIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QuXG4gICAgICogQHBhcmFtIHNwYW4gcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgcmVwcmVzZW50aW5nIHRoZSBzdGFydCB0aW1lIG9mIHRoZSByZXF1ZXN0IHRvIGNhbGN1bGF0ZSBkdXJhdGlvbiBpbiBNZXRyaWNcbiAgICAgKiBAcGFyYW0gb2xkTWV0cmljQXR0cmlidXRlcyBtZXRyaWMgYXR0cmlidXRlcyBmb3Igb2xkIHNlbWFudGljIGNvbnZlbnRpb25zXG4gICAgICogQHBhcmFtIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMgbWV0cmljIGF0dHJpYnV0ZXMgZm9yIG5ldyBzZW1hbnRpYyBjb252ZW50aW9uc1xuICAgICAqL1xuICAgIF90cmFjZUNsaWVudFJlcXVlc3QocmVxdWVzdCwgc3Bhbiwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmdldENvbmZpZygpLnJlcXVlc3RIb29rKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsUmVxdWVzdEhvb2soc3BhbiwgcmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIHJlcXVlc3QgaGFzIGVycm9yZWQgb3IgdGhlIHJlc3BvbnNlIGhhcyBlbmRlZC9lcnJvcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHJlc3BvbnNlRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgLypcbiAgICAgICAgICogVXNlciAncmVzcG9uc2UnIGV2ZW50IGxpc3RlbmVycyBjYW4gYmUgYWRkZWQgYmVmb3JlIG91ciBsaXN0ZW5lcixcbiAgICAgICAgICogZm9yY2Ugb3VyIGxpc3RlbmVyIHRvIGJlIHRoZSBmaXJzdCwgc28gcmVzcG9uc2UgZW1pdHRlciBpcyBib3VuZFxuICAgICAgICAgKiBiZWZvcmUgYW55IHVzZXIgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVlc3QucHJlcGVuZExpc3RlbmVyKCdyZXNwb25zZScsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGlhZy5kZWJ1Zygnb3V0Z29pbmdSZXF1ZXN0IG9uIHJlc3BvbnNlKCknKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lmxpc3RlbmVyQ291bnQoJ3Jlc3BvbnNlJykgPD0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UpKHJlc3BvbnNlLCB0aGlzLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhyZXNwb25zZUF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgb2xkTWV0cmljQXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24ob2xkTWV0cmljQXR0cmlidXRlcywgKDAsIHV0aWxzXzEuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UpKHJlc3BvbnNlQXR0cmlidXRlcykpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q29uZmlnKCkucmVzcG9uc2VIb29rKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbFJlc3BvbnNlSG9vayhzcGFuLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJDYXB0dXJlLmNsaWVudC5jYXB0dXJlUmVxdWVzdEhlYWRlcnMoc3BhbiwgaGVhZGVyID0+IHJlcXVlc3QuZ2V0SGVhZGVyKGhlYWRlcikpO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyQ2FwdHVyZS5jbGllbnQuY2FwdHVyZVJlc3BvbnNlSGVhZGVycyhzcGFuLCBoZWFkZXIgPT4gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCByZXNwb25zZSk7XG4gICAgICAgICAgICBjb25zdCBlbmRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpYWcuZGVidWcoJ291dGdvaW5nUmVxdWVzdCBvbiBlbmQoKScpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCAmJiAhcmVzcG9uc2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0geyBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVoYXZlcyBzYW1lIGZvciBuZXcgYW5kIG9sZCBzZW1jb252XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6ICgwLCB1dGlsc18xLnBhcnNlUmVzcG9uc2VTdGF0dXMpKGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgcmVzcG9uc2Uuc3RhdHVzQ29kZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q29uZmlnKCkuYXBwbHlDdXN0b21BdHRyaWJ1dGVzT25TcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB0aGlzLmdldENvbmZpZygpLmFwcGx5Q3VzdG9tQXR0cmlidXRlc09uU3BhbihzcGFuLCByZXF1ZXN0LCByZXNwb25zZSksICgpID0+IHsgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1qcy9wdWxsLzM2MjUjaXNzdWVjb21tZW50LTE0NzU2NzM1MzNcbiAgICAgICAgICAgIGlmIChzZW12ZXIubHQocHJvY2Vzcy52ZXJzaW9uLCAnMTYuMC4wJykpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbignY2xvc2UnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKGV2ZW50c18xLmVycm9yTW9uaXRvciwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlhZy5kZWJ1Zygnb3V0Z29pbmdSZXF1ZXN0IG9uIGVycm9yKCknLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5zZXRTcGFuV2l0aEVycm9yKShzcGFuLCBlcnJvciwgdGhpcy5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnLmRlYnVnKCdvdXRnb2luZ1JlcXVlc3Qgb24gcmVxdWVzdCBjbG9zZSgpJyk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlc3BvbnNlRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZUZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5vbihldmVudHNfMS5lcnJvck1vbml0b3IsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGlhZy5kZWJ1Zygnb3V0Z29pbmdSZXF1ZXN0IG9uIHJlcXVlc3QgZXJyb3IoKScsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2VGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS5zZXRTcGFuV2l0aEVycm9yKShzcGFuLCBlcnJvciwgdGhpcy5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLkNMSUVOVCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RpYWcuZGVidWcoJ2h0dHAuQ2xpZW50UmVxdWVzdCByZXR1cm4gcmVxdWVzdCcpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgX2luY29taW5nUmVxdWVzdEZ1bmN0aW9uKGNvbXBvbmVudCwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGluY29taW5nUmVxdWVzdChldmVudCwgLi4uYXJncykge1xuICAgICAgICAgICAgLy8gT25seSB0cmFjZXMgcmVxdWVzdCBldmVudHNcbiAgICAgICAgICAgIGlmIChldmVudCAhPT0gJ3JlcXVlc3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtldmVudCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZCB8fCAnR0VUJztcbiAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fZGlhZy5kZWJ1ZyhgJHtjb21wb25lbnR9IGluc3RydW1lbnRhdGlvbiBpbmNvbWluZ1JlcXVlc3RgKTtcbiAgICAgICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gaW5zdHJ1bWVudGF0aW9uLmdldENvbmZpZygpKS5pZ25vcmVJbmNvbWluZ1JlcXVlc3RIb29rKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgcmVxdWVzdCk7IH0sIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2RpYWcuZXJyb3IoJ2NhdWdodCBpZ25vcmVJbmNvbWluZ1JlcXVlc3RIb29rIGVycm9yOiAnLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5jb250ZXh0LndpdGgoKDAsIGNvcmVfMS5zdXBwcmVzc1RyYWNpbmcpKGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtldmVudCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcbiAgICAgICAgICAgIGNvbnN0IHNwYW5BdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlcykocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHNlcnZlck5hbWU6IGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5zZXJ2ZXJOYW1lLFxuICAgICAgICAgICAgICAgIGhvb2tBdHRyaWJ1dGVzOiBpbnN0cnVtZW50YXRpb24uX2NhbGxTdGFydFNwYW5Ib29rKHJlcXVlc3QsIGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5zdGFydEluY29taW5nU3Bhbkhvb2spLFxuICAgICAgICAgICAgICAgIHNlbWNvbnZTdGFiaWxpdHk6IGluc3RydW1lbnRhdGlvbi5fc2VtY29udlN0YWJpbGl0eSxcbiAgICAgICAgICAgIH0sIGluc3RydW1lbnRhdGlvbi5fZGlhZyk7XG4gICAgICAgICAgICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5TRVJWRVIsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogc3BhbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gKDAsIGNvcmVfMS5oclRpbWUpKCk7XG4gICAgICAgICAgICBjb25zdCBvbGRNZXRyaWNBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcykoc3BhbkF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgLy8gcmVxdWVzdCBtZXRob2QgYW5kIHVybC5zY2hlbWUgYXJlIGJvdGggcmVxdWlyZWQgc3BhbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjb25zdCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF06IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXSxcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9TQ0hFTUVdOiBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmVjb21tZW5kZWQgaWYgYW5kIG9ubHkgaWYgb25lIHdhcyBzZW50LCBzYW1lIGFzIHNwYW4gcmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgIGlmIChzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXSkge1xuICAgICAgICAgICAgICAgIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl0gPVxuICAgICAgICAgICAgICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGFwaV8xLnByb3BhZ2F0aW9uLmV4dHJhY3QoYXBpXzEuUk9PVF9DT05URVhULCBoZWFkZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBpbnN0cnVtZW50YXRpb24uX3N0YXJ0SHR0cFNwYW4obWV0aG9kLCBzcGFuT3B0aW9ucywgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IHJwY01ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGNvcmVfMi5SUENUeXBlLkhUVFAsXG4gICAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYXBpXzEuY29udGV4dC53aXRoKCgwLCBjb3JlXzIuc2V0UlBDTWV0YWRhdGEpKGFwaV8xLnRyYWNlLnNldFNwYW4oY3R4LCBzcGFuKSwgcnBjTWV0YWRhdGEpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGFwaV8xLmNvbnRleHQuYmluZChhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5yZXF1ZXN0SG9vaykge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2NhbGxSZXF1ZXN0SG9vayhzcGFuLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydW1lbnRhdGlvbi5nZXRDb25maWcoKS5yZXNwb25zZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9jYWxsUmVzcG9uc2VIb29rKHNwYW4sIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9oZWFkZXJDYXB0dXJlLnNlcnZlci5jYXB0dXJlUmVxdWVzdEhlYWRlcnMoc3BhbiwgaGVhZGVyID0+IHJlcXVlc3QuaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgICAgICAgICAvLyBBZnRlciAnZXJyb3InLCBubyBmdXJ0aGVyIGV2ZW50cyBvdGhlciB0aGFuICdjbG9zZScgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gICAgICAgICAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX29uU2VydmVyUmVzcG9uc2VGaW5pc2gocmVxdWVzdCwgcmVzcG9uc2UsIHNwYW4sIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oZXZlbnRzXzEuZXJyb3JNb25pdG9yLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uLl9vblNlcnZlclJlc3BvbnNlRXJyb3Ioc3Bhbiwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcywgc3RhcnRUaW1lLCBlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2V2ZW50LCAuLi5hcmdzXSksIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5zZXRTcGFuV2l0aEVycm9yKShzcGFuLCBlcnJvciwgaW5zdHJ1bWVudGF0aW9uLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fY2xvc2VIdHRwU3BhbihzcGFuLCBhcGlfMS5TcGFuS2luZC5TRVJWRVIsIHN0YXJ0VGltZSwgb2xkTWV0cmljQXR0cmlidXRlcywgc3RhYmxlTWV0cmljQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9vdXRnb2luZ1JlcXVlc3RGdW5jdGlvbihjb21wb25lbnQsIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBvdXRnb2luZ1JlcXVlc3Qob3B0aW9ucywgLi4uYXJncykge1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc1ZhbGlkT3B0aW9uc1R5cGUpKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHRyYU9wdGlvbnMgPSB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMgaW5zdGFuY2VvZiB1cmwuVVJMKVxuICAgICAgICAgICAgICAgID8gYXJncy5zaGlmdCgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgaW52YWxpZFVybCwgb3B0aW9uc1BhcnNlZCB9ID0gKDAsIHV0aWxzXzEuZ2V0UmVxdWVzdEluZm8pKGluc3RydW1lbnRhdGlvbi5fZGlhZywgb3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm9kZSA4J3MgaHR0cHMgbW9kdWxlIGRpcmVjdGx5IGNhbGwgdGhlIGh0dHAgb25lIHNvIHRvIGF2b2lkIGNyZWF0aW5nXG4gICAgICAgICAgICAgKiAyIHNwYW4gZm9yIHRoZSBzYW1lIHJlcXVlc3Qgd2UgbmVlZCB0byBjaGVjayB0aGF0IHRoZSBwcm90b2NvbCBpcyBjb3JyZWN0XG4gICAgICAgICAgICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjE3LjAvbGliL2h0dHBzLmpzI0wyNDVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJ2h0dHAnICYmXG4gICAgICAgICAgICAgICAgc2VtdmVyLmx0KHByb2Nlc3MudmVyc2lvbiwgJzkuMC4wJykgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zUGFyc2VkLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbb3B0aW9uc1BhcnNlZCwgLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gaW5zdHJ1bWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5nZXRDb25maWcoKSkuaWdub3JlT3V0Z29pbmdSZXF1ZXN0SG9vaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG9wdGlvbnNQYXJzZWQpO1xuICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RydW1lbnRhdGlvbi5fZGlhZy5lcnJvcignY2F1Z2h0IGlnbm9yZU91dGdvaW5nUmVxdWVzdEhvb2sgZXJyb3I6ICcsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zUGFyc2VkLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGhvc3RuYW1lLCBwb3J0IH0gPSAoMCwgdXRpbHNfMS5leHRyYWN0SG9zdG5hbWVBbmRQb3J0KShvcHRpb25zUGFyc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSAoMCwgdXRpbHNfMS5nZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzKShvcHRpb25zUGFyc2VkLCB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgaG9va0F0dHJpYnV0ZXM6IGluc3RydW1lbnRhdGlvbi5fY2FsbFN0YXJ0U3Bhbkhvb2sob3B0aW9uc1BhcnNlZCwgaW5zdHJ1bWVudGF0aW9uLmdldENvbmZpZygpLnN0YXJ0T3V0Z29pbmdTcGFuSG9vayksXG4gICAgICAgICAgICB9LCBpbnN0cnVtZW50YXRpb24uX3NlbWNvbnZTdGFiaWxpdHkpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gKDAsIGNvcmVfMS5oclRpbWUpKCk7XG4gICAgICAgICAgICBjb25zdCBvbGRNZXRyaWNBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcykoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAvLyByZXF1ZXN0IG1ldGhvZCwgc2VydmVyIGFkZHJlc3MsIGFuZCBzZXJ2ZXIgcG9ydCBhcmUgYm90aCByZXF1aXJlZCBzcGFuIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNvbnN0IHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTogYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF0sXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9BRERSRVNTXSxcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXTogYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfU0VSVkVSX1BPUlRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIGlmIGFuZCBvbmx5IGlmIG9uZSB3YXMgc2VudCwgc2FtZSBhcyBzcGFuIHJlcXVpcmVtZW50XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV0pIHtcbiAgICAgICAgICAgICAgICBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXSA9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVjb21tZW5kZWQgaWYgYW5kIG9ubHkgaWYgb25lIHdhcyBzZW50LCBzYW1lIGFzIHNwYW4gcmVjb21tZW5kYXRpb25cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dKSB7XG4gICAgICAgICAgICAgICAgc3RhYmxlTWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QUk9UT0NPTF9WRVJTSU9OXSA9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5DTElFTlQsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gaW5zdHJ1bWVudGF0aW9uLl9zdGFydEh0dHBTcGFuKG1ldGhvZCwgc3Bhbk9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Q29udGV4dCA9IGFwaV8xLmNvbnRleHQuYWN0aXZlKCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29udGV4dCA9IGFwaV8xLnRyYWNlLnNldFNwYW4ocGFyZW50Q29udGV4dCwgc3Bhbik7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnNQYXJzZWQuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNQYXJzZWQuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGhlYWRlcnMgb2JqZWN0IHRvIGF2b2lkIG11dGF0aW5nIGFuIG9iamVjdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjYWxsZXIgbWlnaHQgaGF2ZSBhIHJlZmVyZW5jZSB0by5cbiAgICAgICAgICAgICAgICBvcHRpb25zUGFyc2VkLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zUGFyc2VkLmhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KHJlcXVlc3RDb250ZXh0LCBvcHRpb25zUGFyc2VkLmhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChyZXF1ZXN0Q29udGV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogVGhlIHJlc3BvbnNlIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQgYmVmb3JlIENsaWVudFJlcXVlc3QgaXMgYm91bmQsXG4gICAgICAgICAgICAgICAgICogdGh1cyBpdCBpcyBuZWVkZWQgdG8gYmluZCBpdCBiZWZvcmUgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBhcGlfMS5jb250ZXh0LmJpbmQocGFyZW50Q29udGV4dCwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludmFsaWRVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgdXJsIGlzIGludmFsaWQsIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gaW5qZWN0aW5nIGNvbnRleHQgYXMgaXQgd2lsbCBmYWlsIHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzaW5nIGluIHdoYXQgdGhlIHVzZXIgcHJvdmlkZWQgd2lsbCBnaXZlIHRoZSB1c2VyIGFuIGVycm9yIHRoYXQgbWF0Y2hlcyB3aGF0IHRoZXknZCBzZWUgd2l0aG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGluc3RydW1lbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbb3B0aW9ucywgLi4uYXJnc10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtvcHRpb25zUGFyc2VkLCAuLi5hcmdzXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuc2V0U3BhbldpdGhFcnJvcikoc3BhbiwgZXJyb3IsIGluc3RydW1lbnRhdGlvbi5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2Nsb3NlSHR0cFNwYW4oc3BhbiwgYXBpXzEuU3BhbktpbmQuQ0xJRU5ULCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50YXRpb24uX2RpYWcuZGVidWcoYCR7Y29tcG9uZW50fSBpbnN0cnVtZW50YXRpb24gb3V0Z29pbmdSZXF1ZXN0YCk7XG4gICAgICAgICAgICAgICAgYXBpXzEuY29udGV4dC5iaW5kKHBhcmVudENvbnRleHQsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50YXRpb24uX3RyYWNlQ2xpZW50UmVxdWVzdChyZXF1ZXN0LCBzcGFuLCBzdGFydFRpbWUsIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9vblNlcnZlclJlc3BvbnNlRmluaXNoKHJlcXVlc3QsIHJlc3BvbnNlLCBzcGFuLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzLCBzdGFydFRpbWUpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9ICgwLCB1dGlsc18xLmdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXNPblJlc3BvbnNlKShyZXF1ZXN0LCByZXNwb25zZSwgdGhpcy5fc2VtY29udlN0YWJpbGl0eSk7XG4gICAgICAgIG9sZE1ldHJpY0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKG9sZE1ldHJpY0F0dHJpYnV0ZXMsICgwLCB1dGlsc18xLmdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlKShhdHRyaWJ1dGVzKSk7XG4gICAgICAgIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMsICgwLCB1dGlsc18xLmdldEluY29taW5nU3RhYmxlUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlKShhdHRyaWJ1dGVzKSk7XG4gICAgICAgIHRoaXMuX2hlYWRlckNhcHR1cmUuc2VydmVyLmNhcHR1cmVSZXNwb25zZUhlYWRlcnMoc3BhbiwgaGVhZGVyID0+IHJlc3BvbnNlLmdldEhlYWRlcihoZWFkZXIpKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLnNldFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiAoMCwgdXRpbHNfMS5wYXJzZVJlc3BvbnNlU3RhdHVzKShhcGlfMS5TcGFuS2luZC5TRVJWRVIsIHJlc3BvbnNlLnN0YXR1c0NvZGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9ST1VURV07XG4gICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgc3Bhbi51cGRhdGVOYW1lKGAke3JlcXVlc3QubWV0aG9kIHx8ICdHRVQnfSAke3JvdXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldENvbmZpZygpLmFwcGx5Q3VzdG9tQXR0cmlidXRlc09uU3Bhbikge1xuICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHRoaXMuZ2V0Q29uZmlnKCkuYXBwbHlDdXN0b21BdHRyaWJ1dGVzT25TcGFuKHNwYW4sIHJlcXVlc3QsIHJlc3BvbnNlKSwgKCkgPT4geyB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLlNFUlZFUiwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgX29uU2VydmVyUmVzcG9uc2VFcnJvcihzcGFuLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzLCBzdGFydFRpbWUsIGVycm9yKSB7XG4gICAgICAgICgwLCB1dGlsc18xLnNldFNwYW5XaXRoRXJyb3IpKHNwYW4sIGVycm9yLCB0aGlzLl9zZW1jb252U3RhYmlsaXR5KTtcbiAgICAgICAgLy8gVE9ETyBnZXQgZXJyb3IgYXR0cmlidXRlcyBmb3IgbWV0cmljc1xuICAgICAgICB0aGlzLl9jbG9zZUh0dHBTcGFuKHNwYW4sIGFwaV8xLlNwYW5LaW5kLlNFUlZFUiwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgX3N0YXJ0SHR0cFNwYW4obmFtZSwgb3B0aW9ucywgY3R4ID0gYXBpXzEuY29udGV4dC5hY3RpdmUoKSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJZiBhIHBhcmVudCBpcyByZXF1aXJlZCBidXQgbm90IHByZXNlbnQsIHdlIHVzZSBhIGBOb29wU3BhbmAgdG8gc3RpbGxcbiAgICAgICAgICogcHJvcGFnYXRlIGNvbnRleHQgd2l0aG91dCByZWNvcmRpbmcgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXF1aXJlUGFyZW50ID0gb3B0aW9ucy5raW5kID09PSBhcGlfMS5TcGFuS2luZC5DTElFTlRcbiAgICAgICAgICAgID8gdGhpcy5nZXRDb25maWcoKS5yZXF1aXJlUGFyZW50Zm9yT3V0Z29pbmdTcGFuc1xuICAgICAgICAgICAgOiB0aGlzLmdldENvbmZpZygpLnJlcXVpcmVQYXJlbnRmb3JJbmNvbWluZ1NwYW5zO1xuICAgICAgICBsZXQgc3BhbjtcbiAgICAgICAgY29uc3QgY3VycmVudFNwYW4gPSBhcGlfMS50cmFjZS5nZXRTcGFuKGN0eCk7XG4gICAgICAgIGlmIChyZXF1aXJlUGFyZW50ID09PSB0cnVlICYmIGN1cnJlbnRTcGFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4gPSBhcGlfMS50cmFjZS53cmFwU3BhbkNvbnRleHQoYXBpXzEuSU5WQUxJRF9TUEFOX0NPTlRFWFQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVpcmVQYXJlbnQgPT09IHRydWUgJiYgKGN1cnJlbnRTcGFuID09PSBudWxsIHx8IGN1cnJlbnRTcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U3Bhbi5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSkge1xuICAgICAgICAgICAgc3BhbiA9IGN1cnJlbnRTcGFuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMudHJhY2VyLnN0YXJ0U3BhbihuYW1lLCBvcHRpb25zLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NwYW5Ob3RFbmRlZC5hZGQoc3Bhbik7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBfY2xvc2VIdHRwU3BhbihzcGFuLCBzcGFuS2luZCwgc3RhcnRUaW1lLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3Bhbk5vdEVuZGVkLmhhcyhzcGFuKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIHRoaXMuX3NwYW5Ob3RFbmRlZC5kZWxldGUoc3Bhbik7XG4gICAgICAgIC8vIFJlY29yZCBtZXRyaWNzXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gKDAsIGNvcmVfMS5oclRpbWVUb01pbGxpc2Vjb25kcykoKDAsIGNvcmVfMS5oclRpbWVEdXJhdGlvbikoc3RhcnRUaW1lLCAoMCwgY29yZV8xLmhyVGltZSkoKSkpO1xuICAgICAgICBpZiAoc3BhbktpbmQgPT09IGFwaV8xLlNwYW5LaW5kLlNFUlZFUikge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkU2VydmVyRHVyYXRpb24oZHVyYXRpb24sIG9sZE1ldHJpY0F0dHJpYnV0ZXMsIHN0YWJsZU1ldHJpY0F0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwYW5LaW5kID09PSBhcGlfMS5TcGFuS2luZC5DTElFTlQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZENsaWVudER1cmF0aW9uKGR1cmF0aW9uLCBvbGRNZXRyaWNBdHRyaWJ1dGVzLCBzdGFibGVNZXRyaWNBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2FsbFJlc3BvbnNlSG9vayhzcGFuLCByZXNwb25zZSkge1xuICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gdGhpcy5nZXRDb25maWcoKS5yZXNwb25zZUhvb2soc3BhbiwgcmVzcG9uc2UpLCAoKSA9PiB7IH0sIHRydWUpO1xuICAgIH1cbiAgICBfY2FsbFJlcXVlc3RIb29rKHNwYW4sIHJlcXVlc3QpIHtcbiAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHRoaXMuZ2V0Q29uZmlnKCkucmVxdWVzdEhvb2soc3BhbiwgcmVxdWVzdCksICgpID0+IHsgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIF9jYWxsU3RhcnRTcGFuSG9vayhyZXF1ZXN0LCBob29rRnVuYykge1xuICAgICAgICBpZiAodHlwZW9mIGhvb2tGdW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGhvb2tGdW5jKHJlcXVlc3QpLCAoKSA9PiB7IH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jcmVhdGVIZWFkZXJDYXB0dXJlKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudDoge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVSZXF1ZXN0SGVhZGVyczogKDAsIHV0aWxzXzEuaGVhZGVyQ2FwdHVyZSkoJ3JlcXVlc3QnLCAoX2MgPSAoX2IgPSAoX2EgPSBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGllbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXF1ZXN0SGVhZGVycykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pLFxuICAgICAgICAgICAgICAgIGNhcHR1cmVSZXNwb25zZUhlYWRlcnM6ICgwLCB1dGlsc18xLmhlYWRlckNhcHR1cmUpKCdyZXNwb25zZScsIChfZiA9IChfZSA9IChfZCA9IGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNsaWVudCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlc3BvbnNlSGVhZGVycykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogW10pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcnZlcjoge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVSZXF1ZXN0SGVhZGVyczogKDAsIHV0aWxzXzEuaGVhZGVyQ2FwdHVyZSkoJ3JlcXVlc3QnLCAoX2ogPSAoX2ggPSAoX2cgPSBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5zZXJ2ZXIpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SGVhZGVycykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogW10pLFxuICAgICAgICAgICAgICAgIGNhcHR1cmVSZXNwb25zZUhlYWRlcnM6ICgwLCB1dGlsc18xLmhlYWRlckNhcHR1cmUpKCdyZXNwb25zZScsIChfbSA9IChfbCA9IChfayA9IGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLnNlcnZlcikgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnJlc3BvbnNlSGVhZGVycykgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogW10pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHBJbnN0cnVtZW50YXRpb24gPSBIdHRwSW5zdHJ1bWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js":</span>
<span class="cstat-no" title="statement not covered" >/*!********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpInstrumentation = void 0;\nvar http_1 = __webpack_require__(/*! ./http */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/http.js\");\nObject.defineProperty(exports, \"HttpInstrumentation\", ({ enumerable: true, get: function () { return http_1.HttpInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixhQUFhLG1CQUFPLENBQUMsaUxBQVE7QUFDN0IsdURBQXNELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ3BJIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHBJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG52YXIgaHR0cF8xID0gcmVxdWlyZShcIi4vaHR0cFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBJbnN0cnVtZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBfMS5IdHRwSW5zdHJ1bWVudGF0aW9uOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/index.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js":</span>
<span class="cstat-no" title="statement not covered" >/*!********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.headerCapture = exports.getIncomingStableRequestMetricAttributesOnResponse = exports.getIncomingRequestMetricAttributesOnResponse = exports.getIncomingRequestAttributesOnResponse = exports.getIncomingRequestMetricAttributes = exports.getIncomingRequestAttributes = exports.getRemoteClientAddress = exports.getOutgoingRequestMetricAttributesOnResponse = exports.getOutgoingRequestAttributesOnResponse = exports.setAttributesFromHttpKind = exports.getOutgoingRequestMetricAttributes = exports.getOutgoingRequestAttributes = exports.extractHostnameAndPort = exports.isValidOptionsType = exports.getRequestInfo = exports.isCompressed = exports.setResponseContentLengthAttribute = exports.setRequestContentLengthAttribute = exports.setSpanWithError = exports.satisfiesPattern = exports.parseResponseStatus = exports.getAbsoluteUrl = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst AttributeNames_1 = __webpack_require__(/*! ./enums/AttributeNames */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/enums/AttributeNames.js\");\nconst forwardedParse = __webpack_require__(/*! forwarded-parse */ \"(ssr)/./node_modules/.pnpm/forwarded-parse@2.1.2/node_modules/forwarded-parse/index.js\");\n/**\n * Get an absolute url\n */\nconst getAbsoluteUrl = (requestUrl, headers, fallbackProtocol = 'http:') =&gt; {\n    const reqUrlObject = requestUrl || {};\n    const protocol = reqUrlObject.protocol || fallbackProtocol;\n    const port = (reqUrlObject.port || '').toString();\n    const path = reqUrlObject.path || '/';\n    let host = reqUrlObject.host || reqUrlObject.hostname || headers.host || 'localhost';\n    // if there is no port in host and there is a port\n    // it should be displayed if it's not 80 and 443 (default ports)\n    if (host.indexOf(':') === -1 &amp;&amp;\n        port &amp;&amp;\n        port !== '80' &amp;&amp;\n        port !== '443') {\n        host += `:${port}`;\n    }\n    return `${protocol}//${host}${path}`;\n};\nexports.getAbsoluteUrl = getAbsoluteUrl;\n/**\n * Parse status code from HTTP response. [More details](https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-http.md#status)\n */\nconst parseResponseStatus = (kind, statusCode) =&gt; {\n    const upperBound = kind === api_1.SpanKind.CLIENT ? 400 : 500;\n    // 1xx, 2xx, 3xx are OK on client and server\n    // 4xx is OK on server\n    if (statusCode &amp;&amp; statusCode &gt;= 100 &amp;&amp; statusCode &lt; upperBound) {\n        return api_1.SpanStatusCode.UNSET;\n    }\n    // All other codes are error\n    return api_1.SpanStatusCode.ERROR;\n};\nexports.parseResponseStatus = parseResponseStatus;\n/**\n * Check whether the given obj match pattern\n * @param constant e.g URL of request\n * @param pattern Match pattern\n */\nconst satisfiesPattern = (constant, pattern) =&gt; {\n    if (typeof pattern === 'string') {\n        return pattern === constant;\n    }\n    else if (pattern instanceof RegExp) {\n        return pattern.test(constant);\n    }\n    else if (typeof pattern === 'function') {\n        return pattern(constant);\n    }\n    else {\n        throw new TypeError('Pattern is in unsupported datatype');\n    }\n};\nexports.satisfiesPattern = satisfiesPattern;\n/**\n * Sets the span with the error passed in params\n * @param {Span} span the span that need to be set\n * @param {Error} error error that will be set to span\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst setSpanWithError = (span, error, semconvStability) =&gt; {\n    const message = error.message;\n    if ((semconvStability &amp; 2 /* OLD */) === 2 /* OLD */) {\n        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_NAME, error.name);\n        span.setAttribute(AttributeNames_1.AttributeNames.HTTP_ERROR_MESSAGE, message);\n    }\n    if ((semconvStability &amp; 1 /* STABLE */) ===\n        1 /* STABLE */) {\n        span.setAttribute(semantic_conventions_1.ATTR_ERROR_TYPE, error.name);\n    }\n    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message });\n    span.recordException(error);\n};\nexports.setSpanWithError = setSpanWithError;\n/**\n * Adds attributes for request content-length and content-encoding HTTP headers\n * @param { IncomingMessage } Request object whose headers will be analyzed\n * @param { Attributes } Attributes object to be modified\n */\nconst setRequestContentLengthAttribute = (request, attributes) =&gt; {\n    const length = getContentLength(request.headers);\n    if (length === null)\n        return;\n    if ((0, exports.isCompressed)(request.headers)) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH] = length;\n    }\n    else {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = length;\n    }\n};\nexports.setRequestContentLengthAttribute = setRequestContentLengthAttribute;\n/**\n * Adds attributes for response content-length and content-encoding HTTP headers\n * @param { IncomingMessage } Response object whose headers will be analyzed\n * @param { Attributes } Attributes object to be modified\n *\n * @deprecated this is for an older version of semconv. It is retained for compatibility using OTEL_SEMCONV_STABILITY_OPT_IN\n */\nconst setResponseContentLengthAttribute = (response, attributes) =&gt; {\n    const length = getContentLength(response.headers);\n    if (length === null)\n        return;\n    if ((0, exports.isCompressed)(response.headers)) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH] = length;\n    }\n    else {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = length;\n    }\n};\nexports.setResponseContentLengthAttribute = setResponseContentLengthAttribute;\nfunction getContentLength(headers) {\n    const contentLengthHeader = headers['content-length'];\n    if (contentLengthHeader === undefined)\n        return null;\n    const contentLength = parseInt(contentLengthHeader, 10);\n    if (isNaN(contentLength))\n        return null;\n    return contentLength;\n}\nconst isCompressed = (headers) =&gt; {\n    const encoding = headers['content-encoding'];\n    return !!encoding &amp;&amp; encoding !== 'identity';\n};\nexports.isCompressed = isCompressed;\n/**\n * Mimics Node.js conversion of URL strings to RequestOptions expected by\n * `http.request` and `https.request` APIs.\n *\n * See https://github.com/nodejs/node/blob/2505e217bba05fc581b572c685c5cf280a16c5a3/lib/internal/url.js#L1415-L1437\n *\n * @param stringUrl\n * @throws TypeError if the URL is not valid.\n */\nfunction stringUrlToHttpOptions(stringUrl) {\n    // This is heavily inspired by Node.js handling of the same situation, trying\n    // to follow it as closely as possible while keeping in mind that we only\n    // deal with string URLs, not URL objects.\n    const { hostname, pathname, port, username, password, search, protocol, hash, href, origin, host, } = new URL(stringUrl);\n    const options = {\n        protocol: protocol,\n        hostname: hostname &amp;&amp; hostname[0] === '[' ? hostname.slice(1, -1) : hostname,\n        hash: hash,\n        search: search,\n        pathname: pathname,\n        path: `${pathname || ''}${search || ''}`,\n        href: href,\n        origin: origin,\n        host: host,\n    };\n    if (port !== '') {\n        options.port = Number(port);\n    }\n    if (username || password) {\n        options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;\n    }\n    return options;\n}\n/**\n * Makes sure options is an url object\n * return an object with default value and parsed options\n * @param logger component logger\n * @param options original options for the request\n * @param [extraOptions] additional options for the request\n */\nconst getRequestInfo = (logger, options, extraOptions) =&gt; {\n    let pathname;\n    let origin;\n    let optionsParsed;\n    let invalidUrl = false;\n    if (typeof options === 'string') {\n        try {\n            const convertedOptions = stringUrlToHttpOptions(options);\n            optionsParsed = convertedOptions;\n            pathname = convertedOptions.pathname || '/';\n        }\n        catch (e) {\n            invalidUrl = true;\n            logger.verbose('Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:', e);\n            // for backward compatibility with how url.parse() behaved.\n            optionsParsed = {\n                path: options,\n            };\n            pathname = optionsParsed.path || '/';\n        }\n        origin = `${optionsParsed.protocol || 'http:'}//${optionsParsed.host}`;\n        if (extraOptions !== undefined) {\n            Object.assign(optionsParsed, extraOptions);\n        }\n    }\n    else if (options instanceof url.URL) {\n        optionsParsed = {\n            protocol: options.protocol,\n            hostname: typeof options.hostname === 'string' &amp;&amp; options.hostname.startsWith('[')\n                ? options.hostname.slice(1, -1)\n                : options.hostname,\n            path: `${options.pathname || ''}${options.search || ''}`,\n        };\n        if (options.port !== '') {\n            optionsParsed.port = Number(options.port);\n        }\n        if (options.username || options.password) {\n            optionsParsed.auth = `${options.username}:${options.password}`;\n        }\n        pathname = options.pathname;\n        origin = options.origin;\n        if (extraOptions !== undefined) {\n            Object.assign(optionsParsed, extraOptions);\n        }\n    }\n    else {\n        optionsParsed = Object.assign({ protocol: options.host ? 'http:' : undefined }, options);\n        const hostname = optionsParsed.host ||\n            (optionsParsed.port != null\n                ? `${optionsParsed.hostname}${optionsParsed.port}`\n                : optionsParsed.hostname);\n        origin = `${optionsParsed.protocol || 'http:'}//${hostname}`;\n        pathname = options.pathname;\n        if (!pathname &amp;&amp; optionsParsed.path) {\n            try {\n                const parsedUrl = new URL(optionsParsed.path, origin);\n                pathname = parsedUrl.pathname || '/';\n            }\n            catch (e) {\n                pathname = '/';\n            }\n        }\n    }\n    // some packages return method in lowercase..\n    // ensure upperCase for consistency\n    const method = optionsParsed.method\n        ? optionsParsed.method.toUpperCase()\n        : 'GET';\n    return { origin, pathname, method, optionsParsed, invalidUrl };\n};\nexports.getRequestInfo = getRequestInfo;\n/**\n * Makes sure options is of type string or object\n * @param options for the request\n */\nconst isValidOptionsType = (options) =&gt; {\n    if (!options) {\n        return false;\n    }\n    const type = typeof options;\n    return type === 'string' || (type === 'object' &amp;&amp; !Array.isArray(options));\n};\nexports.isValidOptionsType = isValidOptionsType;\nconst extractHostnameAndPort = (requestOptions) =&gt; {\n    var _a;\n    if (requestOptions.hostname &amp;&amp; requestOptions.port) {\n        return { hostname: requestOptions.hostname, port: requestOptions.port };\n    }\n    const matches = ((_a = requestOptions.host) === null || _a === void 0 ? void 0 : _a.match(/^([^:/ ]+)(:\\d{1,5})?/)) || null;\n    const hostname = requestOptions.hostname || (matches === null ? 'localhost' : matches[1]);\n    let port = requestOptions.port;\n    if (!port) {\n        if (matches &amp;&amp; matches[2]) {\n            // remove the leading \":\". The extracted port would be something like \":8080\"\n            port = matches[2].substring(1);\n        }\n        else {\n            port = requestOptions.protocol === 'https:' ? '443' : '80';\n        }\n    }\n    return { hostname, port };\n};\nexports.extractHostnameAndPort = extractHostnameAndPort;\n/**\n * Returns outgoing request attributes scoped to the options passed to the request\n * @param {ParsedRequestOptions} requestOptions the same options used to make the request\n * @param {{ component: string, hostname: string, hookAttributes?: Attributes }} options used to pass data needed to create attributes\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getOutgoingRequestAttributes = (requestOptions, options, semconvStability) =&gt; {\n    var _a, _b;\n    const hostname = options.hostname;\n    const port = options.port;\n    const method = (_a = requestOptions.method) !== null &amp;&amp; _a !== void 0 ? _a : 'GET';\n    const normalizedMethod = normalizeMethod(method);\n    const headers = requestOptions.headers || {};\n    const userAgent = headers['user-agent'];\n    const urlFull = (0, exports.getAbsoluteUrl)(requestOptions, headers, `${options.component}:`);\n    const oldAttributes = {\n        [semantic_conventions_1.SEMATTRS_HTTP_URL]: urlFull,\n        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,\n        [semantic_conventions_1.SEMATTRS_HTTP_TARGET]: requestOptions.path || '/',\n        [semantic_conventions_1.SEMATTRS_NET_PEER_NAME]: hostname,\n        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: (_b = headers.host) !== null &amp;&amp; _b !== void 0 ? _b : `${hostname}:${port}`,\n    };\n    const newAttributes = {\n        // Required attributes\n        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,\n        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: hostname,\n        [semantic_conventions_1.ATTR_SERVER_PORT]: Number(port),\n        [semantic_conventions_1.ATTR_URL_FULL]: urlFull,\n        // leaving out protocol version, it is not yet negotiated\n        // leaving out protocol name, it is only required when protocol version is set\n        // retries and redirects not supported\n        // Opt-in attributes left off for now\n    };\n    // conditionally required if request method required case normalization\n    if (method !== normalizedMethod) {\n        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;\n    }\n    if (userAgent !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;\n    }\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return Object.assign(newAttributes, options.hookAttributes);\n        case 2 /* OLD */:\n            return Object.assign(oldAttributes, options.hookAttributes);\n    }\n    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);\n};\nexports.getOutgoingRequestAttributes = getOutgoingRequestAttributes;\n/**\n * Returns outgoing request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getOutgoingRequestMetricAttributes = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_NAME];\n    //TODO: http.url attribute, it should substitute any parameters to avoid high cardinality.\n    return metricAttributes;\n};\nexports.getOutgoingRequestMetricAttributes = getOutgoingRequestMetricAttributes;\n/**\n * Returns attributes related to the kind of HTTP protocol used\n * @param {string} [kind] Kind of HTTP protocol used: \"1.0\", \"1.1\", \"2\", \"SPDY\" or \"QUIC\".\n */\nconst setAttributesFromHttpKind = (kind, attributes) =&gt; {\n    if (kind) {\n        attributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = kind;\n        if (kind.toUpperCase() !== 'QUIC') {\n            attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_TCP;\n        }\n        else {\n            attributes[semantic_conventions_1.SEMATTRS_NET_TRANSPORT] = semantic_conventions_1.NETTRANSPORTVALUES_IP_UDP;\n        }\n    }\n};\nexports.setAttributesFromHttpKind = setAttributesFromHttpKind;\n/**\n * Returns outgoing request attributes scoped to the response data\n * @param {IncomingMessage} response the response object\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getOutgoingRequestAttributesOnResponse = (response, semconvStability) =&gt; {\n    const { statusCode, statusMessage, httpVersion, socket } = response;\n    const oldAttributes = {};\n    const stableAttributes = {};\n    if (statusCode != null) {\n        stableAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] = statusCode;\n    }\n    if (socket) {\n        const { remoteAddress, remotePort } = socket;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;\n        // Recommended\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS] = remoteAddress;\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PEER_PORT] = remotePort;\n        stableAttributes[semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION] = response.httpVersion;\n    }\n    (0, exports.setResponseContentLengthAttribute)(response, oldAttributes);\n    if (statusCode) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n        oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || '').toUpperCase();\n    }\n    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return stableAttributes;\n        case 2 /* OLD */:\n            return oldAttributes;\n    }\n    return Object.assign(oldAttributes, stableAttributes);\n};\nexports.getOutgoingRequestAttributesOnResponse = getOutgoingRequestAttributesOnResponse;\n/**\n * Returns outgoing request Metric attributes scoped to the response data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getOutgoingRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];\n    return metricAttributes;\n};\nexports.getOutgoingRequestMetricAttributesOnResponse = getOutgoingRequestMetricAttributesOnResponse;\nfunction parseHostHeader(hostHeader, proto) {\n    const parts = hostHeader.split(':');\n    // no semicolon implies ipv4 dotted syntax or host name without port\n    // x.x.x.x\n    // example.com\n    if (parts.length === 1) {\n        if (proto === 'http') {\n            return { host: parts[0], port: '80' };\n        }\n        if (proto === 'https') {\n            return { host: parts[0], port: '443' };\n        }\n        return { host: parts[0] };\n    }\n    // single semicolon implies ipv4 dotted syntax or host name with port\n    // x.x.x.x:yyyy\n    // example.com:yyyy\n    if (parts.length === 2) {\n        return {\n            host: parts[0],\n            port: parts[1],\n        };\n    }\n    // more than 2 parts implies ipv6 syntax with multiple colons\n    // [x:x:x:x:x:x:x:x]\n    // [x:x:x:x:x:x:x:x]:yyyy\n    if (parts[0].startsWith('[')) {\n        if (parts[parts.length - 1].endsWith(']')) {\n            if (proto === 'http') {\n                return { host: hostHeader, port: '80' };\n            }\n            if (proto === 'https') {\n                return { host: hostHeader, port: '443' };\n            }\n        }\n        else if (parts[parts.length - 2].endsWith(']')) {\n            return {\n                host: parts.slice(0, -1).join(':'),\n                port: parts[parts.length - 1],\n            };\n        }\n    }\n    // if nothing above matches just return the host header\n    return { host: hostHeader };\n}\n/**\n * Get server.address and port according to http semconv 1.27\n * https://github.com/open-telemetry/semantic-conventions/blob/bf0a2c1134f206f034408b201dbec37960ed60ec/docs/http/http-spans.md#setting-serveraddress-and-serverport-attributes\n */\nfunction getServerAddress(request, component) {\n    const forwardedHeader = request.headers['forwarded'];\n    if (forwardedHeader) {\n        for (const entry of parseForwardedHeader(forwardedHeader)) {\n            if (entry.host) {\n                return parseHostHeader(entry.host, entry.proto);\n            }\n        }\n    }\n    const xForwardedHost = request.headers['x-forwarded-host'];\n    if (typeof xForwardedHost === 'string') {\n        if (typeof request.headers['x-forwarded-proto'] === 'string') {\n            return parseHostHeader(xForwardedHost, request.headers['x-forwarded-proto']);\n        }\n        if (Array.isArray(request.headers['x-forwarded-proto'])) {\n            return parseHostHeader(xForwardedHost, request.headers['x-forwarded-proto'][0]);\n        }\n        return parseHostHeader(xForwardedHost);\n    }\n    else if (Array.isArray(xForwardedHost) &amp;&amp;\n        typeof xForwardedHost[0] === 'string' &amp;&amp;\n        xForwardedHost[0].length &gt; 0) {\n        if (typeof request.headers['x-forwarded-proto'] === 'string') {\n            return parseHostHeader(xForwardedHost[0], request.headers['x-forwarded-proto']);\n        }\n        if (Array.isArray(request.headers['x-forwarded-proto'])) {\n            return parseHostHeader(xForwardedHost[0], request.headers['x-forwarded-proto'][0]);\n        }\n        return parseHostHeader(xForwardedHost[0]);\n    }\n    const host = request.headers['host'];\n    if (typeof host === 'string' &amp;&amp; host.length &gt; 0) {\n        return parseHostHeader(host, component);\n    }\n    return null;\n}\n/**\n * Get server.address and port according to http semconv 1.27\n * https://github.com/open-telemetry/semantic-conventions/blob/bf0a2c1134f206f034408b201dbec37960ed60ec/docs/http/http-spans.md#setting-serveraddress-and-serverport-attributes\n */\nfunction getRemoteClientAddress(request) {\n    const forwardedHeader = request.headers['forwarded'];\n    if (forwardedHeader) {\n        for (const entry of parseForwardedHeader(forwardedHeader)) {\n            if (entry.for) {\n                return entry.for;\n            }\n        }\n    }\n    const xForwardedFor = request.headers['x-forwarded-for'];\n    if (typeof xForwardedFor === 'string') {\n        return xForwardedFor;\n    }\n    else if (Array.isArray(xForwardedFor)) {\n        return xForwardedFor[0];\n    }\n    const remote = request.socket.remoteAddress;\n    if (remote) {\n        return remote;\n    }\n    return null;\n}\nexports.getRemoteClientAddress = getRemoteClientAddress;\nfunction getInfoFromIncomingMessage(component, request, logger) {\n    var _a, _b;\n    try {\n        if (request.headers.host) {\n            return new URL((_a = request.url) !== null &amp;&amp; _a !== void 0 ? _a : '/', `${component}://${request.headers.host}`);\n        }\n        else {\n            const unsafeParsedUrl = new URL((_b = request.url) !== null &amp;&amp; _b !== void 0 ? _b : '/', \n            // using localhost as a workaround to still use the URL constructor for parsing\n            `${component}://localhost`);\n            // since we use localhost as a workaround, ensure we hide the rest of the properties to avoid\n            // our workaround leaking though.\n            return {\n                pathname: unsafeParsedUrl.pathname,\n                search: unsafeParsedUrl.search,\n                toString: function () {\n                    // we cannot use the result of unsafeParsedUrl.toString as it's potentially wrong.\n                    return unsafeParsedUrl.pathname + unsafeParsedUrl.search;\n                },\n            };\n        }\n    }\n    catch (e) {\n        // something is wrong, use undefined - this *should* never happen, logging\n        // for troubleshooting in case it does happen.\n        logger.verbose('Unable to get URL from request', e);\n        return {};\n    }\n}\n/**\n * Returns incoming request attributes scoped to the request data\n * @param {IncomingMessage} request the request object\n * @param {{ component: string, serverName?: string, hookAttributes?: Attributes }} options used to pass data needed to create attributes\n * @param {SemconvStability} semconvStability determines which semconv version to use\n */\nconst getIncomingRequestAttributes = (request, options, logger) =&gt; {\n    const headers = request.headers;\n    const userAgent = headers['user-agent'];\n    const ips = headers['x-forwarded-for'];\n    const httpVersion = request.httpVersion;\n    const host = headers.host;\n    const hostname = (host === null || host === void 0 ? void 0 : host.replace(/^(.*)(:[0-9]{1,5})/, '$1')) || 'localhost';\n    const method = request.method;\n    const normalizedMethod = normalizeMethod(method);\n    const serverAddress = getServerAddress(request, options.component);\n    const serverName = options.serverName;\n    const remoteClientAddress = getRemoteClientAddress(request);\n    const newAttributes = {\n        [semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD]: normalizedMethod,\n        [semantic_conventions_1.ATTR_URL_SCHEME]: options.component,\n        [semantic_conventions_1.ATTR_SERVER_ADDRESS]: serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.host,\n        [semantic_conventions_1.ATTR_NETWORK_PEER_ADDRESS]: request.socket.remoteAddress,\n        [semantic_conventions_1.ATTR_NETWORK_PEER_PORT]: request.socket.remotePort,\n        [semantic_conventions_1.ATTR_NETWORK_PROTOCOL_VERSION]: request.httpVersion,\n        [semantic_conventions_1.ATTR_USER_AGENT_ORIGINAL]: userAgent,\n    };\n    const parsedUrl = getInfoFromIncomingMessage(options.component, request, logger);\n    if ((parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) != null) {\n        newAttributes[semantic_conventions_1.ATTR_URL_PATH] = parsedUrl.pathname;\n    }\n    if (remoteClientAddress != null) {\n        newAttributes[semantic_conventions_1.ATTR_CLIENT_ADDRESS] = remoteClientAddress;\n    }\n    if ((serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.port) != null) {\n        newAttributes[semantic_conventions_1.ATTR_SERVER_PORT] = Number(serverAddress.port);\n    }\n    // conditionally required if request method required case normalization\n    if (method !== normalizedMethod) {\n        newAttributes[semantic_conventions_1.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = method;\n    }\n    const oldAttributes = {\n        [semantic_conventions_1.SEMATTRS_HTTP_URL]: parsedUrl.toString(),\n        [semantic_conventions_1.SEMATTRS_HTTP_HOST]: host,\n        [semantic_conventions_1.SEMATTRS_NET_HOST_NAME]: hostname,\n        [semantic_conventions_1.SEMATTRS_HTTP_METHOD]: method,\n        [semantic_conventions_1.SEMATTRS_HTTP_SCHEME]: options.component,\n    };\n    if (typeof ips === 'string') {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_CLIENT_IP] = ips.split(',')[0];\n    }\n    if (typeof serverName === 'string') {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_SERVER_NAME] = serverName;\n    }\n    if (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_TARGET] =\n            (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname) + (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.search) || '/';\n    }\n    if (userAgent !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_USER_AGENT] = userAgent;\n    }\n    (0, exports.setRequestContentLengthAttribute)(request, oldAttributes);\n    (0, exports.setAttributesFromHttpKind)(httpVersion, oldAttributes);\n    switch (options.semconvStability) {\n        case 1 /* STABLE */:\n            return Object.assign(newAttributes, options.hookAttributes);\n        case 2 /* OLD */:\n            return Object.assign(oldAttributes, options.hookAttributes);\n    }\n    return Object.assign(oldAttributes, newAttributes, options.hookAttributes);\n};\nexports.getIncomingRequestAttributes = getIncomingRequestAttributes;\n/**\n * Returns incoming request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n * @param {{ component: string }} options used to pass data needed to create attributes\n */\nconst getIncomingRequestMetricAttributes = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_SCHEME];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_METHOD];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_NAME];\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_FLAVOR];\n    //TODO: http.target attribute, it should substitute any parameters to avoid high cardinality.\n    return metricAttributes;\n};\nexports.getIncomingRequestMetricAttributes = getIncomingRequestMetricAttributes;\n/**\n * Returns incoming request attributes scoped to the response data\n * @param {(ServerResponse &amp; { socket: Socket; })} response the response object\n */\nconst getIncomingRequestAttributesOnResponse = (request, response, semconvStability) =&gt; {\n    // take socket from the request,\n    // since it may be detached from the response object in keep-alive mode\n    const { socket } = request;\n    const { statusCode, statusMessage } = response;\n    const newAttributes = {\n        [semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]: statusCode,\n    };\n    const rpcMetadata = (0, core_1.getRPCMetadata)(api_1.context.active());\n    const oldAttributes = {};\n    if (socket) {\n        const { localAddress, localPort, remoteAddress, remotePort } = socket;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_IP] = localAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] = localPort;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_IP] = remoteAddress;\n        oldAttributes[semantic_conventions_1.SEMATTRS_NET_PEER_PORT] = remotePort;\n    }\n    oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n    oldAttributes[AttributeNames_1.AttributeNames.HTTP_STATUS_TEXT] = (statusMessage || '').toUpperCase();\n    if ((rpcMetadata === null || rpcMetadata === void 0 ? void 0 : rpcMetadata.type) === core_1.RPCType.HTTP &amp;&amp; rpcMetadata.route !== undefined) {\n        oldAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = rpcMetadata.route;\n        newAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = rpcMetadata.route;\n    }\n    switch (semconvStability) {\n        case 1 /* STABLE */:\n            return newAttributes;\n        case 2 /* OLD */:\n            return oldAttributes;\n    }\n    return Object.assign(oldAttributes, newAttributes);\n};\nexports.getIncomingRequestAttributesOnResponse = getIncomingRequestAttributesOnResponse;\n/**\n * Returns incoming request Metric attributes scoped to the request data\n * @param {Attributes} spanAttributes the span attributes\n */\nconst getIncomingRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_STATUS_CODE];\n    metricAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT] =\n        spanAttributes[semantic_conventions_1.SEMATTRS_NET_HOST_PORT];\n    if (spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] !== undefined) {\n        metricAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n    }\n    return metricAttributes;\n};\nexports.getIncomingRequestMetricAttributesOnResponse = getIncomingRequestMetricAttributesOnResponse;\nconst getIncomingStableRequestMetricAttributesOnResponse = (spanAttributes) =&gt; {\n    const metricAttributes = {};\n    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] !== undefined) {\n        metricAttributes[semantic_conventions_1.ATTR_HTTP_ROUTE] = spanAttributes[semantic_conventions_1.SEMATTRS_HTTP_ROUTE];\n    }\n    // required if and only if one was sent, same as span requirement\n    if (spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE]) {\n        metricAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE] =\n            spanAttributes[semantic_conventions_1.ATTR_HTTP_RESPONSE_STATUS_CODE];\n    }\n    return metricAttributes;\n};\nexports.getIncomingStableRequestMetricAttributesOnResponse = getIncomingStableRequestMetricAttributesOnResponse;\nfunction headerCapture(type, headers) {\n    const normalizedHeaders = new Map();\n    for (let i = 0, len = headers.length; i &lt; len; i++) {\n        const capturedHeader = headers[i].toLowerCase();\n        normalizedHeaders.set(capturedHeader, capturedHeader.replace(/-/g, '_'));\n    }\n    return (span, getHeader) =&gt; {\n        for (const capturedHeader of normalizedHeaders.keys()) {\n            const value = getHeader(capturedHeader);\n            if (value === undefined) {\n                continue;\n            }\n            const normalizedHeader = normalizedHeaders.get(capturedHeader);\n            const key = `http.${type}.header.${normalizedHeader}`;\n            if (typeof value === 'string') {\n                span.setAttribute(key, [value]);\n            }\n            else if (Array.isArray(value)) {\n                span.setAttribute(key, value);\n            }\n            else {\n                span.setAttribute(key, [value]);\n            }\n        }\n    };\n}\nexports.headerCapture = headerCapture;\nconst KNOWN_METHODS = new Set([\n    // methods from https://www.rfc-editor.org/rfc/rfc9110.html#name-methods\n    'GET',\n    'HEAD',\n    'POST',\n    'PUT',\n    'DELETE',\n    'CONNECT',\n    'OPTIONS',\n    'TRACE',\n    // PATCH from https://www.rfc-editor.org/rfc/rfc5789.html\n    'PATCH',\n]);\nfunction normalizeMethod(method) {\n    if (method == null) {\n        return 'GET';\n    }\n    const upper = method.toUpperCase();\n    if (KNOWN_METHODS.has(upper)) {\n        return upper;\n    }\n    return '_OTHER';\n}\nfunction parseForwardedHeader(header) {\n    try {\n        return forwardedParse(header);\n    }\n    catch (_a) {\n        return [];\n    }\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLDBEQUEwRCxHQUFHLG9EQUFvRCxHQUFHLDhDQUE4QyxHQUFHLDBDQUEwQyxHQUFHLG9DQUFvQyxHQUFHLDhCQUE4QixHQUFHLG9EQUFvRCxHQUFHLDhDQUE4QyxHQUFHLGlDQUFpQyxHQUFHLDBDQUEwQyxHQUFHLG9DQUFvQyxHQUFHLDhCQUE4QixHQUFHLDBCQUEwQixHQUFHLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLHlDQUF5QyxHQUFHLHdDQUF3QyxHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQjtBQUNqMEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGtJQUFvQjtBQUMxQywrQkFBK0IsbUJBQU8sQ0FBQyxzTEFBcUM7QUFDNUUsZUFBZSxtQkFBTyxDQUFDLCtKQUFxQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIseUJBQXlCLG1CQUFPLENBQUMsaU5BQXdCO0FBQ3pELHVCQUF1QixtQkFBTyxDQUFDLCtHQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLGNBQWMsU0FBUyxJQUFJLEtBQUssRUFBRSxLQUFLO0FBQ3ZDO0FBQ0Esc0JBQXNC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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvb21hci9Eb2N1bWVudHMvcnVsZUlRL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24taHR0cEAwLjU3LjJfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24taHR0cC9idWlsZC9zcmMvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhlYWRlckNhcHR1cmUgPSBleHBvcnRzLmdldEluY29taW5nU3RhYmxlUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSBleHBvcnRzLmdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXMgPSBleHBvcnRzLmdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSBleHBvcnRzLmdldFJlbW90ZUNsaWVudEFkZHJlc3MgPSBleHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGV4cG9ydHMuc2V0QXR0cmlidXRlc0Zyb21IdHRwS2luZCA9IGV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IGV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlcyA9IGV4cG9ydHMuZXh0cmFjdEhvc3RuYW1lQW5kUG9ydCA9IGV4cG9ydHMuaXNWYWxpZE9wdGlvbnNUeXBlID0gZXhwb3J0cy5nZXRSZXF1ZXN0SW5mbyA9IGV4cG9ydHMuaXNDb21wcmVzc2VkID0gZXhwb3J0cy5zZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSBleHBvcnRzLnNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlID0gZXhwb3J0cy5zZXRTcGFuV2l0aEVycm9yID0gZXhwb3J0cy5zYXRpc2ZpZXNQYXR0ZXJuID0gZXhwb3J0cy5wYXJzZVJlc3BvbnNlU3RhdHVzID0gZXhwb3J0cy5nZXRBYnNvbHV0ZVVybCA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2NvcmVcIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgQXR0cmlidXRlTmFtZXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zL0F0dHJpYnV0ZU5hbWVzXCIpO1xuY29uc3QgZm9yd2FyZGVkUGFyc2UgPSByZXF1aXJlKFwiZm9yd2FyZGVkLXBhcnNlXCIpO1xuLyoqXG4gKiBHZXQgYW4gYWJzb2x1dGUgdXJsXG4gKi9cbmNvbnN0IGdldEFic29sdXRlVXJsID0gKHJlcXVlc3RVcmwsIGhlYWRlcnMsIGZhbGxiYWNrUHJvdG9jb2wgPSAnaHR0cDonKSA9PiB7XG4gICAgY29uc3QgcmVxVXJsT2JqZWN0ID0gcmVxdWVzdFVybCB8fCB7fTtcbiAgICBjb25zdCBwcm90b2NvbCA9IHJlcVVybE9iamVjdC5wcm90b2NvbCB8fCBmYWxsYmFja1Byb3RvY29sO1xuICAgIGNvbnN0IHBvcnQgPSAocmVxVXJsT2JqZWN0LnBvcnQgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgcGF0aCA9IHJlcVVybE9iamVjdC5wYXRoIHx8ICcvJztcbiAgICBsZXQgaG9zdCA9IHJlcVVybE9iamVjdC5ob3N0IHx8IHJlcVVybE9iamVjdC5ob3N0bmFtZSB8fCBoZWFkZXJzLmhvc3QgfHwgJ2xvY2FsaG9zdCc7XG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gcG9ydCBpbiBob3N0IGFuZCB0aGVyZSBpcyBhIHBvcnRcbiAgICAvLyBpdCBzaG91bGQgYmUgZGlzcGxheWVkIGlmIGl0J3Mgbm90IDgwIGFuZCA0NDMgKGRlZmF1bHQgcG9ydHMpXG4gICAgaWYgKGhvc3QuaW5kZXhPZignOicpID09PSAtMSAmJlxuICAgICAgICBwb3J0ICYmXG4gICAgICAgIHBvcnQgIT09ICc4MCcgJiZcbiAgICAgICAgcG9ydCAhPT0gJzQ0MycpIHtcbiAgICAgICAgaG9zdCArPSBgOiR7cG9ydH1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtwYXRofWA7XG59O1xuZXhwb3J0cy5nZXRBYnNvbHV0ZVVybCA9IGdldEFic29sdXRlVXJsO1xuLyoqXG4gKiBQYXJzZSBzdGF0dXMgY29kZSBmcm9tIEhUVFAgcmVzcG9uc2UuIFtNb3JlIGRldGFpbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LXNwZWNpZmljYXRpb24vYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi9kYXRhLWh0dHAubWQjc3RhdHVzKVxuICovXG5jb25zdCBwYXJzZVJlc3BvbnNlU3RhdHVzID0gKGtpbmQsIHN0YXR1c0NvZGUpID0+IHtcbiAgICBjb25zdCB1cHBlckJvdW5kID0ga2luZCA9PT0gYXBpXzEuU3BhbktpbmQuQ0xJRU5UID8gNDAwIDogNTAwO1xuICAgIC8vIDF4eCwgMnh4LCAzeHggYXJlIE9LIG9uIGNsaWVudCBhbmQgc2VydmVyXG4gICAgLy8gNHh4IGlzIE9LIG9uIHNlcnZlclxuICAgIGlmIChzdGF0dXNDb2RlICYmIHN0YXR1c0NvZGUgPj0gMTAwICYmIHN0YXR1c0NvZGUgPCB1cHBlckJvdW5kKSB7XG4gICAgICAgIHJldHVybiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5VTlNFVDtcbiAgICB9XG4gICAgLy8gQWxsIG90aGVyIGNvZGVzIGFyZSBlcnJvclxuICAgIHJldHVybiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUjtcbn07XG5leHBvcnRzLnBhcnNlUmVzcG9uc2VTdGF0dXMgPSBwYXJzZVJlc3BvbnNlU3RhdHVzO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBvYmogbWF0Y2ggcGF0dGVyblxuICogQHBhcmFtIGNvbnN0YW50IGUuZyBVUkwgb2YgcmVxdWVzdFxuICogQHBhcmFtIHBhdHRlcm4gTWF0Y2ggcGF0dGVyblxuICovXG5jb25zdCBzYXRpc2ZpZXNQYXR0ZXJuID0gKGNvbnN0YW50LCBwYXR0ZXJuKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGF0dGVybiA9PT0gY29uc3RhbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChjb25zdGFudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuKGNvbnN0YW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdHRlcm4gaXMgaW4gdW5zdXBwb3J0ZWQgZGF0YXR5cGUnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zYXRpc2ZpZXNQYXR0ZXJuID0gc2F0aXNmaWVzUGF0dGVybjtcbi8qKlxuICogU2V0cyB0aGUgc3BhbiB3aXRoIHRoZSBlcnJvciBwYXNzZWQgaW4gcGFyYW1zXG4gKiBAcGFyYW0ge1NwYW59IHNwYW4gdGhlIHNwYW4gdGhhdCBuZWVkIHRvIGJlIHNldFxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgZXJyb3IgdGhhdCB3aWxsIGJlIHNldCB0byBzcGFuXG4gKiBAcGFyYW0ge1NlbWNvbnZTdGFiaWxpdHl9IHNlbWNvbnZTdGFiaWxpdHkgZGV0ZXJtaW5lcyB3aGljaCBzZW1jb252IHZlcnNpb24gdG8gdXNlXG4gKi9cbmNvbnN0IHNldFNwYW5XaXRoRXJyb3IgPSAoc3BhbiwgZXJyb3IsIHNlbWNvbnZTdGFiaWxpdHkpID0+IHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoKHNlbWNvbnZTdGFiaWxpdHkgJiAyIC8qIE9MRCAqLykgPT09IDIgLyogT0xEICovKSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKEF0dHJpYnV0ZU5hbWVzXzEuQXR0cmlidXRlTmFtZXMuSFRUUF9FUlJPUl9OQU1FLCBlcnJvci5uYW1lKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoQXR0cmlidXRlTmFtZXNfMS5BdHRyaWJ1dGVOYW1lcy5IVFRQX0VSUk9SX01FU1NBR0UsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoKHNlbWNvbnZTdGFiaWxpdHkgJiAxIC8qIFNUQUJMRSAqLykgPT09XG4gICAgICAgIDEgLyogU1RBQkxFICovKSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKHNlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9FUlJPUl9UWVBFLCBlcnJvci5uYW1lKTtcbiAgICB9XG4gICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUiwgbWVzc2FnZSB9KTtcbiAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihlcnJvcik7XG59O1xuZXhwb3J0cy5zZXRTcGFuV2l0aEVycm9yID0gc2V0U3BhbldpdGhFcnJvcjtcbi8qKlxuICogQWRkcyBhdHRyaWJ1dGVzIGZvciByZXF1ZXN0IGNvbnRlbnQtbGVuZ3RoIGFuZCBjb250ZW50LWVuY29kaW5nIEhUVFAgaGVhZGVyc1xuICogQHBhcmFtIHsgSW5jb21pbmdNZXNzYWdlIH0gUmVxdWVzdCBvYmplY3Qgd2hvc2UgaGVhZGVycyB3aWxsIGJlIGFuYWx5emVkXG4gKiBAcGFyYW0geyBBdHRyaWJ1dGVzIH0gQXR0cmlidXRlcyBvYmplY3QgdG8gYmUgbW9kaWZpZWRcbiAqL1xuY29uc3Qgc2V0UmVxdWVzdENvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSAocmVxdWVzdCwgYXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldENvbnRlbnRMZW5ndGgocmVxdWVzdC5oZWFkZXJzKTtcbiAgICBpZiAobGVuZ3RoID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCgwLCBleHBvcnRzLmlzQ29tcHJlc3NlZCkocmVxdWVzdC5oZWFkZXJzKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9SRVFVRVNUX0NPTlRFTlRfTEVOR1RIXSA9IGxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JFUVVFU1RfQ09OVEVOVF9MRU5HVEhfVU5DT01QUkVTU0VEXSA9IGxlbmd0aDtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRSZXF1ZXN0Q29udGVudExlbmd0aEF0dHJpYnV0ZSA9IHNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlO1xuLyoqXG4gKiBBZGRzIGF0dHJpYnV0ZXMgZm9yIHJlc3BvbnNlIGNvbnRlbnQtbGVuZ3RoIGFuZCBjb250ZW50LWVuY29kaW5nIEhUVFAgaGVhZGVyc1xuICogQHBhcmFtIHsgSW5jb21pbmdNZXNzYWdlIH0gUmVzcG9uc2Ugb2JqZWN0IHdob3NlIGhlYWRlcnMgd2lsbCBiZSBhbmFseXplZFxuICogQHBhcmFtIHsgQXR0cmlidXRlcyB9IEF0dHJpYnV0ZXMgb2JqZWN0IHRvIGJlIG1vZGlmaWVkXG4gKlxuICogQGRlcHJlY2F0ZWQgdGhpcyBpcyBmb3IgYW4gb2xkZXIgdmVyc2lvbiBvZiBzZW1jb252LiBJdCBpcyByZXRhaW5lZCBmb3IgY29tcGF0aWJpbGl0eSB1c2luZyBPVEVMX1NFTUNPTlZfU1RBQklMSVRZX09QVF9JTlxuICovXG5jb25zdCBzZXRSZXNwb25zZUNvbnRlbnRMZW5ndGhBdHRyaWJ1dGUgPSAocmVzcG9uc2UsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRDb250ZW50TGVuZ3RoKHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgIGlmIChsZW5ndGggPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNDb21wcmVzc2VkKShyZXNwb25zZS5oZWFkZXJzKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSF0gPSBsZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSF9VTkNPTVBSRVNTRURdID0gbGVuZ3RoO1xuICAgIH1cbn07XG5leHBvcnRzLnNldFJlc3BvbnNlQ29udGVudExlbmd0aEF0dHJpYnV0ZSA9IHNldFJlc3BvbnNlQ29udGVudExlbmd0aEF0dHJpYnV0ZTtcbmZ1bmN0aW9uIGdldENvbnRlbnRMZW5ndGgoaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZWFkZXIgPSBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgIGlmIChjb250ZW50TGVuZ3RoSGVhZGVyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBwYXJzZUludChjb250ZW50TGVuZ3RoSGVhZGVyLCAxMCk7XG4gICAgaWYgKGlzTmFOKGNvbnRlbnRMZW5ndGgpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY29udGVudExlbmd0aDtcbn1cbmNvbnN0IGlzQ29tcHJlc3NlZCA9IChoZWFkZXJzKSA9PiB7XG4gICAgY29uc3QgZW5jb2RpbmcgPSBoZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgcmV0dXJuICEhZW5jb2RpbmcgJiYgZW5jb2RpbmcgIT09ICdpZGVudGl0eSc7XG59O1xuZXhwb3J0cy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4vKipcbiAqIE1pbWljcyBOb2RlLmpzIGNvbnZlcnNpb24gb2YgVVJMIHN0cmluZ3MgdG8gUmVxdWVzdE9wdGlvbnMgZXhwZWN0ZWQgYnlcbiAqIGBodHRwLnJlcXVlc3RgIGFuZCBgaHR0cHMucmVxdWVzdGAgQVBJcy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvMjUwNWUyMTdiYmEwNWZjNTgxYjU3MmM2ODVjNWNmMjgwYTE2YzVhMy9saWIvaW50ZXJuYWwvdXJsLmpzI0wxNDE1LUwxNDM3XG4gKlxuICogQHBhcmFtIHN0cmluZ1VybFxuICogQHRocm93cyBUeXBlRXJyb3IgaWYgdGhlIFVSTCBpcyBub3QgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1VybFRvSHR0cE9wdGlvbnMoc3RyaW5nVXJsKSB7XG4gICAgLy8gVGhpcyBpcyBoZWF2aWx5IGluc3BpcmVkIGJ5IE5vZGUuanMgaGFuZGxpbmcgb2YgdGhlIHNhbWUgc2l0dWF0aW9uLCB0cnlpbmdcbiAgICAvLyB0byBmb2xsb3cgaXQgYXMgY2xvc2VseSBhcyBwb3NzaWJsZSB3aGlsZSBrZWVwaW5nIGluIG1pbmQgdGhhdCB3ZSBvbmx5XG4gICAgLy8gZGVhbCB3aXRoIHN0cmluZyBVUkxzLCBub3QgVVJMIG9iamVjdHMuXG4gICAgY29uc3QgeyBob3N0bmFtZSwgcGF0aG5hbWUsIHBvcnQsIHVzZXJuYW1lLCBwYXNzd29yZCwgc2VhcmNoLCBwcm90b2NvbCwgaGFzaCwgaHJlZiwgb3JpZ2luLCBob3N0LCB9ID0gbmV3IFVSTChzdHJpbmdVcmwpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICAgICAgaG9zdG5hbWU6IGhvc3RuYW1lICYmIGhvc3RuYW1lWzBdID09PSAnWycgPyBob3N0bmFtZS5zbGljZSgxLCAtMSkgOiBob3N0bmFtZSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgICAgcGF0aDogYCR7cGF0aG5hbWUgfHwgJyd9JHtzZWFyY2ggfHwgJyd9YCxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgfTtcbiAgICBpZiAocG9ydCAhPT0gJycpIHtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gTnVtYmVyKHBvcnQpO1xuICAgIH1cbiAgICBpZiAodXNlcm5hbWUgfHwgcGFzc3dvcmQpIHtcbiAgICAgICAgb3B0aW9ucy5hdXRoID0gYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpfWA7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuLyoqXG4gKiBNYWtlcyBzdXJlIG9wdGlvbnMgaXMgYW4gdXJsIG9iamVjdFxuICogcmV0dXJuIGFuIG9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWUgYW5kIHBhcnNlZCBvcHRpb25zXG4gKiBAcGFyYW0gbG9nZ2VyIGNvbXBvbmVudCBsb2dnZXJcbiAqIEBwYXJhbSBvcHRpb25zIG9yaWdpbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0gW2V4dHJhT3B0aW9uc10gYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdFxuICovXG5jb25zdCBnZXRSZXF1ZXN0SW5mbyA9IChsb2dnZXIsIG9wdGlvbnMsIGV4dHJhT3B0aW9ucykgPT4ge1xuICAgIGxldCBwYXRobmFtZTtcbiAgICBsZXQgb3JpZ2luO1xuICAgIGxldCBvcHRpb25zUGFyc2VkO1xuICAgIGxldCBpbnZhbGlkVXJsID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udmVydGVkT3B0aW9ucyA9IHN0cmluZ1VybFRvSHR0cE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBvcHRpb25zUGFyc2VkID0gY29udmVydGVkT3B0aW9ucztcbiAgICAgICAgICAgIHBhdGhuYW1lID0gY29udmVydGVkT3B0aW9ucy5wYXRobmFtZSB8fCAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGludmFsaWRVcmwgPSB0cnVlO1xuICAgICAgICAgICAgbG9nZ2VyLnZlcmJvc2UoJ1VuYWJsZSB0byBwYXJzZSBVUkwgcHJvdmlkZWQgdG8gSFRUUCByZXF1ZXN0LCB1c2luZyBmYWxsYmFjayB0byBkZXRlcm1pbmUgcGF0aC4gT3JpZ2luYWwgZXJyb3I6JywgZSk7XG4gICAgICAgICAgICAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGhvdyB1cmwucGFyc2UoKSBiZWhhdmVkLlxuICAgICAgICAgICAgb3B0aW9uc1BhcnNlZCA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiBvcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gb3B0aW9uc1BhcnNlZC5wYXRoIHx8ICcvJztcbiAgICAgICAgfVxuICAgICAgICBvcmlnaW4gPSBgJHtvcHRpb25zUGFyc2VkLnByb3RvY29sIHx8ICdodHRwOid9Ly8ke29wdGlvbnNQYXJzZWQuaG9zdH1gO1xuICAgICAgICBpZiAoZXh0cmFPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc1BhcnNlZCwgZXh0cmFPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zIGluc3RhbmNlb2YgdXJsLlVSTCkge1xuICAgICAgICBvcHRpb25zUGFyc2VkID0ge1xuICAgICAgICAgICAgcHJvdG9jb2w6IG9wdGlvbnMucHJvdG9jb2wsXG4gICAgICAgICAgICBob3N0bmFtZTogdHlwZW9mIG9wdGlvbnMuaG9zdG5hbWUgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBhdGg6IGAke29wdGlvbnMucGF0aG5hbWUgfHwgJyd9JHtvcHRpb25zLnNlYXJjaCB8fCAnJ31gLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5wb3J0ICE9PSAnJykge1xuICAgICAgICAgICAgb3B0aW9uc1BhcnNlZC5wb3J0ID0gTnVtYmVyKG9wdGlvbnMucG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlcm5hbWUgfHwgb3B0aW9ucy5wYXNzd29yZCkge1xuICAgICAgICAgICAgb3B0aW9uc1BhcnNlZC5hdXRoID0gYCR7b3B0aW9ucy51c2VybmFtZX06JHtvcHRpb25zLnBhc3N3b3JkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aG5hbWUgPSBvcHRpb25zLnBhdGhuYW1lO1xuICAgICAgICBvcmlnaW4gPSBvcHRpb25zLm9yaWdpbjtcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnNQYXJzZWQsIGV4dHJhT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnNQYXJzZWQgPSBPYmplY3QuYXNzaWduKHsgcHJvdG9jb2w6IG9wdGlvbnMuaG9zdCA/ICdodHRwOicgOiB1bmRlZmluZWQgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gb3B0aW9uc1BhcnNlZC5ob3N0IHx8XG4gICAgICAgICAgICAob3B0aW9uc1BhcnNlZC5wb3J0ICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IGAke29wdGlvbnNQYXJzZWQuaG9zdG5hbWV9JHtvcHRpb25zUGFyc2VkLnBvcnR9YFxuICAgICAgICAgICAgICAgIDogb3B0aW9uc1BhcnNlZC5ob3N0bmFtZSk7XG4gICAgICAgIG9yaWdpbiA9IGAke29wdGlvbnNQYXJzZWQucHJvdG9jb2wgfHwgJ2h0dHA6J30vLyR7aG9zdG5hbWV9YDtcbiAgICAgICAgcGF0aG5hbWUgPSBvcHRpb25zLnBhdGhuYW1lO1xuICAgICAgICBpZiAoIXBhdGhuYW1lICYmIG9wdGlvbnNQYXJzZWQucGF0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKG9wdGlvbnNQYXJzZWQucGF0aCwgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZFVybC5wYXRobmFtZSB8fCAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNvbWUgcGFja2FnZXMgcmV0dXJuIG1ldGhvZCBpbiBsb3dlcmNhc2UuLlxuICAgIC8vIGVuc3VyZSB1cHBlckNhc2UgZm9yIGNvbnNpc3RlbmN5XG4gICAgY29uc3QgbWV0aG9kID0gb3B0aW9uc1BhcnNlZC5tZXRob2RcbiAgICAgICAgPyBvcHRpb25zUGFyc2VkLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIDogJ0dFVCc7XG4gICAgcmV0dXJuIHsgb3JpZ2luLCBwYXRobmFtZSwgbWV0aG9kLCBvcHRpb25zUGFyc2VkLCBpbnZhbGlkVXJsIH07XG59O1xuZXhwb3J0cy5nZXRSZXF1ZXN0SW5mbyA9IGdldFJlcXVlc3RJbmZvO1xuLyoqXG4gKiBNYWtlcyBzdXJlIG9wdGlvbnMgaXMgb2YgdHlwZSBzdHJpbmcgb3Igb2JqZWN0XG4gKiBAcGFyYW0gb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3RcbiAqL1xuY29uc3QgaXNWYWxpZE9wdGlvbnNUeXBlID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9wdGlvbnM7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8ICh0eXBlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkT3B0aW9uc1R5cGUgPSBpc1ZhbGlkT3B0aW9uc1R5cGU7XG5jb25zdCBleHRyYWN0SG9zdG5hbWVBbmRQb3J0ID0gKHJlcXVlc3RPcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5ob3N0bmFtZSAmJiByZXF1ZXN0T3B0aW9ucy5wb3J0KSB7XG4gICAgICAgIHJldHVybiB7IGhvc3RuYW1lOiByZXF1ZXN0T3B0aW9ucy5ob3N0bmFtZSwgcG9ydDogcmVxdWVzdE9wdGlvbnMucG9ydCB9O1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0gKChfYSA9IHJlcXVlc3RPcHRpb25zLmhvc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXRjaCgvXihbXjovIF0rKSg6XFxkezEsNX0pPy8pKSB8fCBudWxsO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gcmVxdWVzdE9wdGlvbnMuaG9zdG5hbWUgfHwgKG1hdGNoZXMgPT09IG51bGwgPyAnbG9jYWxob3N0JyA6IG1hdGNoZXNbMV0pO1xuICAgIGxldCBwb3J0ID0gcmVxdWVzdE9wdGlvbnMucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsZWFkaW5nIFwiOlwiLiBUaGUgZXh0cmFjdGVkIHBvcnQgd291bGQgYmUgc29tZXRoaW5nIGxpa2UgXCI6ODA4MFwiXG4gICAgICAgICAgICBwb3J0ID0gbWF0Y2hlc1syXS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3J0ID0gcmVxdWVzdE9wdGlvbnMucHJvdG9jb2wgPT09ICdodHRwczonID8gJzQ0MycgOiAnODAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGhvc3RuYW1lLCBwb3J0IH07XG59O1xuZXhwb3J0cy5leHRyYWN0SG9zdG5hbWVBbmRQb3J0ID0gZXh0cmFjdEhvc3RuYW1lQW5kUG9ydDtcbi8qKlxuICogUmV0dXJucyBvdXRnb2luZyByZXF1ZXN0IGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgcmVxdWVzdFxuICogQHBhcmFtIHtQYXJzZWRSZXF1ZXN0T3B0aW9uc30gcmVxdWVzdE9wdGlvbnMgdGhlIHNhbWUgb3B0aW9ucyB1c2VkIHRvIG1ha2UgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB7eyBjb21wb25lbnQ6IHN0cmluZywgaG9zdG5hbWU6IHN0cmluZywgaG9va0F0dHJpYnV0ZXM/OiBBdHRyaWJ1dGVzIH19IG9wdGlvbnMgdXNlZCB0byBwYXNzIGRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge1NlbWNvbnZTdGFiaWxpdHl9IHNlbWNvbnZTdGFiaWxpdHkgZGV0ZXJtaW5lcyB3aGljaCBzZW1jb252IHZlcnNpb24gdG8gdXNlXG4gKi9cbmNvbnN0IGdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSAocmVxdWVzdE9wdGlvbnMsIG9wdGlvbnMsIHNlbWNvbnZTdGFiaWxpdHkpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gb3B0aW9ucy5ob3N0bmFtZTtcbiAgICBjb25zdCBwb3J0ID0gb3B0aW9ucy5wb3J0O1xuICAgIGNvbnN0IG1ldGhvZCA9IChfYSA9IHJlcXVlc3RPcHRpb25zLm1ldGhvZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0dFVCc7XG4gICAgY29uc3Qgbm9ybWFsaXplZE1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IGhlYWRlcnNbJ3VzZXItYWdlbnQnXTtcbiAgICBjb25zdCB1cmxGdWxsID0gKDAsIGV4cG9ydHMuZ2V0QWJzb2x1dGVVcmwpKHJlcXVlc3RPcHRpb25zLCBoZWFkZXJzLCBgJHtvcHRpb25zLmNvbXBvbmVudH06YCk7XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHtcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9VUkxdOiB1cmxGdWxsLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX01FVEhPRF06IG1ldGhvZCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9UQVJHRVRdOiByZXF1ZXN0T3B0aW9ucy5wYXRoIHx8ICcvJyxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfTkFNRV06IGhvc3RuYW1lLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0hPU1RdOiAoX2IgPSBoZWFkZXJzLmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGAke2hvc3RuYW1lfToke3BvcnR9YCxcbiAgICB9O1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIC8vIFJlcXVpcmVkIGF0dHJpYnV0ZXNcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFUVVFU1RfTUVUSE9EXTogbm9ybWFsaXplZE1ldGhvZCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfQUREUkVTU106IGhvc3RuYW1lLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9QT1JUXTogTnVtYmVyKHBvcnQpLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VSTF9GVUxMXTogdXJsRnVsbCxcbiAgICAgICAgLy8gbGVhdmluZyBvdXQgcHJvdG9jb2wgdmVyc2lvbiwgaXQgaXMgbm90IHlldCBuZWdvdGlhdGVkXG4gICAgICAgIC8vIGxlYXZpbmcgb3V0IHByb3RvY29sIG5hbWUsIGl0IGlzIG9ubHkgcmVxdWlyZWQgd2hlbiBwcm90b2NvbCB2ZXJzaW9uIGlzIHNldFxuICAgICAgICAvLyByZXRyaWVzIGFuZCByZWRpcmVjdHMgbm90IHN1cHBvcnRlZFxuICAgICAgICAvLyBPcHQtaW4gYXR0cmlidXRlcyBsZWZ0IG9mZiBmb3Igbm93XG4gICAgfTtcbiAgICAvLyBjb25kaXRpb25hbGx5IHJlcXVpcmVkIGlmIHJlcXVlc3QgbWV0aG9kIHJlcXVpcmVkIGNhc2Ugbm9ybWFsaXphdGlvblxuICAgIGlmIChtZXRob2QgIT09IG5vcm1hbGl6ZWRNZXRob2QpIHtcbiAgICAgICAgbmV3QXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF9PUklHSU5BTF0gPSBtZXRob2Q7XG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9VU0VSX0FHRU5UXSA9IHVzZXJBZ2VudDtcbiAgICB9XG4gICAgc3dpdGNoIChzZW1jb252U3RhYmlsaXR5KSB7XG4gICAgICAgIGNhc2UgMSAvKiBTVEFCTEUgKi86XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCBvcHRpb25zLmhvb2tBdHRyaWJ1dGVzKTtcbiAgICAgICAgY2FzZSAyIC8qIE9MRCAqLzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvbGRBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzLCBvcHRpb25zLmhvb2tBdHRyaWJ1dGVzKTtcbn07XG5leHBvcnRzLmdldE91dGdvaW5nUmVxdWVzdEF0dHJpYnV0ZXMgPSBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzO1xuLyoqXG4gKiBSZXR1cm5zIG91dGdvaW5nIHJlcXVlc3QgTWV0cmljIGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7QXR0cmlidXRlc30gc3BhbkF0dHJpYnV0ZXMgdGhlIHNwYW4gYXR0cmlidXRlc1xuICovXG5jb25zdCBnZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzID0gKHNwYW5BdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX01FVEhPRF0gPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfTkFNRV0gPVxuICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX05BTUVdO1xuICAgIC8vVE9ETzogaHR0cC51cmwgYXR0cmlidXRlLCBpdCBzaG91bGQgc3Vic3RpdHV0ZSBhbnkgcGFyYW1ldGVycyB0byBhdm9pZCBoaWdoIGNhcmRpbmFsaXR5LlxuICAgIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXM7XG4vKipcbiAqIFJldHVybnMgYXR0cmlidXRlcyByZWxhdGVkIHRvIHRoZSBraW5kIG9mIEhUVFAgcHJvdG9jb2wgdXNlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtraW5kXSBLaW5kIG9mIEhUVFAgcHJvdG9jb2wgdXNlZDogXCIxLjBcIiwgXCIxLjFcIiwgXCIyXCIsIFwiU1BEWVwiIG9yIFwiUVVJQ1wiLlxuICovXG5jb25zdCBzZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kID0gKGtpbmQsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICBpZiAoa2luZCkge1xuICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9GTEFWT1JdID0ga2luZDtcbiAgICAgICAgaWYgKGtpbmQudG9VcHBlckNhc2UoKSAhPT0gJ1FVSUMnKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1RSQU5TUE9SVF0gPSBzZW1hbnRpY19jb252ZW50aW9uc18xLk5FVFRSQU5TUE9SVFZBTFVFU19JUF9UQ1A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1RSQU5TUE9SVF0gPSBzZW1hbnRpY19jb252ZW50aW9uc18xLk5FVFRSQU5TUE9SVFZBTFVFU19JUF9VRFA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5zZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kID0gc2V0QXR0cmlidXRlc0Zyb21IdHRwS2luZDtcbi8qKlxuICogUmV0dXJucyBvdXRnb2luZyByZXF1ZXN0IGF0dHJpYnV0ZXMgc2NvcGVkIHRvIHRoZSByZXNwb25zZSBkYXRhXG4gKiBAcGFyYW0ge0luY29taW5nTWVzc2FnZX0gcmVzcG9uc2UgdGhlIHJlc3BvbnNlIG9iamVjdFxuICogQHBhcmFtIHtTZW1jb252U3RhYmlsaXR5fSBzZW1jb252U3RhYmlsaXR5IGRldGVybWluZXMgd2hpY2ggc2VtY29udiB2ZXJzaW9uIHRvIHVzZVxuICovXG5jb25zdCBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChyZXNwb25zZSwgc2VtY29udlN0YWJpbGl0eSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaHR0cFZlcnNpb24sIHNvY2tldCB9ID0gcmVzcG9uc2U7XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IHN0YWJsZUF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAoc3RhdHVzQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHN0YWJsZUF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdID0gc3RhdHVzQ29kZTtcbiAgICB9XG4gICAgaWYgKHNvY2tldCkge1xuICAgICAgICBjb25zdCB7IHJlbW90ZUFkZHJlc3MsIHJlbW90ZVBvcnQgfSA9IHNvY2tldDtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX0lQXSA9IHJlbW90ZUFkZHJlc3M7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9QT1JUXSA9IHJlbW90ZVBvcnQ7XG4gICAgICAgIC8vIFJlY29tbWVuZGVkXG4gICAgICAgIHN0YWJsZUF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9BRERSRVNTXSA9IHJlbW90ZUFkZHJlc3M7XG4gICAgICAgIHN0YWJsZUF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9QT1JUXSA9IHJlbW90ZVBvcnQ7XG4gICAgICAgIHN0YWJsZUF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUFJPVE9DT0xfVkVSU0lPTl0gPSByZXNwb25zZS5odHRwVmVyc2lvbjtcbiAgICB9XG4gICAgKDAsIGV4cG9ydHMuc2V0UmVzcG9uc2VDb250ZW50TGVuZ3RoQXR0cmlidXRlKShyZXNwb25zZSwgb2xkQXR0cmlidXRlcyk7XG4gICAgaWYgKHN0YXR1c0NvZGUpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdID0gc3RhdHVzQ29kZTtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tBdHRyaWJ1dGVOYW1lc18xLkF0dHJpYnV0ZU5hbWVzLkhUVFBfU1RBVFVTX1RFWFRdID0gKHN0YXR1c01lc3NhZ2UgfHwgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgICgwLCBleHBvcnRzLnNldEF0dHJpYnV0ZXNGcm9tSHR0cEtpbmQpKGh0dHBWZXJzaW9uLCBvbGRBdHRyaWJ1dGVzKTtcbiAgICBzd2l0Y2ggKHNlbWNvbnZTdGFiaWxpdHkpIHtcbiAgICAgICAgY2FzZSAxIC8qIFNUQUJMRSAqLzpcbiAgICAgICAgICAgIHJldHVybiBzdGFibGVBdHRyaWJ1dGVzO1xuICAgICAgICBjYXNlIDIgLyogT0xEICovOlxuICAgICAgICAgICAgcmV0dXJuIG9sZEF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIHN0YWJsZUF0dHJpYnV0ZXMpO1xufTtcbmV4cG9ydHMuZ2V0T3V0Z29pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSBnZXRPdXRnb2luZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZTtcbi8qKlxuICogUmV0dXJucyBvdXRnb2luZyByZXF1ZXN0IE1ldHJpYyBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVzcG9uc2UgZGF0YVxuICogQHBhcmFtIHtBdHRyaWJ1dGVzfSBzcGFuQXR0cmlidXRlcyB0aGUgc3BhbiBhdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlID0gKHNwYW5BdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgbWV0cmljQXR0cmlidXRlcyA9IHt9O1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9QT1JUXSA9XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVF07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdID1cbiAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9GTEFWT1JdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0ZMQVZPUl07XG4gICAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRPdXRnb2luZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGdldE91dGdvaW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlO1xuZnVuY3Rpb24gcGFyc2VIb3N0SGVhZGVyKGhvc3RIZWFkZXIsIHByb3RvKSB7XG4gICAgY29uc3QgcGFydHMgPSBob3N0SGVhZGVyLnNwbGl0KCc6Jyk7XG4gICAgLy8gbm8gc2VtaWNvbG9uIGltcGxpZXMgaXB2NCBkb3R0ZWQgc3ludGF4IG9yIGhvc3QgbmFtZSB3aXRob3V0IHBvcnRcbiAgICAvLyB4LngueC54XG4gICAgLy8gZXhhbXBsZS5jb21cbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChwcm90byA9PT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBob3N0OiBwYXJ0c1swXSwgcG9ydDogJzgwJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm90byA9PT0gJ2h0dHBzJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgaG9zdDogcGFydHNbMF0sIHBvcnQ6ICc0NDMnIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaG9zdDogcGFydHNbMF0gfTtcbiAgICB9XG4gICAgLy8gc2luZ2xlIHNlbWljb2xvbiBpbXBsaWVzIGlwdjQgZG90dGVkIHN5bnRheCBvciBob3N0IG5hbWUgd2l0aCBwb3J0XG4gICAgLy8geC54LngueDp5eXl5XG4gICAgLy8gZXhhbXBsZS5jb206eXl5eVxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvc3Q6IHBhcnRzWzBdLFxuICAgICAgICAgICAgcG9ydDogcGFydHNbMV0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIG1vcmUgdGhhbiAyIHBhcnRzIGltcGxpZXMgaXB2NiBzeW50YXggd2l0aCBtdWx0aXBsZSBjb2xvbnNcbiAgICAvLyBbeDp4Ong6eDp4Ong6eDp4XVxuICAgIC8vIFt4Ong6eDp4Ong6eDp4OnhdOnl5eXlcbiAgICBpZiAocGFydHNbMF0uc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgIGlmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICBpZiAocHJvdG8gPT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IGhvc3RIZWFkZXIsIHBvcnQ6ICc4MCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm90byA9PT0gJ2h0dHBzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhvc3Q6IGhvc3RIZWFkZXIsIHBvcnQ6ICc0NDMnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMl0uZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0OiBwYXJ0cy5zbGljZSgwLCAtMSkuam9pbignOicpLFxuICAgICAgICAgICAgICAgIHBvcnQ6IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBub3RoaW5nIGFib3ZlIG1hdGNoZXMganVzdCByZXR1cm4gdGhlIGhvc3QgaGVhZGVyXG4gICAgcmV0dXJuIHsgaG9zdDogaG9zdEhlYWRlciB9O1xufVxuLyoqXG4gKiBHZXQgc2VydmVyLmFkZHJlc3MgYW5kIHBvcnQgYWNjb3JkaW5nIHRvIGh0dHAgc2VtY29udiAxLjI3XG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYmxvYi9iZjBhMmMxMTM0ZjIwNmYwMzQ0MDhiMjAxZGJlYzM3OTYwZWQ2MGVjL2RvY3MvaHR0cC9odHRwLXNwYW5zLm1kI3NldHRpbmctc2VydmVyYWRkcmVzcy1hbmQtc2VydmVycG9ydC1hdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFNlcnZlckFkZHJlc3MocmVxdWVzdCwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgZm9yd2FyZGVkSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzWydmb3J3YXJkZWQnXTtcbiAgICBpZiAoZm9yd2FyZGVkSGVhZGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcGFyc2VGb3J3YXJkZWRIZWFkZXIoZm9yd2FyZGVkSGVhZGVyKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5Lmhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKGVudHJ5Lmhvc3QsIGVudHJ5LnByb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4Rm9yd2FyZGVkSG9zdCA9IHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtaG9zdCddO1xuICAgIGlmICh0eXBlb2YgeEZvcndhcmRlZEhvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcih4Rm9yd2FyZGVkSG9zdCwgcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1wcm90byddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKHhGb3J3YXJkZWRIb3N0LCByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ11bMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoeEZvcndhcmRlZEhvc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHhGb3J3YXJkZWRIb3N0KSAmJlxuICAgICAgICB0eXBlb2YgeEZvcndhcmRlZEhvc3RbMF0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgIHhGb3J3YXJkZWRIb3N0WzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKHhGb3J3YXJkZWRIb3N0WzBdLCByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLXByb3RvJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUhvc3RIZWFkZXIoeEZvcndhcmRlZEhvc3RbMF0sIHJlcXVlc3QuaGVhZGVyc1sneC1mb3J3YXJkZWQtcHJvdG8nXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSG9zdEhlYWRlcih4Rm9yd2FyZGVkSG9zdFswXSk7XG4gICAgfVxuICAgIGNvbnN0IGhvc3QgPSByZXF1ZXN0LmhlYWRlcnNbJ2hvc3QnXTtcbiAgICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnICYmIGhvc3QubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VIb3N0SGVhZGVyKGhvc3QsIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBHZXQgc2VydmVyLmFkZHJlc3MgYW5kIHBvcnQgYWNjb3JkaW5nIHRvIGh0dHAgc2VtY29udiAxLjI3XG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMvYmxvYi9iZjBhMmMxMTM0ZjIwNmYwMzQ0MDhiMjAxZGJlYzM3OTYwZWQ2MGVjL2RvY3MvaHR0cC9odHRwLXNwYW5zLm1kI3NldHRpbmctc2VydmVyYWRkcmVzcy1hbmQtc2VydmVycG9ydC1hdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFJlbW90ZUNsaWVudEFkZHJlc3MocmVxdWVzdCkge1xuICAgIGNvbnN0IGZvcndhcmRlZEhlYWRlciA9IHJlcXVlc3QuaGVhZGVyc1snZm9yd2FyZGVkJ107XG4gICAgaWYgKGZvcndhcmRlZEhlYWRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHBhcnNlRm9yd2FyZGVkSGVhZGVyKGZvcndhcmRlZEhlYWRlcikpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5mb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuZm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHhGb3J3YXJkZWRGb3IgPSByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddO1xuICAgIGlmICh0eXBlb2YgeEZvcndhcmRlZEZvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHhGb3J3YXJkZWRGb3I7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeEZvcndhcmRlZEZvcikpIHtcbiAgICAgICAgcmV0dXJuIHhGb3J3YXJkZWRGb3JbMF07XG4gICAgfVxuICAgIGNvbnN0IHJlbW90ZSA9IHJlcXVlc3Quc29ja2V0LnJlbW90ZUFkZHJlc3M7XG4gICAgaWYgKHJlbW90ZSkge1xuICAgICAgICByZXR1cm4gcmVtb3RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZ2V0UmVtb3RlQ2xpZW50QWRkcmVzcyA9IGdldFJlbW90ZUNsaWVudEFkZHJlc3M7XG5mdW5jdGlvbiBnZXRJbmZvRnJvbUluY29taW5nTWVzc2FnZShjb21wb25lbnQsIHJlcXVlc3QsIGxvZ2dlcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaGVhZGVycy5ob3N0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTCgoX2EgPSByZXF1ZXN0LnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJy8nLCBgJHtjb21wb25lbnR9Oi8vJHtyZXF1ZXN0LmhlYWRlcnMuaG9zdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2FmZVBhcnNlZFVybCA9IG5ldyBVUkwoKF9iID0gcmVxdWVzdC51cmwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcvJywgXG4gICAgICAgICAgICAvLyB1c2luZyBsb2NhbGhvc3QgYXMgYSB3b3JrYXJvdW5kIHRvIHN0aWxsIHVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIGZvciBwYXJzaW5nXG4gICAgICAgICAgICBgJHtjb21wb25lbnR9Oi8vbG9jYWxob3N0YCk7XG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSB1c2UgbG9jYWxob3N0IGFzIGEgd29ya2Fyb3VuZCwgZW5zdXJlIHdlIGhpZGUgdGhlIHJlc3Qgb2YgdGhlIHByb3BlcnRpZXMgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIG91ciB3b3JrYXJvdW5kIGxlYWtpbmcgdGhvdWdoLlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZTogdW5zYWZlUGFyc2VkVXJsLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogdW5zYWZlUGFyc2VkVXJsLnNlYXJjaCxcbiAgICAgICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgdXNlIHRoZSByZXN1bHQgb2YgdW5zYWZlUGFyc2VkVXJsLnRvU3RyaW5nIGFzIGl0J3MgcG90ZW50aWFsbHkgd3JvbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bnNhZmVQYXJzZWRVcmwucGF0aG5hbWUgKyB1bnNhZmVQYXJzZWRVcmwuc2VhcmNoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyBpcyB3cm9uZywgdXNlIHVuZGVmaW5lZCAtIHRoaXMgKnNob3VsZCogbmV2ZXIgaGFwcGVuLCBsb2dnaW5nXG4gICAgICAgIC8vIGZvciB0cm91Ymxlc2hvb3RpbmcgaW4gY2FzZSBpdCBkb2VzIGhhcHBlbi5cbiAgICAgICAgbG9nZ2VyLnZlcmJvc2UoJ1VuYWJsZSB0byBnZXQgVVJMIGZyb20gcmVxdWVzdCcsIGUpO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGluY29taW5nIHJlcXVlc3QgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtJbmNvbWluZ01lc3NhZ2V9IHJlcXVlc3QgdGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge3sgY29tcG9uZW50OiBzdHJpbmcsIHNlcnZlck5hbWU/OiBzdHJpbmcsIGhvb2tBdHRyaWJ1dGVzPzogQXR0cmlidXRlcyB9fSBvcHRpb25zIHVzZWQgdG8gcGFzcyBkYXRhIG5lZWRlZCB0byBjcmVhdGUgYXR0cmlidXRlc1xuICogQHBhcmFtIHtTZW1jb252U3RhYmlsaXR5fSBzZW1jb252U3RhYmlsaXR5IGRldGVybWluZXMgd2hpY2ggc2VtY29udiB2ZXJzaW9uIHRvIHVzZVxuICovXG5jb25zdCBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzID0gKHJlcXVlc3QsIG9wdGlvbnMsIGxvZ2dlcikgPT4ge1xuICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnM7XG4gICAgY29uc3QgdXNlckFnZW50ID0gaGVhZGVyc1sndXNlci1hZ2VudCddO1xuICAgIGNvbnN0IGlwcyA9IGhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddO1xuICAgIGNvbnN0IGh0dHBWZXJzaW9uID0gcmVxdWVzdC5odHRwVmVyc2lvbjtcbiAgICBjb25zdCBob3N0ID0gaGVhZGVycy5ob3N0O1xuICAgIGNvbnN0IGhvc3RuYW1lID0gKGhvc3QgPT09IG51bGwgfHwgaG9zdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdC5yZXBsYWNlKC9eKC4qKSg6WzAtOV17MSw1fSkvLCAnJDEnKSkgfHwgJ2xvY2FsaG9zdCc7XG4gICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgY29uc3Qgbm9ybWFsaXplZE1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpO1xuICAgIGNvbnN0IHNlcnZlckFkZHJlc3MgPSBnZXRTZXJ2ZXJBZGRyZXNzKHJlcXVlc3QsIG9wdGlvbnMuY29tcG9uZW50KTtcbiAgICBjb25zdCBzZXJ2ZXJOYW1lID0gb3B0aW9ucy5zZXJ2ZXJOYW1lO1xuICAgIGNvbnN0IHJlbW90ZUNsaWVudEFkZHJlc3MgPSBnZXRSZW1vdGVDbGllbnRBZGRyZXNzKHJlcXVlc3QpO1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVFVRVNUX01FVEhPRF06IG5vcm1hbGl6ZWRNZXRob2QsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfVVJMX1NDSEVNRV06IG9wdGlvbnMuY29tcG9uZW50LFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1NFUlZFUl9BRERSRVNTXTogc2VydmVyQWRkcmVzcyA9PT0gbnVsbCB8fCBzZXJ2ZXJBZGRyZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXJ2ZXJBZGRyZXNzLmhvc3QsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfTkVUV09SS19QRUVSX0FERFJFU1NdOiByZXF1ZXN0LnNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX05FVFdPUktfUEVFUl9QT1JUXTogcmVxdWVzdC5zb2NrZXQucmVtb3RlUG9ydCxcbiAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9ORVRXT1JLX1BST1RPQ09MX1ZFUlNJT05dOiByZXF1ZXN0Lmh0dHBWZXJzaW9uLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX1VTRVJfQUdFTlRfT1JJR0lOQUxdOiB1c2VyQWdlbnQsXG4gICAgfTtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBnZXRJbmZvRnJvbUluY29taW5nTWVzc2FnZShvcHRpb25zLmNvbXBvbmVudCwgcmVxdWVzdCwgbG9nZ2VyKTtcbiAgICBpZiAoKHBhcnNlZFVybCA9PT0gbnVsbCB8fCBwYXJzZWRVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlZFVybC5wYXRobmFtZSkgIT0gbnVsbCkge1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9VUkxfUEFUSF0gPSBwYXJzZWRVcmwucGF0aG5hbWU7XG4gICAgfVxuICAgIGlmIChyZW1vdGVDbGllbnRBZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgbmV3QXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfQ0xJRU5UX0FERFJFU1NdID0gcmVtb3RlQ2xpZW50QWRkcmVzcztcbiAgICB9XG4gICAgaWYgKChzZXJ2ZXJBZGRyZXNzID09PSBudWxsIHx8IHNlcnZlckFkZHJlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZlckFkZHJlc3MucG9ydCkgIT0gbnVsbCkge1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9TRVJWRVJfUE9SVF0gPSBOdW1iZXIoc2VydmVyQWRkcmVzcy5wb3J0KTtcbiAgICB9XG4gICAgLy8gY29uZGl0aW9uYWxseSByZXF1aXJlZCBpZiByZXF1ZXN0IG1ldGhvZCByZXF1aXJlZCBjYXNlIG5vcm1hbGl6YXRpb25cbiAgICBpZiAobWV0aG9kICE9PSBub3JtYWxpemVkTWV0aG9kKSB7XG4gICAgICAgIG5ld0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVRVUVTVF9NRVRIT0RfT1JJR0lOQUxdID0gbWV0aG9kO1xuICAgIH1cbiAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0ge1xuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1VSTF06IHBhcnNlZFVybC50b1N0cmluZygpLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0hPU1RdOiBob3N0LFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9OQU1FXTogaG9zdG5hbWUsXG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTogbWV0aG9kLFxuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NDSEVNRV06IG9wdGlvbnMuY29tcG9uZW50LFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBpcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX0NMSUVOVF9JUF0gPSBpcHMuc3BsaXQoJywnKVswXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZXJ2ZXJOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TRVJWRVJfTkFNRV0gPSBzZXJ2ZXJOYW1lO1xuICAgIH1cbiAgICBpZiAocGFyc2VkVXJsID09PSBudWxsIHx8IHBhcnNlZFVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyc2VkVXJsLnBhdGhuYW1lKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1RBUkdFVF0gPVxuICAgICAgICAgICAgKHBhcnNlZFVybCA9PT0gbnVsbCB8fCBwYXJzZWRVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnNlZFVybC5wYXRobmFtZSkgKyAocGFyc2VkVXJsID09PSBudWxsIHx8IHBhcnNlZFVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyc2VkVXJsLnNlYXJjaCkgfHwgJy8nO1xuICAgIH1cbiAgICBpZiAodXNlckFnZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfVVNFUl9BR0VOVF0gPSB1c2VyQWdlbnQ7XG4gICAgfVxuICAgICgwLCBleHBvcnRzLnNldFJlcXVlc3RDb250ZW50TGVuZ3RoQXR0cmlidXRlKShyZXF1ZXN0LCBvbGRBdHRyaWJ1dGVzKTtcbiAgICAoMCwgZXhwb3J0cy5zZXRBdHRyaWJ1dGVzRnJvbUh0dHBLaW5kKShodHRwVmVyc2lvbiwgb2xkQXR0cmlidXRlcyk7XG4gICAgc3dpdGNoIChvcHRpb25zLnNlbWNvbnZTdGFiaWxpdHkpIHtcbiAgICAgICAgY2FzZSAxIC8qIFNUQUJMRSAqLzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xuICAgICAgICBjYXNlIDIgLyogT0xEICovOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2xkQXR0cmlidXRlcywgb3B0aW9ucy5ob29rQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMsIG9wdGlvbnMuaG9va0F0dHJpYnV0ZXMpO1xufTtcbmV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlcyA9IGdldEluY29taW5nUmVxdWVzdEF0dHJpYnV0ZXM7XG4vKipcbiAqIFJldHVybnMgaW5jb21pbmcgcmVxdWVzdCBNZXRyaWMgYXR0cmlidXRlcyBzY29wZWQgdG8gdGhlIHJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtBdHRyaWJ1dGVzfSBzcGFuQXR0cmlidXRlcyB0aGUgc3BhbiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge3sgY29tcG9uZW50OiBzdHJpbmcgfX0gb3B0aW9ucyB1c2VkIHRvIHBhc3MgZGF0YSBuZWVkZWQgdG8gY3JlYXRlIGF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IChzcGFuQXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IG1ldHJpY0F0dHJpYnV0ZXMgPSB7fTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9TQ0hFTUVdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NDSEVNRV07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfTUVUSE9EXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9NRVRIT0RdO1xuICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfSE9TVF9OQU1FXSA9XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfTkFNRV07XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfRkxBVk9SXSA9IHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfSFRUUF9GTEFWT1JdO1xuICAgIC8vVE9ETzogaHR0cC50YXJnZXQgYXR0cmlidXRlLCBpdCBzaG91bGQgc3Vic3RpdHV0ZSBhbnkgcGFyYW1ldGVycyB0byBhdm9pZCBoaWdoIGNhcmRpbmFsaXR5LlxuICAgIHJldHVybiBtZXRyaWNBdHRyaWJ1dGVzO1xufTtcbmV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlcyA9IGdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXM7XG4vKipcbiAqIFJldHVybnMgaW5jb21pbmcgcmVxdWVzdCBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVzcG9uc2UgZGF0YVxuICogQHBhcmFtIHsoU2VydmVyUmVzcG9uc2UgJiB7IHNvY2tldDogU29ja2V0OyB9KX0gcmVzcG9uc2UgdGhlIHJlc3BvbnNlIG9iamVjdFxuICovXG5jb25zdCBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZSA9IChyZXF1ZXN0LCByZXNwb25zZSwgc2VtY29udlN0YWJpbGl0eSkgPT4ge1xuICAgIC8vIHRha2Ugc29ja2V0IGZyb20gdGhlIHJlcXVlc3QsXG4gICAgLy8gc2luY2UgaXQgbWF5IGJlIGRldGFjaGVkIGZyb20gdGhlIHJlc3BvbnNlIG9iamVjdCBpbiBrZWVwLWFsaXZlIG1vZGVcbiAgICBjb25zdCB7IHNvY2tldCB9ID0gcmVxdWVzdDtcbiAgICBjb25zdCB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UgfSA9IHJlc3BvbnNlO1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLkFUVFJfSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERV06IHN0YXR1c0NvZGUsXG4gICAgfTtcbiAgICBjb25zdCBycGNNZXRhZGF0YSA9ICgwLCBjb3JlXzEuZ2V0UlBDTWV0YWRhdGEpKGFwaV8xLmNvbnRleHQuYWN0aXZlKCkpO1xuICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgIGNvbnN0IHsgbG9jYWxBZGRyZXNzLCBsb2NhbFBvcnQsIHJlbW90ZUFkZHJlc3MsIHJlbW90ZVBvcnQgfSA9IHNvY2tldDtcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX0lQXSA9IGxvY2FsQWRkcmVzcztcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX1BPUlRdID0gbG9jYWxQb3J0O1xuICAgICAgICBvbGRBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfSVBdID0gcmVtb3RlQWRkcmVzcztcbiAgICAgICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX1BPUlRdID0gcmVtb3RlUG9ydDtcbiAgICB9XG4gICAgb2xkQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdID0gc3RhdHVzQ29kZTtcbiAgICBvbGRBdHRyaWJ1dGVzW0F0dHJpYnV0ZU5hbWVzXzEuQXR0cmlidXRlTmFtZXMuSFRUUF9TVEFUVVNfVEVYVF0gPSAoc3RhdHVzTWVzc2FnZSB8fCAnJykudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoKHJwY01ldGFkYXRhID09PSBudWxsIHx8IHJwY01ldGFkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBycGNNZXRhZGF0YS50eXBlKSA9PT0gY29yZV8xLlJQQ1R5cGUuSFRUUCAmJiBycGNNZXRhZGF0YS5yb3V0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9sZEF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXSA9IHJwY01ldGFkYXRhLnJvdXRlO1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JPVVRFXSA9IHJwY01ldGFkYXRhLnJvdXRlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNlbWNvbnZTdGFiaWxpdHkpIHtcbiAgICAgICAgY2FzZSAxIC8qIFNUQUJMRSAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xuICAgICAgICBjYXNlIDIgLyogT0xEICovOlxuICAgICAgICAgICAgcmV0dXJuIG9sZEF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9sZEF0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xufTtcbmV4cG9ydHMuZ2V0SW5jb21pbmdSZXF1ZXN0QXR0cmlidXRlc09uUmVzcG9uc2UgPSBnZXRJbmNvbWluZ1JlcXVlc3RBdHRyaWJ1dGVzT25SZXNwb25zZTtcbi8qKlxuICogUmV0dXJucyBpbmNvbWluZyByZXF1ZXN0IE1ldHJpYyBhdHRyaWJ1dGVzIHNjb3BlZCB0byB0aGUgcmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge0F0dHJpYnV0ZXN9IHNwYW5BdHRyaWJ1dGVzIHRoZSBzcGFuIGF0dHJpYnV0ZXNcbiAqL1xuY29uc3QgZ2V0SW5jb21pbmdSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0ge307XG4gICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdID1cbiAgICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgICBtZXRyaWNBdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX0hPU1RfUE9SVF0gPVxuICAgICAgICBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9IT1NUX1BPUlRdO1xuICAgIGlmIChzcGFuQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUk9VVEVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWV0cmljQXR0cmlidXRlc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX0hUVFBfUk9VVEVdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRJbmNvbWluZ1JlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGdldEluY29taW5nUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlO1xuY29uc3QgZ2V0SW5jb21pbmdTdGFibGVSZXF1ZXN0TWV0cmljQXR0cmlidXRlc09uUmVzcG9uc2UgPSAoc3BhbkF0dHJpYnV0ZXMpID0+IHtcbiAgICBjb25zdCBtZXRyaWNBdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JPVVRFXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUk9VVEVdID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19IVFRQX1JPVVRFXTtcbiAgICB9XG4gICAgLy8gcmVxdWlyZWQgaWYgYW5kIG9ubHkgaWYgb25lIHdhcyBzZW50LCBzYW1lIGFzIHNwYW4gcmVxdWlyZW1lbnRcbiAgICBpZiAoc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdKSB7XG4gICAgICAgIG1ldHJpY0F0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5BVFRSX0hUVFBfUkVTUE9OU0VfU1RBVFVTX0NPREVdID1cbiAgICAgICAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljX2NvbnZlbnRpb25zXzEuQVRUUl9IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldHJpY0F0dHJpYnV0ZXM7XG59O1xuZXhwb3J0cy5nZXRJbmNvbWluZ1N0YWJsZVJlcXVlc3RNZXRyaWNBdHRyaWJ1dGVzT25SZXNwb25zZSA9IGdldEluY29taW5nU3RhYmxlUmVxdWVzdE1ldHJpY0F0dHJpYnV0ZXNPblJlc3BvbnNlO1xuZnVuY3Rpb24gaGVhZGVyQ2FwdHVyZSh0eXBlLCBoZWFkZXJzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGhlYWRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRIZWFkZXIgPSBoZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIG5vcm1hbGl6ZWRIZWFkZXJzLnNldChjYXB0dXJlZEhlYWRlciwgY2FwdHVyZWRIZWFkZXIucmVwbGFjZSgvLS9nLCAnXycpKTtcbiAgICB9XG4gICAgcmV0dXJuIChzcGFuLCBnZXRIZWFkZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjYXB0dXJlZEhlYWRlciBvZiBub3JtYWxpemVkSGVhZGVycy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0SGVhZGVyKGNhcHR1cmVkSGVhZGVyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSGVhZGVyID0gbm9ybWFsaXplZEhlYWRlcnMuZ2V0KGNhcHR1cmVkSGVhZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGBodHRwLiR7dHlwZX0uaGVhZGVyLiR7bm9ybWFsaXplZEhlYWRlcn1gO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShrZXksIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGtleSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5oZWFkZXJDYXB0dXJlID0gaGVhZGVyQ2FwdHVyZTtcbmNvbnN0IEtOT1dOX01FVEhPRFMgPSBuZXcgU2V0KFtcbiAgICAvLyBtZXRob2RzIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTAuaHRtbCNuYW1lLW1ldGhvZHNcbiAgICAnR0VUJyxcbiAgICAnSEVBRCcsXG4gICAgJ1BPU1QnLFxuICAgICdQVVQnLFxuICAgICdERUxFVEUnLFxuICAgICdDT05ORUNUJyxcbiAgICAnT1BUSU9OUycsXG4gICAgJ1RSQUNFJyxcbiAgICAvLyBQQVRDSCBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM1Nzg5Lmh0bWxcbiAgICAnUEFUQ0gnLFxuXSk7XG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgaWYgKG1ldGhvZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnR0VUJztcbiAgICB9XG4gICAgY29uc3QgdXBwZXIgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoS05PV05fTUVUSE9EUy5oYXModXBwZXIpKSB7XG4gICAgICAgIHJldHVybiB1cHBlcjtcbiAgICB9XG4gICAgcmV0dXJuICdfT1RIRVInO1xufVxuZnVuY3Rpb24gcGFyc2VGb3J3YXJkZWRIZWFkZXIoaGVhZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZvcndhcmRlZFBhcnNlKGhlYWRlcik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/utils.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ }),</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js":</span>
<span class="cstat-no" title="statement not covered" >/*!**********************************************************************************************************************************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \**********************************************************************************************************************************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, exports) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.VERSION = '0.57.2';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWh0dHBAMC41Ny4yX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWh0dHAvYnVpbGQvc3JjL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvaG9tZS9vbWFyL0RvY3VtZW50cy9ydWxlSVEvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1odHRwQDAuNTcuMl9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1odHRwL2J1aWxkL3NyYy92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5WRVJTSU9OID0gJzAuNTcuMic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation-http@0.57.2_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-http/build/src/version.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ })</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >};</span>
<span class="cstat-no" title="statement not covered" >;</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-09-12T12:09:10.571Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    