#!/usr/bin/env python3
"""
Comprehensive Security Vulnerability Audit for RuleIQ Platform
Identifies and categorizes all security vulnerabilities by severity
"""

import os
import re
import json
import subprocess
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Tuple

class SecurityAuditor:
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.vulnerabilities = {
            "CRITICAL": [],
            "HIGH": [],
            "MEDIUM": [],
            "LOW": []
        }
        self.scan_results = {}
        
    def scan_hardcoded_secrets(self) -> List[Dict]:
        """Scan for hardcoded secrets and credentials"""
        secrets_found = []
        patterns = [
            (r'password\s*=\s*["\'][^"\']+["\']', "Hardcoded password"),
            (r'secret\s*=\s*["\'][^"\']+["\']', "Hardcoded secret"),
            (r'api_key\s*=\s*["\'][^"\']+["\']', "Hardcoded API key"),
            (r'token\s*=\s*["\'][^"\']+["\']', "Hardcoded token"),
            (r'bearer\s+[a-zA-Z0-9\-_\.]+', "Hardcoded bearer token"),
            (r'["\']sk-[a-zA-Z0-9]{48}["\']', "OpenAI API key exposed"),
            (r'JWT_SECRET\s*=\s*["\'][^"\']+["\']', "Hardcoded JWT secret"),
        ]
        
        print("üîç Scanning for hardcoded secrets...")
        
        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith('.py'):
                    file_path = Path(root) / file
                    # Skip test files and this script
                    if 'test' in str(file_path) or file_path == Path(__file__):
                        continue
                        
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        for line_num, line in enumerate(content.splitlines(), 1):
                            for pattern, vuln_type in patterns:
                                if re.search(pattern, line, re.IGNORECASE):
                                    # Skip if it's using os.getenv
                                    if 'os.getenv' in line or 'os.environ' in line:
                                        continue
                                    secrets_found.append({
                                        "file": str(file_path.relative_to(self.project_root)),
                                        "line": line_num,
                                        "type": vuln_type,
                                        "severity": "CRITICAL",
                                        "code": line.strip()[:100]
                                    })
                    except Exception as e:
                        pass
                        
        return secrets_found
    
    def scan_sql_injection(self) -> List[Dict]:
        """Scan for SQL injection vulnerabilities"""
        sql_vulns = []
        patterns = [
            (r'f["\'](SELECT|INSERT|UPDATE|DELETE|DROP).*{.*}["\']', "SQL Injection - f-string"),
            (r'["\']\s*\+.*?(SELECT|INSERT|UPDATE|DELETE)', "SQL Injection - string concatenation"),
            (r'\.format\(.*?\).*(SELECT|INSERT|UPDATE|DELETE)', "SQL Injection - format string"),
            (r'%s.*(SELECT|INSERT|UPDATE|DELETE)(?!.*\,)', "SQL Injection - improper parameterization"),
        ]
        
        print("üîç Scanning for SQL injection vulnerabilities...")
        
        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith('.py'):
                    file_path = Path(root) / file
                    if 'test' in str(file_path) or file_path == Path(__file__):
                        continue
                        
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        for line_num, line in enumerate(content.splitlines(), 1):
                            for pattern, vuln_type in patterns:
                                if re.search(pattern, line, re.IGNORECASE):
                                    sql_vulns.append({
                                        "file": str(file_path.relative_to(self.project_root)),
                                        "line": line_num,
                                        "type": vuln_type,
                                        "severity": "CRITICAL",
                                        "code": line.strip()[:100]
                                    })
                    except Exception as e:
                        pass
                        
        return sql_vulns
    
    def scan_xss_vulnerabilities(self) -> List[Dict]:
        """Scan for XSS vulnerabilities"""
        xss_vulns = []
        patterns = [
            (r'render_template_string\([^)]*\)', "XSS - unsafe template rendering"),
            (r'\.html\s*=.*request\.(args|form|values)', "XSS - direct HTML assignment"),
            (r'Markup\([^)]*\)(?!.*escape)', "XSS - unescaped Markup"),
            (r'\.innerHTML\s*=', "XSS - innerHTML usage"),
            (r'\|safe(?!\s*})', "XSS - Jinja2 safe filter"),
        ]
        
        print("üîç Scanning for XSS vulnerabilities...")
        
        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith(('.py', '.html', '.js')):
                    file_path = Path(root) / file
                    if 'test' in str(file_path) or file_path == Path(__file__):
                        continue
                        
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        for line_num, line in enumerate(content.splitlines(), 1):
                            for pattern, vuln_type in patterns:
                                if re.search(pattern, line, re.IGNORECASE):
                                    xss_vulns.append({
                                        "file": str(file_path.relative_to(self.project_root)),
                                        "line": line_num,
                                        "type": vuln_type,
                                        "severity": "HIGH",
                                        "code": line.strip()[:100]
                                    })
                    except Exception as e:
                        pass
                        
        return xss_vulns
    
    def scan_authentication_issues(self) -> List[Dict]:
        """Scan for authentication and authorization issues"""
        auth_issues = []
        patterns = [
            (r'verify\s*=\s*False', "SSL verification disabled"),
            (r'@app\.route.*(?!.*@.*auth)', "Unprotected endpoint"),
            (r'session\[.*\]\s*=(?!.*expire)', "Session without expiration"),
            (r'def.*admin.*\(.*\)(?!.*check|.*auth|.*login)', "Admin function without auth check"),
        ]
        
        print("üîç Scanning for authentication issues...")
        
        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith('.py'):
                    file_path = Path(root) / file
                    if 'test' in str(file_path) or file_path == Path(__file__):
                        continue
                        
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        for line_num, line in enumerate(content.splitlines(), 1):
                            for pattern, vuln_type in patterns:
                                if re.search(pattern, line, re.IGNORECASE):
                                    auth_issues.append({
                                        "file": str(file_path.relative_to(self.project_root)),
                                        "line": line_num,
                                        "type": vuln_type,
                                        "severity": "HIGH",
                                        "code": line.strip()[:100]
                                    })
                    except Exception as e:
                        pass
                        
        return auth_issues
    
    def scan_insecure_dependencies(self) -> List[Dict]:
        """Check for known vulnerable dependencies"""
        vulnerable_deps = []
        
        print("üîç Checking for vulnerable dependencies...")
        
        # Check requirements.txt
        req_file = self.project_root / "requirements.txt"
        if req_file.exists():
            try:
                # Run safety check if available
                result = subprocess.run(
                    ["safety", "check", "--json"],
                    capture_output=True,
                    text=True,
                    cwd=self.project_root
                )
                if result.returncode == 0:
                    vulns = json.loads(result.stdout)
                    for vuln in vulns:
                        vulnerable_deps.append({
                            "package": vuln.get("package", "unknown"),
                            "installed": vuln.get("installed_version", "unknown"),
                            "vulnerability": vuln.get("vulnerability", ""),
                            "severity": "HIGH",
                            "advisory": vuln.get("advisory", "")
                        })
            except:
                # Fallback to manual check for known vulnerable versions
                with open(req_file, 'r') as f:
                    for line in f:
                        if 'flask<2.0' in line.lower() or 'django<3.2' in line.lower():
                            vulnerable_deps.append({
                                "package": line.strip(),
                                "severity": "HIGH",
                                "issue": "Outdated version with known vulnerabilities"
                            })
                            
        return vulnerable_deps
    
    def scan_path_traversal(self) -> List[Dict]:
        """Scan for path traversal vulnerabilities"""
        path_vulns = []
        patterns = [
            (r'open\([^)]*request\.(args|form|values)', "Path traversal - user input in file open"),
            (r'os\.path\.join\([^)]*request\.(args|form|values)', "Path traversal - user input in path join"),
            (r'send_file\([^)]*request\.(args|form|values)', "Path traversal - user input in send_file"),
        ]
        
        print("üîç Scanning for path traversal vulnerabilities...")
        
        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith('.py'):
                    file_path = Path(root) / file
                    if 'test' in str(file_path) or file_path == Path(__file__):
                        continue
                        
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        for line_num, line in enumerate(content.splitlines(), 1):
                            for pattern, vuln_type in patterns:
                                if re.search(pattern, line, re.IGNORECASE):
                                    path_vulns.append({
                                        "file": str(file_path.relative_to(self.project_root)),
                                        "line": line_num,
                                        "type": vuln_type,
                                        "severity": "HIGH",
                                        "code": line.strip()[:100]
                                    })
                    except Exception as e:
                        pass
                        
        return path_vulns
    
    def categorize_vulnerabilities(self, vulns: List[Dict], category: str):
        """Categorize vulnerabilities by severity"""
        for vuln in vulns:
            severity = vuln.get("severity", "MEDIUM")
            self.vulnerabilities[severity].append({
                "category": category,
                **vuln
            })
    
    def generate_audit_report(self):
        """Generate comprehensive audit report"""
        total_vulns = sum(len(v) for v in self.vulnerabilities.values())
        
        report = {
            "audit_timestamp": datetime.now().isoformat(),
            "summary": {
                "total_vulnerabilities": total_vulns,
                "critical": len(self.vulnerabilities["CRITICAL"]),
                "high": len(self.vulnerabilities["HIGH"]),
                "medium": len(self.vulnerabilities["MEDIUM"]),
                "low": len(self.vulnerabilities["LOW"])
            },
            "vulnerabilities": self.vulnerabilities,
            "recommendations": {
                "immediate_actions": [
                    "Fix all CRITICAL vulnerabilities within 12 hours",
                    "Replace hardcoded secrets with environment variables",
                    "Implement parameterized queries for all database operations",
                    "Add authentication to all sensitive endpoints",
                    "Update vulnerable dependencies"
                ],
                "security_improvements": [
                    "Implement OWASP security headers",
                    "Add rate limiting to prevent DoS attacks",
                    "Enable audit logging for all security events",
                    "Implement input validation and sanitization",
                    "Set up security monitoring and alerting"
                ]
            },
            "owasp_top_10_status": {
                "A01_broken_access_control": "VULNERABLE",
                "A02_cryptographic_failures": "VULNERABLE", 
                "A03_injection": "VULNERABLE",
                "A04_insecure_design": "NEEDS_REVIEW",
                "A05_security_misconfiguration": "VULNERABLE",
                "A06_vulnerable_components": "NEEDS_CHECK",
                "A07_identification_failures": "VULNERABLE",
                "A08_data_integrity_failures": "NEEDS_REVIEW",
                "A09_logging_failures": "VULNERABLE",
                "A10_server_side_request_forgery": "NEEDS_CHECK"
            }
        }
        
        # Save detailed report
        report_path = self.project_root / "security_audit_report.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        # Generate markdown report
        self.generate_markdown_report(report)
        
        return report
    
    def generate_markdown_report(self, report: dict):
        """Generate human-readable markdown report"""
        md_content = f"""# Security Audit Report - RuleIQ Platform

Generated: {report['audit_timestamp']}

## Executive Summary

**CRITICAL SECURITY ALERT**: {report['summary']['critical']} critical vulnerabilities identified requiring immediate remediation.

### Vulnerability Summary
- **CRITICAL**: {report['summary']['critical']} vulnerabilities
- **HIGH**: {report['summary']['high']} vulnerabilities  
- **MEDIUM**: {report['summary']['medium']} vulnerabilities
- **LOW**: {report['summary']['low']} vulnerabilities
- **TOTAL**: {report['summary']['total_vulnerabilities']} vulnerabilities

## Critical Vulnerabilities (Fix Immediately)

"""
        
        # Add critical vulnerabilities
        for vuln in self.vulnerabilities["CRITICAL"]:
            md_content += f"""### {vuln.get('category', 'Unknown')} - {vuln.get('type', 'Unknown')}
- **File**: `{vuln.get('file', 'unknown')}`
- **Line**: {vuln.get('line', 'N/A')}
- **Code**: `{vuln.get('code', '')}`

"""
        
        md_content += """## Immediate Actions Required

1. **Within 2 hours**: Fix all hardcoded credentials
2. **Within 6 hours**: Patch SQL injection vulnerabilities
3. **Within 12 hours**: Fix all CRITICAL vulnerabilities
4. **Within 24 hours**: Fix all HIGH vulnerabilities

## OWASP Top 10 Compliance Status

"""
        
        for owasp_item, status in report['owasp_top_10_status'].items():
            icon = "‚ùå" if status == "VULNERABLE" else "‚ö†Ô∏è"
            md_content += f"- {icon} **{owasp_item}**: {status}\n"
        
        # Save markdown report
        md_path = self.project_root / "SECURITY_AUDIT_REPORT.md"
        with open(md_path, 'w') as f:
            f.write(md_content)
        
        print(f"‚úÖ Markdown report saved to: {md_path}")
    
    def run_full_audit(self):
        """Run comprehensive security audit"""
        print("üîê Starting Comprehensive Security Audit...\n")
        
        # 1. Scan for hardcoded secrets
        secrets = self.scan_hardcoded_secrets()
        self.categorize_vulnerabilities(secrets, "Hardcoded Secrets")
        print(f"   Found {len(secrets)} hardcoded secrets")
        
        # 2. Scan for SQL injection
        sql_vulns = self.scan_sql_injection()
        self.categorize_vulnerabilities(sql_vulns, "SQL Injection")
        print(f"   Found {len(sql_vulns)} SQL injection vulnerabilities")
        
        # 3. Scan for XSS
        xss_vulns = self.scan_xss_vulnerabilities()
        self.categorize_vulnerabilities(xss_vulns, "XSS")
        print(f"   Found {len(xss_vulns)} XSS vulnerabilities")
        
        # 4. Scan for authentication issues
        auth_issues = self.scan_authentication_issues()
        self.categorize_vulnerabilities(auth_issues, "Authentication")
        print(f"   Found {len(auth_issues)} authentication issues")
        
        # 5. Check dependencies
        dep_vulns = self.scan_insecure_dependencies()
        self.categorize_vulnerabilities(dep_vulns, "Dependencies")
        print(f"   Found {len(dep_vulns)} vulnerable dependencies")
        
        # 6. Scan for path traversal
        path_vulns = self.scan_path_traversal()
        self.categorize_vulnerabilities(path_vulns, "Path Traversal")
        print(f"   Found {len(path_vulns)} path traversal vulnerabilities")
        
        # 7. Generate report
        print("\nüìä Generating audit report...")
        report = self.generate_audit_report()
        
        # Print summary
        print("\n" + "="*60)
        print("üö® SECURITY AUDIT COMPLETE - IMMEDIATE ACTION REQUIRED")
        print("="*60)
        print(f"\nüìà Vulnerability Breakdown:")
        print(f"   CRITICAL: {report['summary']['critical']} (Fix within 12 hours)")
        print(f"   HIGH: {report['summary']['high']} (Fix within 24 hours)")
        print(f"   MEDIUM: {report['summary']['medium']} (Fix within 48 hours)")
        print(f"   LOW: {report['summary']['low']} (Document for later)")
        print(f"\n   TOTAL: {report['summary']['total_vulnerabilities']} vulnerabilities")
        
        print("\nüìã Reports Generated:")
        print("   - security_audit_report.json (detailed JSON)")
        print("   - SECURITY_AUDIT_REPORT.md (human-readable)")
        
        print("\n‚ö° Next Steps:")
        print("   1. Review SECURITY_AUDIT_REPORT.md")
        print("   2. Run: python security_vulnerability_fix.py")
        print("   3. Verify fixes with: python security_vulnerability_verify.py")
        
        return report

if __name__ == "__main__":
    auditor = SecurityAuditor()
    auditor.run_full_audit()