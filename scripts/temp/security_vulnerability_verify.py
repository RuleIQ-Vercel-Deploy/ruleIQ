#!/usr/bin/env python3
"""
Security Vulnerability Verification Script
Verifies that all security fixes have been properly applied
"""

import os
import re
import json
import subprocess
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any

class SecurityVerifier:
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.verification_results = {
            "passed": [],
            "failed": [],
            "warnings": []
        }
        
    def verify_no_hardcoded_secrets(self) -> bool:
        """Verify no hardcoded secrets remain"""
        print("üîç Verifying no hardcoded secrets...")
        
        patterns = [
            (r'password\s*=\s*["\'][^{]*["\'](?!.*os\.getenv)', "Hardcoded password"),
            (r'secret\s*=\s*["\'][^{]*["\'](?!.*os\.getenv)', "Hardcoded secret"),
            (r'api_key\s*=\s*["\'][^{]*["\'](?!.*os\.getenv)', "Hardcoded API key"),
            (r'JWT_SECRET\s*=\s*["\'][^{]*["\'](?!.*os\.getenv)', "Hardcoded JWT secret"),
            (r'["\']sk-[a-zA-Z0-9]{48}["\']', "OpenAI API key"),
        ]
        
        issues_found = False
        
        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith('.py'):
                    file_path = Path(root) / file
                    # Skip test files, this script, and example files
                    if any(skip in str(file_path) for skip in ['test', 'verify', 'example', 'template']):
                        continue
                        
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        for line_num, line in enumerate(content.splitlines(), 1):
                            for pattern, issue_type in patterns:
                                if re.search(pattern, line, re.IGNORECASE):
                                    self.verification_results["failed"].append({
                                        "check": "No hardcoded secrets",
                                        "file": str(file_path.relative_to(self.project_root)),
                                        "line": line_num,
                                        "issue": issue_type
                                    })
                                    issues_found = True
                                    print(f"   ‚ùå Found {issue_type} in {file_path.name}:{line_num}")
                    except:
                        pass
        
        if not issues_found:
            self.verification_results["passed"].append("No hardcoded secrets found")
            print("   ‚úÖ PASSED: No hardcoded secrets found")
            return True
        return False
    
    def verify_sql_injection_protection(self) -> bool:
        """Verify SQL injection protection is in place"""
        print("üîç Verifying SQL injection protection...")
        
        vulnerable_patterns = [
            r'f["\'].*?(SELECT|INSERT|UPDATE|DELETE).*?\{.*?\}',
            r'["\'].*?(SELECT|INSERT|UPDATE|DELETE).*?["\']\s*\+\s*\w+',
            r'\.format\(.*?\).*?(SELECT|INSERT|UPDATE|DELETE)',
        ]
        
        issues_found = False
        
        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith('.py'):
                    file_path = Path(root) / file
                    if any(skip in str(file_path) for skip in ['test', 'verify']):
                        continue
                        
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        for pattern in vulnerable_patterns:
                            matches = re.finditer(pattern, content, re.IGNORECASE | re.DOTALL)
                            for match in matches:
                                line_num = content[:match.start()].count('\n') + 1
                                self.verification_results["failed"].append({
                                    "check": "SQL injection protection",
                                    "file": str(file_path.relative_to(self.project_root)),
                                    "line": line_num,
                                    "issue": "Potential SQL injection vulnerability"
                                })
                                issues_found = True
                                print(f"   ‚ùå SQL injection risk in {file_path.name}:{line_num}")
                    except:
                        pass
        
        if not issues_found:
            self.verification_results["passed"].append("SQL injection protection verified")
            print("   ‚úÖ PASSED: SQL injection protection in place")
            return True
        return False
    
    def verify_security_headers(self) -> bool:
        """Verify security headers middleware exists"""
        print("üîç Verifying security headers...")
        
        headers_file = self.project_root / "middleware" / "security_headers_enhanced.py"
        
        if headers_file.exists():
            with open(headers_file, 'r') as f:
                content = f.read()
                
            required_headers = [
                "X-Content-Type-Options",
                "X-Frame-Options",
                "X-XSS-Protection",
                "Strict-Transport-Security",
                "Content-Security-Policy"
            ]
            
            missing_headers = []
            for header in required_headers:
                if header not in content:
                    missing_headers.append(header)
            
            if not missing_headers:
                self.verification_results["passed"].append("Security headers properly configured")
                print("   ‚úÖ PASSED: All security headers present")
                return True
            else:
                self.verification_results["failed"].append({
                    "check": "Security headers",
                    "issue": f"Missing headers: {', '.join(missing_headers)}"
                })
                print(f"   ‚ùå Missing headers: {', '.join(missing_headers)}")
                return False
        else:
            self.verification_results["failed"].append({
                "check": "Security headers",
                "issue": "Security headers middleware not found"
            })
            print("   ‚ùå Security headers middleware not found")
            return False
    
    def verify_input_validation(self) -> bool:
        """Verify input validation is implemented"""
        print("üîç Verifying input validation...")
        
        validator_file = self.project_root / "api" / "validators" / "input_sanitizer.py"
        
        if validator_file.exists():
            self.verification_results["passed"].append("Input validation module exists")
            print("   ‚úÖ PASSED: Input validation module found")
            
            # Check if it's being used in routers
            router_dir = self.project_root / "api" / "routers"
            validators_used = False
            
            for router_file in router_dir.glob("*.py"):
                try:
                    with open(router_file, 'r') as f:
                        if "InputSanitizer" in f.read() or "validator" in f.read():
                            validators_used = True
                            break
                except:
                    pass
            
            if not validators_used:
                self.verification_results["warnings"].append(
                    "Input validation module exists but may not be fully integrated"
                )
                print("   ‚ö†Ô∏è  Warning: Input validators may not be fully integrated")
            
            return True
        else:
            self.verification_results["failed"].append({
                "check": "Input validation",
                "issue": "Input validation module not found"
            })
            print("   ‚ùå Input validation module not found")
            return False
    
    def verify_authentication_security(self) -> bool:
        """Verify authentication security improvements"""
        print("üîç Verifying authentication security...")
        
        auth_file = self.project_root / "api" / "dependencies" / "auth_enhanced.py"
        
        if auth_file.exists():
            with open(auth_file, 'r') as f:
                content = f.read()
            
            required_features = [
                "JWT_SECRET = os.getenv",
                "exp",  # Token expiration
                "verify_token",
                "HTTPBearer"
            ]
            
            missing_features = []
            for feature in required_features:
                if feature not in content:
                    missing_features.append(feature)
            
            if not missing_features:
                self.verification_results["passed"].append("Authentication security enhanced")
                print("   ‚úÖ PASSED: Authentication properly secured")
                return True
            else:
                self.verification_results["failed"].append({
                    "check": "Authentication security",
                    "issue": f"Missing features: {', '.join(missing_features)}"
                })
                print(f"   ‚ùå Missing auth features: {', '.join(missing_features)}")
                return False
        else:
            # Check if original auth file is secure
            orig_auth = self.project_root / "api" / "dependencies" / "auth.py"
            if orig_auth.exists():
                with open(orig_auth, 'r') as f:
                    content = f.read()
                if "os.getenv" in content and "JWT" in content:
                    self.verification_results["passed"].append("Original auth file appears secure")
                    print("   ‚úÖ PASSED: Original auth file appears secure")
                    return True
            
            self.verification_results["warnings"].append("Enhanced auth module not found, check original")
            print("   ‚ö†Ô∏è  Enhanced auth module not found")
            return False
    
    def verify_env_template(self) -> bool:
        """Verify environment template exists"""
        print("üîç Verifying environment configuration...")
        
        env_template = self.project_root / ".env.template"
        env_file = self.project_root / ".env"
        
        if env_template.exists():
            self.verification_results["passed"].append("Environment template exists")
            print("   ‚úÖ PASSED: Environment template found")
            
            if not env_file.exists():
                self.verification_results["warnings"].append(
                    ".env file not configured - copy .env.template to .env and add secrets"
                )
                print("   ‚ö†Ô∏è  Warning: .env file not configured")
            
            return True
        else:
            self.verification_results["failed"].append({
                "check": "Environment configuration",
                "issue": "Environment template not found"
            })
            print("   ‚ùå Environment template not found")
            return False
    
    def check_owasp_compliance(self) -> Dict:
        """Check OWASP Top 10 compliance status"""
        print("üîç Checking OWASP Top 10 compliance...")
        
        owasp_status = {
            "A01_broken_access_control": "NEEDS_REVIEW",
            "A02_cryptographic_failures": "NEEDS_REVIEW",
            "A03_injection": "NEEDS_REVIEW",
            "A04_insecure_design": "NEEDS_REVIEW",
            "A05_security_misconfiguration": "NEEDS_REVIEW",
            "A06_vulnerable_components": "NEEDS_CHECK",
            "A07_identification_failures": "NEEDS_REVIEW",
            "A08_data_integrity_failures": "NEEDS_REVIEW",
            "A09_logging_failures": "NEEDS_REVIEW",
            "A10_server_side_request_forgery": "NEEDS_CHECK"
        }
        
        # Update based on verification results
        if "No hardcoded secrets found" in str(self.verification_results["passed"]):
            owasp_status["A02_cryptographic_failures"] = "IMPROVED"
        
        if "SQL injection protection verified" in str(self.verification_results["passed"]):
            owasp_status["A03_injection"] = "IMPROVED"
        
        if "Authentication security enhanced" in str(self.verification_results["passed"]):
            owasp_status["A07_identification_failures"] = "IMPROVED"
        
        if "Security headers properly configured" in str(self.verification_results["passed"]):
            owasp_status["A05_security_misconfiguration"] = "IMPROVED"
        
        return owasp_status
    
    def generate_verification_report(self):
        """Generate comprehensive verification report"""
        owasp_status = self.check_owasp_compliance()
        
        report = {
            "verification_timestamp": datetime.now().isoformat(),
            "summary": {
                "checks_passed": len(self.verification_results["passed"]),
                "checks_failed": len(self.verification_results["failed"]),
                "warnings": len(self.verification_results["warnings"])
            },
            "verification_results": self.verification_results,
            "owasp_compliance": owasp_status,
            "security_score": {
                "score": len(self.verification_results["passed"]) * 20,
                "max_score": 100,
                "grade": self._calculate_grade(len(self.verification_results["passed"]))
            },
            "recommendations": self._generate_recommendations()
        }
        
        # Save JSON report
        report_path = self.project_root / "security_verification_report.json"
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        # Generate markdown report
        self._generate_markdown_report(report)
        
        return report
    
    def _calculate_grade(self, passed_checks: int) -> str:
        """Calculate security grade"""
        score = passed_checks * 20
        if score >= 90:
            return "A"
        elif score >= 80:
            return "B"
        elif score >= 70:
            return "C"
        elif score >= 60:
            return "D"
        else:
            return "F"
    
    def _generate_recommendations(self) -> List[str]:
        """Generate recommendations based on verification results"""
        recommendations = []
        
        if self.verification_results["failed"]:
            recommendations.append("Address all failed security checks immediately")
        
        if self.verification_results["warnings"]:
            recommendations.append("Review and address warning items")
        
        recommendations.extend([
            "Implement continuous security monitoring",
            "Schedule regular security audits",
            "Keep dependencies updated",
            "Implement rate limiting on all endpoints",
            "Add comprehensive audit logging"
        ])
        
        return recommendations
    
    def _generate_markdown_report(self, report: dict):
        """Generate markdown verification report"""
        grade_emoji = {
            "A": "üèÜ",
            "B": "‚úÖ",
            "C": "‚ö†Ô∏è",
            "D": "‚ö°",
            "F": "‚ùå"
        }
        
        md_content = f"""# Security Verification Report

Generated: {report['verification_timestamp']}

## Security Score: {report['security_score']['score']}/100 {grade_emoji.get(report['security_score']['grade'], '')} Grade: {report['security_score']['grade']}

## Summary
- ‚úÖ Checks Passed: {report['summary']['checks_passed']}
- ‚ùå Checks Failed: {report['summary']['checks_failed']}
- ‚ö†Ô∏è  Warnings: {report['summary']['warnings']}

## Verification Results

### Passed Checks ‚úÖ
"""
        for check in report['verification_results']['passed']:
            md_content += f"- {check}\n"
        
        if report['verification_results']['failed']:
            md_content += "\n### Failed Checks ‚ùå\n"
            for check in report['verification_results']['failed']:
                if isinstance(check, dict):
                    md_content += f"- **{check.get('check', 'Unknown')}**: {check.get('issue', 'Unknown issue')}\n"
                    if 'file' in check:
                        md_content += f"  - File: `{check['file']}`\n"
        
        if report['verification_results']['warnings']:
            md_content += "\n### Warnings ‚ö†Ô∏è\n"
            for warning in report['verification_results']['warnings']:
                md_content += f"- {warning}\n"
        
        md_content += "\n## OWASP Top 10 Compliance\n"
        for item, status in report['owasp_compliance'].items():
            icon = "‚úÖ" if "IMPROVED" in status else "‚ö†Ô∏è"
            md_content += f"- {icon} **{item}**: {status}\n"
        
        md_content += "\n## Recommendations\n"
        for i, rec in enumerate(report['recommendations'], 1):
            md_content += f"{i}. {rec}\n"
        
        md_path = self.project_root / "SECURITY_VERIFICATION_REPORT.md"
        with open(md_path, 'w') as f:
            f.write(md_content)
        
        print(f"\n‚úÖ Verification report saved to: {md_path}")
    
    def run_verification(self):
        """Execute comprehensive security verification"""
        print("\nüõ°Ô∏è Security Verification Starting...")
        print("="*60)
        
        # Run all verification checks
        checks = [
            self.verify_no_hardcoded_secrets(),
            self.verify_sql_injection_protection(),
            self.verify_security_headers(),
            self.verify_input_validation(),
            self.verify_authentication_security(),
            self.verify_env_template()
        ]
        
        # Generate report
        print("\nüìä Generating verification report...")
        report = self.generate_verification_report()
        
        print("\n" + "="*60)
        print(f"üõ°Ô∏è SECURITY VERIFICATION COMPLETE")
        print("="*60)
        
        print(f"\nüìà Security Score: {report['security_score']['score']}/100 (Grade: {report['security_score']['grade']})")
        print(f"\n‚úÖ Passed: {report['summary']['checks_passed']}")
        print(f"‚ùå Failed: {report['summary']['checks_failed']}")
        print(f"‚ö†Ô∏è  Warnings: {report['summary']['warnings']}")
        
        if report['summary']['checks_failed'] > 0:
            print("\nüö® CRITICAL: Security issues detected!")
            print("   Review SECURITY_VERIFICATION_REPORT.md for details")
            print("   Run: python security_vulnerability_fix.py to apply fixes")
        else:
            print("\n‚úÖ All critical security checks passed!")
        
        print("\nüìã Reports Generated:")
        print("   - security_verification_report.json")
        print("   - SECURITY_VERIFICATION_REPORT.md")
        
        return report

if __name__ == "__main__":
    verifier = SecurityVerifier()
    verifier.run_verification()