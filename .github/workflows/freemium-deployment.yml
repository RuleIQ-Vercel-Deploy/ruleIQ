name: Deploy Freemium Strategy to Production

on:
  push:
    branches:
      - main
    paths:
      - "api/routers/freemium.py"
      - "services/freemium/**"
      - "database/models/freemium.py"
      - "frontend/app/(public)/freemium/**"
      - "frontend/components/freemium/**"
      - "docker-compose.freemium.yml"
      - "Dockerfile.freemium"

  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production

concurrency:
  group: freemium-deployment-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel production deployments

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ruleiq/freemium-api

jobs:
  # Security and Quality Gates
  security-scan:
    runs-on: ubuntu-latest
    outputs:
      security-passed: ${{ steps.security-check.outputs.passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Run Trivy security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Security check result
        id: security-check
        run: |
          if [ -f trivy-results.sarif ]; then
            # Check if there are any HIGH or CRITICAL vulnerabilities
            HIGH_CRITICAL=$(jq '.runs[0].results | length' trivy-results.sarif 2>/dev/null || echo "0")
            if [ "$HIGH_CRITICAL" -gt 0 ]; then
              echo "‚ùå High/Critical vulnerabilities found: $HIGH_CRITICAL"
              echo "passed=false" >> $GITHUB_OUTPUT
              exit 1
            else
              echo "‚úÖ No high/critical vulnerabilities found"
              echo "passed=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "passed=true" >> $GITHUB_OUTPUT
          fi

  # Backend Tests
  backend-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest-cov pytest-xdist

      - name: Set up test environment
        run: |
          cp .env.example .env
          echo "DATABASE_URL=postgresql://postgres:postgres@localhost:5432/test_db" >> .env
          echo "REDIS_URL=redis://localhost:6379" >> .env
          echo "ENV=test" >> .env

      - name: Run database migrations
        run: |
          python -m alembic upgrade head

      - name: Run freemium-specific tests
        run: |
          pytest tests/integration/api/test_freemium_endpoints.py -v --cov=api.routers.freemium --cov=services.freemium --cov-report=xml --cov-report=html
          pytest tests/unit/services/test_freemium_service.py -v --cov-append --cov-report=xml
          pytest tests/security/test_freemium_security.py -v --cov-append --cov-report=xml

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: freemium-backend
          name: freemium-backend-coverage

      - name: Check test coverage threshold
        run: |
          COVERAGE=$(python -c "import xml.etree.ElementTree as ET; tree = ET.parse('coverage.xml'); root = tree.getroot(); print(float(root.attrib['line-rate']) * 100)")
          echo "Coverage: $COVERAGE%"
          if (( $(echo "$COVERAGE < 85" | bc -l) )); then
            echo "‚ùå Coverage $COVERAGE% is below 85% threshold"
            exit 1
          fi
          echo "‚úÖ Coverage $COVERAGE% meets threshold"

  # Frontend Tests
  frontend-tests:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Node.js and pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 8

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'
          cache-dependency-path: frontend/pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install

      - name: Run freemium frontend tests
        run: |
          pnpm test -- --testPathPattern="freemium" --coverage --coverageReporters=json --coverageReporters=lcov

      - name: Build freemium pages
        run: |
          pnpm build
        env:
          NEXT_PUBLIC_API_URL: https://api.ruleiq.com

      - name: Upload frontend coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./frontend/coverage/lcov.info
          flags: freemium-frontend
          name: freemium-frontend-coverage

  # Load Testing
  load-testing:
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up test environment
        run: |
          docker-compose -f docker-compose.freemium.yml up -d
          sleep 30  # Wait for services to be ready

      - name: Install k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run freemium endpoint load tests
        run: |
          k6 run --vus 100 --duration 2m tests/load/freemium-endpoints.js

      - name: Clean up test environment
        if: always()
        run: |
          docker-compose -f docker-compose.freemium.yml down -v

  # Build and Push Images
  build-and-push:
    runs-on: ubuntu-latest
    needs: [security-scan, backend-tests, frontend-tests, load-testing]
    if: needs.security-scan.outputs.security-passed == 'true'
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=freemium-latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.freemium
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  # Deploy to Staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.ruleiq.com/freemium

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.STAGING_KUBECONFIG }}

      - name: Deploy to staging
        run: |
          helm upgrade --install ruleiq-freemium-staging ./helm/ruleiq-freemium \
            --namespace staging \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ needs.build-and-push.outputs.image-tag }} \
            --set environment=staging \
            --set replicas=2 \
            --set resources.limits.cpu=1 \
            --set resources.limits.memory=1Gi \
            --values ./helm/ruleiq-freemium/values-staging.yaml

      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/ruleiq-freemium-staging -n staging --timeout=300s

      - name: Run smoke tests
        run: |
          sleep 30
          curl -f https://staging.ruleiq.com/freemium/health || exit 1
          curl -f https://staging.ruleiq.com/api/v1/freemium/health || exit 1

  # Deploy to Production
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production'
    environment:
      name: production
      url: https://ruleiq.com/freemium

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.PRODUCTION_KUBECONFIG }}

      - name: Pre-deployment database backup
        run: |
          echo "Creating database backup before deployment..."
          kubectl create job --from=cronjob/postgres-backup backup-pre-freemium-$(date +%Y%m%d-%H%M%S) -n production

      - name: Deploy to production with blue-green strategy
        run: |
          # Deploy to green environment first
          helm upgrade --install ruleiq-freemium-green ./helm/ruleiq-freemium \
            --namespace production \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ needs.build-and-push.outputs.image-tag }} \
            --set environment=production \
            --set replicas=4 \
            --set resources.limits.cpu=2 \
            --set resources.limits.memory=2Gi \
            --set service.name=ruleiq-freemium-green \
            --values ./helm/ruleiq-freemium/values-production.yaml

      - name: Wait for green deployment
        run: |
          kubectl rollout status deployment/ruleiq-freemium-green -n production --timeout=600s

      - name: Health check green deployment
        run: |
          sleep 60
          for i in {1..10}; do
            if curl -f https://green.ruleiq.com/freemium/health; then
              echo "Green deployment healthy"
              break
            fi
            echo "Health check attempt $i failed, retrying..."
            sleep 30
          done

      - name: Switch traffic to green deployment
        run: |
          # Update ingress to point to green service
          kubectl patch ingress ruleiq-freemium-ingress -n production -p '{"spec":{"rules":[{"host":"ruleiq.com","http":{"paths":[{"path":"/freemium","pathType":"Prefix","backend":{"service":{"name":"ruleiq-freemium-green","port":{"number":80}}}}]}}]}}'
          
          # Wait for traffic switch
          sleep 30

      - name: Final health check
        run: |
          for i in {1..5}; do
            if curl -f https://ruleiq.com/freemium/health; then
              echo "Production deployment successful"
              break
            fi
            echo "Production health check attempt $i failed, retrying..."
            sleep 30
          done

      - name: Clean up old blue deployment
        if: success()
        run: |
          # Remove old blue deployment after successful green deployment
          helm uninstall ruleiq-freemium-blue -n production || echo "No blue deployment to remove"
          
          # Rename green to blue for next deployment
          kubectl patch deployment ruleiq-freemium-green -n production -p '{"metadata":{"name":"ruleiq-freemium-blue"}}'
          kubectl patch service ruleiq-freemium-green -n production -p '{"metadata":{"name":"ruleiq-freemium-blue"}}'

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, rolling back..."
          kubectl patch ingress ruleiq-freemium-ingress -n production -p '{"spec":{"rules":[{"host":"ruleiq.com","http":{"paths":[{"path":"/freemium","pathType":"Prefix","backend":{"service":{"name":"ruleiq-freemium-blue","port":{"number":80}}}}]}}]}}'
          helm uninstall ruleiq-freemium-green -n production

  # Post-deployment monitoring
  post-deployment-monitoring:
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && needs.deploy-production.result == 'success'
    steps:
      - name: Monitor deployment metrics
        run: |
          echo "Setting up post-deployment monitoring..."
          
          # Check key metrics for 10 minutes
          for i in {1..20}; do
            echo "Monitoring check $i/20..."
            
            # Check error rate (should be < 1%)
            ERROR_RATE=$(curl -s "https://monitoring.ruleiq.com/api/v1/query?query=rate(http_requests_total{status=~'5..'}[5m])" | jq '.data.result[0].value[1] // "0"' | tr -d '"')
            
            # Check response time (should be < 200ms)
            RESPONSE_TIME=$(curl -s "https://monitoring.ruleiq.com/api/v1/query?query=histogram_quantile(0.95,rate(http_request_duration_seconds_bucket[5m]))" | jq '.data.result[0].value[1] // "0"' | tr -d '"')
            
            echo "Error rate: $ERROR_RATE, Response time: $RESPONSE_TIME"
            
            # Alert if metrics exceed thresholds
            if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
              echo "‚ö†Ô∏è  High error rate detected: $ERROR_RATE"
              # Send alert to Slack/PagerDuty
            fi
            
            if (( $(echo "$RESPONSE_TIME > 0.2" | bc -l) )); then
              echo "‚ö†Ô∏è  High response time detected: $RESPONSE_TIME"
              # Send alert to Slack/PagerDuty
            fi
            
            sleep 30
          done

      - name: Update deployment status
        run: |
          echo "‚úÖ Freemium strategy deployment completed successfully"
          echo "üîç Monitoring will continue for the next 24 hours"